import {
  require_base64_js,
  require_buffer
} from "./chunk-2V4JDYVR.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-AC2VUBZ6.js";

// node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash3.outputLen);
  number(hash3.blockLen);
}
function exists(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance2) {
  bytes(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert, assert_default;
var init_assert = __esm({
  "node_modules/@noble/hashes/esm/_assert.js"() {
    assert = {
      number,
      bool,
      bytes,
      hash,
      exists,
      output
    };
    assert_default = assert;
  }
});

// node_modules/@noble/hashes/esm/crypto.js
var crypto2;
var init_crypto = __esm({
  "node_modules/@noble/hashes/esm/crypto.js"() {
    crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/esm/utils.js
function utf8ToBytes(str2) {
  if (typeof str2 !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str2}`);
  }
  return new TextEncoder().encode(str2);
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!(data instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
function wrapConstructor(hashConstructor) {
  const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
var u32, createView, rotr, isLE, hexes, Hash;
var init_utils = __esm({
  "node_modules/@noble/hashes/esm/utils.js"() {
    init_crypto();
    u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    rotr = (word, shift) => word << 32 - shift | word >>> shift;
    isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!isLE)
      throw new Error("Non little-endian hardware is not supported");
    hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
  }
});

// node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
var SHA2;
var init_sha2 = __esm({
  "node_modules/@noble/hashes/esm/_sha2.js"() {
    init_assert();
    init_utils();
    SHA2 = class extends Hash {
      constructor(blockLen, outputLen, padOffset, isLE2) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE2;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
      }
      update(data) {
        assert_default.exists(this);
        const { view, buffer, blockLen } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = createView(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        assert_default.exists(this);
        assert_default.output(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE: isLE2 } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE2);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished: finished2, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished2;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
  }
});

// node_modules/@noble/hashes/esm/_u64.js
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var U32_MASK64, _32n, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add3L, add3H, add4L, add4H, add5L, add5H, u64, u64_default;
var init_u64 = __esm({
  "node_modules/@noble/hashes/esm/_u64.js"() {
    U32_MASK64 = BigInt(2 ** 32 - 1);
    _32n = BigInt(32);
    toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    shrSH = (h, l, s) => h >>> s;
    shrSL = (h, l, s) => h << 32 - s | l >>> s;
    rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    rotr32H = (h, l) => l;
    rotr32L = (h, l) => h;
    rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    u64_default = u64;
  }
});

// node_modules/@noble/hashes/esm/sha512.js
var SHA512_Kh, SHA512_Kl, SHA512_W_H, SHA512_W_L, SHA512, SHA512_224, SHA512_256, SHA384, sha512, sha512_224, sha512_256, sha384;
var init_sha512 = __esm({
  "node_modules/@noble/hashes/esm/sha512.js"() {
    init_sha2();
    init_u64();
    init_utils();
    [SHA512_Kh, SHA512_Kl] = u64_default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n)));
    SHA512_W_H = new Uint32Array(80);
    SHA512_W_L = new Uint32Array(80);
    SHA512 = class extends SHA2 {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset3) {
        for (let i = 0; i < 16; i++, offset3 += 4) {
          SHA512_W_H[i] = view.getUint32(offset3);
          SHA512_W_L[i] = view.getUint32(offset3 += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
          const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
          const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
          const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
          const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
          const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = u64_default.add3L(T1l, sigma0l, MAJl);
          Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    SHA512_224 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 2352822216 | 0;
        this.Al = 424955298 | 0;
        this.Bh = 1944164710 | 0;
        this.Bl = 2312950998 | 0;
        this.Ch = 502970286 | 0;
        this.Cl = 855612546 | 0;
        this.Dh = 1738396948 | 0;
        this.Dl = 1479516111 | 0;
        this.Eh = 258812777 | 0;
        this.El = 2077511080 | 0;
        this.Fh = 2011393907 | 0;
        this.Fl = 79989058 | 0;
        this.Gh = 1067287976 | 0;
        this.Gl = 1780299464 | 0;
        this.Hh = 286451373 | 0;
        this.Hl = 2446758561 | 0;
        this.outputLen = 28;
      }
    };
    SHA512_256 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    SHA384 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    sha512 = wrapConstructor(() => new SHA512());
    sha512_224 = wrapConstructor(() => new SHA512_224());
    sha512_256 = wrapConstructor(() => new SHA512_256());
    sha384 = wrapConstructor(() => new SHA384());
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@noble/ed25519/lib/esm/index.js
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function assertExtPoint(other) {
  if (!(other instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(other) {
  if (!(other instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
function concatBytes(...arrays) {
  if (!arrays.every((a) => a instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex2 += hexes2[uint8a[i]];
  }
  return hex2;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex2);
  }
  if (hex2.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array4 = new Uint8Array(hex2.length / 2);
  for (let i = 0; i < array4.length; i++) {
    const j = i * 2;
    const hexByte = hex2.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array4[i] = byte;
  }
  return array4;
}
function numberTo32BytesBE(num) {
  const length = 32;
  const hex2 = num.toString(16).padStart(length * 2, "0");
  return hexToBytes(hex2);
}
function numberTo32BytesLE(num) {
  return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
  return (mod(num) & _1n) === _1n;
}
function bytesToNumberLE(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex(Uint8Array.from(uint8a).reverse()));
}
function bytes255ToNumberLE(bytes2) {
  return mod(bytesToNumberLE(bytes2) & MAX_255B);
}
function mod(a, b = CURVE.P) {
  const res = a % b;
  return res >= _0n ? res : b + res;
}
function invert(number4, modulo = CURVE.P) {
  if (number4 === _0n || modulo <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number4} mod=${modulo}`);
  }
  let a = mod(number4, modulo);
  let b = modulo;
  let x = _0n, y = _1n, u = _1n, v = _0n;
  while (a !== _0n) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = acc;
    return mod(acc * num, p);
  }, _1n);
  const inverted = invert(lastMultiplied, p);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = mod(acc * tmp[i], p);
    return mod(acc * num, p);
  }, inverted);
  return tmp;
}
function pow2(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n) {
    res *= res;
    res %= P;
  }
  return res;
}
function pow_2_252_3(x) {
  const { P } = CURVE;
  const _5n = BigInt(5);
  const _10n = BigInt(10);
  const _20n = BigInt(20);
  const _40n = BigInt(40);
  const _80n = BigInt(80);
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n) * b2 % P;
  const b5 = pow2(b4, _1n) * x % P;
  const b10 = pow2(b5, _5n) * b5 % P;
  const b20 = pow2(b10, _10n) * b10 % P;
  const b40 = pow2(b20, _20n) * b20 % P;
  const b80 = pow2(b40, _40n) * b40 % P;
  const b160 = pow2(b80, _80n) * b80 % P;
  const b240 = pow2(b160, _80n) * b80 % P;
  const b250 = pow2(b240, _10n) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n) * x % P;
  return { pow_p_5_8, b2 };
}
function uvRatio(u, v) {
  const v32 = mod(v * v * v);
  const v7 = mod(v32 * v32 * v);
  const pow = pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v32 * pow);
  const vx2 = mod(v * x * x);
  const root1 = x;
  const root2 = mod(x * SQRT_M1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u);
  const noRoot = vx2 === mod(-u * SQRT_M1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (edIsNegative(x))
    x = mod(-x);
  return { isValid: useRoot1 || useRoot2, value: x };
}
function invertSqrt(number4) {
  return uvRatio(_1n, number4);
}
function modlLE(hash3) {
  return mod(bytesToNumberLE(hash3), CURVE.l);
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}
function ensureBytes(hex2, expectedLength) {
  const bytes2 = hex2 instanceof Uint8Array ? Uint8Array.from(hex2) : hexToBytes(hex2);
  if (typeof expectedLength === "number" && bytes2.length !== expectedLength)
    throw new Error(`Expected ${expectedLength} bytes`);
  return bytes2;
}
function normalizeScalar(num, max, strict = true) {
  if (!max)
    throw new TypeError("Specify max value");
  if (typeof num === "number" && Number.isSafeInteger(num))
    num = BigInt(num);
  if (typeof num === "bigint" && num < max) {
    if (strict) {
      if (_0n < num)
        return num;
    } else {
      if (_0n <= num)
        return num;
    }
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function checkPrivateKey(key) {
  key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);
  if (key.length !== 32)
    throw new Error(`Expected 32 bytes`);
  return key;
}
function getKeyFromHash(hashed) {
  const head = adjustBytes25519(hashed.slice(0, 32));
  const prefix = hashed.slice(32, 64);
  const scalar = modlLE(head);
  const point = Point.BASE.multiply(scalar);
  const pointBytes = point.toRawBytes();
  return { head, prefix, scalar, point, pointBytes };
}
function sha512s(...m) {
  if (typeof _sha512Sync !== "function")
    throw new Error("utils.sha512Sync must be set to use sync methods");
  return _sha512Sync(...m);
}
async function getExtendedPublicKey(key) {
  return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));
}
function getExtendedPublicKeySync(key) {
  return getKeyFromHash(sha512s(checkPrivateKey(key)));
}
function getPublicKeySync(privateKey) {
  return getExtendedPublicKeySync(privateKey).pointBytes;
}
function signSync(message, privateKey) {
  message = ensureBytes(message);
  const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);
  const r = modlLE(sha512s(prefix, message));
  const R = Point.BASE.multiply(r);
  const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));
  const s = mod(r + k * scalar, CURVE.l);
  return new Signature(R, s).toRawBytes();
}
function prepareVerification(sig, message, publicKey4) {
  message = ensureBytes(message);
  if (!(publicKey4 instanceof Point))
    publicKey4 = Point.fromHex(publicKey4, false);
  const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);
  const SB = ExtendedPoint.BASE.multiplyUnsafe(s);
  return { r, s, SB, pub: publicKey4, msg: message };
}
function finishVerification(publicKey4, r, SB, hashed) {
  const k = modlLE(hashed);
  const kA = ExtendedPoint.fromAffine(publicKey4).multiplyUnsafe(k);
  const RkA = ExtendedPoint.fromAffine(r).add(kA);
  return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
function verifySync(sig, message, publicKey4) {
  const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey4);
  const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);
  return finishVerification(pub, r, SB, hashed);
}
var nodeCrypto, _0n, _1n, _2n, _8n, CU_O, CURVE, POW_2_256, SQRT_M1, SQRT_D, SQRT_AD_MINUS_ONE, INVSQRT_A_MINUS_D, ONE_MINUS_D_SQ, D_MINUS_ONE_SQ, ExtendedPoint, RistrettoPoint, pointPrecomputes, Point, Signature, hexes2, MAX_255B, _sha512Sync, sync, crypto3, utils;
var init_esm = __esm({
  "node_modules/@noble/ed25519/lib/esm/index.js"() {
    nodeCrypto = __toESM(require_crypto());
    _0n = BigInt(0);
    _1n = BigInt(1);
    _2n = BigInt(2);
    _8n = BigInt(8);
    CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
    CURVE = Object.freeze({
      a: BigInt(-1),
      d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
      P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
      l: CU_O,
      n: CU_O,
      h: BigInt(8),
      Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
      Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
    });
    POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    SQRT_D = BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
    SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
    INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
    ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
    D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
    ExtendedPoint = class {
      constructor(x, y, z, t) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.t = t;
      }
      static fromAffine(p) {
        if (!(p instanceof Point)) {
          throw new TypeError("ExtendedPoint#fromAffine: expected Point");
        }
        if (p.equals(Point.ZERO))
          return ExtendedPoint.ZERO;
        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));
      }
      static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
      }
      static normalizeZ(points) {
        return this.toAffineBatch(points).map(this.fromAffine);
      }
      equals(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const X1Z2 = mod(X1 * Z2);
        const X2Z1 = mod(X2 * Z1);
        const Y1Z2 = mod(Y1 * Z2);
        const Y2Z1 = mod(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      negate() {
        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));
      }
      double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const { a } = CURVE;
        const A = mod(X1 * X1);
        const B = mod(Y1 * Y1);
        const C = mod(_2n * mod(Z1 * Z1));
        const D = mod(a * A);
        const x1y1 = X1 + Y1;
        const E = mod(mod(x1y1 * x1y1) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = mod(E * F);
        const Y3 = mod(G * H);
        const T3 = mod(E * H);
        const Z3 = mod(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
      }
      add(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1, t: T1 } = this;
        const { x: X2, y: Y2, z: Z2, t: T2 } = other;
        const A = mod((Y1 - X1) * (Y2 + X2));
        const B = mod((Y1 + X1) * (Y2 - X2));
        const F = mod(B - A);
        if (F === _0n)
          return this.double();
        const C = mod(Z1 * _2n * T2);
        const D = mod(T1 * _2n * Z2);
        const E = D + C;
        const G = B + A;
        const H = D - C;
        const X3 = mod(E * F);
        const Y3 = mod(G * H);
        const T3 = mod(E * H);
        const Z3 = mod(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      precomputeWindow(W) {
        const windows = 1 + 256 / W;
        const points = [];
        let p = this;
        let base = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1; i < 2 ** (W - 1); i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      }
      wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(ExtendedPoint.BASE))
          affinePoint = Point.BASE;
        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W) {
          throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
          precomputes = this.precomputeWindow(W);
          if (affinePoint && W !== 1) {
            precomputes = ExtendedPoint.normalizeZ(precomputes);
            pointPrecomputes.set(affinePoint, precomputes);
          }
        }
        let p = ExtendedPoint.ZERO;
        let f2 = ExtendedPoint.BASE;
        const windows = 1 + 256 / W;
        const windowSize = 2 ** (W - 1);
        const mask3 = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset3 = window2 * windowSize;
          let wbits = Number(n & mask3);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n;
          }
          const offset1 = offset3;
          const offset22 = offset3 + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset22]));
          }
        }
        return ExtendedPoint.normalizeZ([p, f2])[0];
      }
      multiply(scalar, affinePoint) {
        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
      }
      multiplyUnsafe(scalar) {
        let n = normalizeScalar(scalar, CURVE.l, false);
        const G = ExtendedPoint.BASE;
        const P0 = ExtendedPoint.ZERO;
        if (n === _0n)
          return P0;
        if (this.equals(P0) || n === _1n)
          return this;
        if (this.equals(G))
          return this.wNAF(n);
        let p = P0;
        let d = this;
        while (n > _0n) {
          if (n & _1n)
            p = p.add(d);
          d = d.double();
          n >>= _1n;
        }
        return p;
      }
      isSmallOrder() {
        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
      }
      isTorsionFree() {
        let p = this.multiplyUnsafe(CURVE.l / _2n).double();
        if (CURVE.l % _2n)
          p = p.add(this);
        return p.equals(ExtendedPoint.ZERO);
      }
      toAffine(invZ) {
        const { x, y, z } = this;
        const is0 = this.equals(ExtendedPoint.ZERO);
        if (invZ == null)
          invZ = is0 ? _8n : invert(z);
        const ax = mod(x * invZ);
        const ay = mod(y * invZ);
        const zz = mod(z * invZ);
        if (is0)
          return Point.ZERO;
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return new Point(ax, ay);
      }
      fromRistrettoBytes() {
        legacyRist();
      }
      toRistrettoBytes() {
        legacyRist();
      }
      fromRistrettoHash() {
        legacyRist();
      }
    };
    ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));
    ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
    RistrettoPoint = class {
      constructor(ep) {
        this.ep = ep;
      }
      static calcElligatorRistrettoMap(r0) {
        const { d } = CURVE;
        const r = mod(SQRT_M1 * r0 * r0);
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod((c - d * r) * mod(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod(s * r0);
        if (!edIsNegative(s_))
          s_ = mod(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod((s + s) * D);
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod(_1n - s2);
        const W3 = mod(_1n + s2);
        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
      }
      static hashToCurve(hex2) {
        hex2 = ensureBytes(hex2, 64);
        const r1 = bytes255ToNumberLE(hex2.slice(0, 32));
        const R1 = this.calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex2.slice(32, 64));
        const R2 = this.calcElligatorRistrettoMap(r2);
        return new RistrettoPoint(R1.add(R2));
      }
      static fromHex(hex2) {
        hex2 = ensureBytes(hex2, 32);
        const { a, d } = CURVE;
        const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
        const s = bytes255ToNumberLE(hex2);
        if (!equalBytes(numberTo32BytesLE(s), hex2) || edIsNegative(s))
          throw new Error(emsg);
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2);
        const u2 = mod(_1n - a * s2);
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod(v * u2_2));
        const Dx = mod(I * u2);
        const Dy = mod(I * Dx * v);
        let x = mod((s + s) * Dx);
        if (edIsNegative(x))
          x = mod(-x);
        const y = mod(u1 * Dy);
        const t = mod(x * y);
        if (!isValid || edIsNegative(t) || y === _0n)
          throw new Error(emsg);
        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));
      }
      toRawBytes() {
        let { x, y, z, t } = this.ep;
        const u1 = mod(mod(z + y) * mod(z - y));
        const u2 = mod(x * y);
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
        const D1 = mod(invsqrt * u1);
        const D2 = mod(invsqrt * u2);
        const zInv = mod(D1 * D2 * t);
        let D;
        if (edIsNegative(t * zInv)) {
          let _x = mod(y * SQRT_M1);
          let _y = mod(x * SQRT_M1);
          x = _x;
          y = _y;
          D = mod(D1 * INVSQRT_A_MINUS_D);
        } else {
          D = D2;
        }
        if (edIsNegative(x * zInv))
          y = mod(-y);
        let s = mod((z - y) * D);
        if (edIsNegative(s))
          s = mod(-s);
        return numberTo32BytesLE(s);
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
      toString() {
        return this.toHex();
      }
      equals(other) {
        assertRstPoint(other);
        const a = this.ep;
        const b = other.ep;
        const one = mod(a.x * b.y) === mod(a.y * b.x);
        const two = mod(a.y * b.y) === mod(a.x * b.x);
        return one || two;
      }
      add(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.add(other.ep));
      }
      subtract(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.subtract(other.ep));
      }
      multiply(scalar) {
        return new RistrettoPoint(this.ep.multiply(scalar));
      }
      multiplyUnsafe(scalar) {
        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
      }
    };
    RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
    RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
    pointPrecomputes = /* @__PURE__ */ new WeakMap();
    Point = class {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      static fromHex(hex2, strict = true) {
        const { d, P } = CURVE;
        hex2 = ensureBytes(hex2, 32);
        const normed = hex2.slice();
        normed[31] = hex2[31] & ~128;
        const y = bytesToNumberLE(normed);
        if (strict && y >= P)
          throw new Error("Expected 0 < hex < P");
        if (!strict && y >= POW_2_256)
          throw new Error("Expected 0 < hex < 2**256");
        const y2 = mod(y * y);
        const u = mod(y2 - _1n);
        const v = mod(d * y2 + _1n);
        let { isValid, value: x } = uvRatio(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n) === _1n;
        const isLastByteOdd = (hex2[31] & 128) !== 0;
        if (isLastByteOdd !== isXOdd) {
          x = mod(-x);
        }
        return new Point(x, y);
      }
      static async fromPrivateKey(privateKey) {
        return (await getExtendedPublicKey(privateKey)).point;
      }
      toRawBytes() {
        const bytes2 = numberTo32BytesLE(this.y);
        bytes2[31] |= this.x & _1n ? 128 : 0;
        return bytes2;
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
      toX25519() {
        const { y } = this;
        const u = mod((_1n + y) * invert(_1n - y));
        return numberTo32BytesLE(u);
      }
      isTorsionFree() {
        return ExtendedPoint.fromAffine(this).isTorsionFree();
      }
      equals(other) {
        return this.x === other.x && this.y === other.y;
      }
      negate() {
        return new Point(mod(-this.x), this.y);
      }
      add(other) {
        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
    };
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
    Point.ZERO = new Point(_0n, _1n);
    Signature = class {
      constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
      }
      static fromHex(hex2) {
        const bytes2 = ensureBytes(hex2, 64);
        const r = Point.fromHex(bytes2.slice(0, 32), false);
        const s = bytesToNumberLE(bytes2.slice(32, 64));
        return new Signature(r, s);
      }
      assertValidity() {
        const { r, s } = this;
        if (!(r instanceof Point))
          throw new Error("Expected Point instance");
        normalizeScalar(s, CURVE.l, false);
        return this;
      }
      toRawBytes() {
        const u84 = new Uint8Array(64);
        u84.set(this.r.toRawBytes());
        u84.set(numberTo32BytesLE(this.s), 32);
        return u84;
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
    };
    hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    sync = {
      getExtendedPublicKey: getExtendedPublicKeySync,
      getPublicKey: getPublicKeySync,
      sign: signSync,
      verify: verifySync
    };
    Point.BASE._setWindowSize(8);
    crypto3 = {
      node: nodeCrypto,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
    utils = {
      bytesToHex,
      hexToBytes,
      concatBytes,
      getExtendedPublicKey,
      mod,
      invert,
      TORSION_SUBGROUP: [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ],
      hashToPrivateScalar: (hash3) => {
        hash3 = ensureBytes(hash3);
        if (hash3.length < 40 || hash3.length > 1024)
          throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
        return mod(bytesToNumberLE(hash3), CURVE.l - _1n) + _1n;
      },
      randomBytes: (bytesLength = 32) => {
        if (crypto3.web) {
          return crypto3.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto3.node) {
          const { randomBytes } = crypto3.node;
          return new Uint8Array(randomBytes(bytesLength).buffer);
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      },
      randomPrivateKey: () => {
        return utils.randomBytes(32);
      },
      sha512: async (...messages2) => {
        const message = concatBytes(...messages2);
        if (crypto3.web) {
          const buffer = await crypto3.web.subtle.digest("SHA-512", message.buffer);
          return new Uint8Array(buffer);
        } else if (crypto3.node) {
          return Uint8Array.from(crypto3.node.createHash("sha512").update(message).digest());
        } else {
          throw new Error("The environment doesn't have sha512 function");
        }
      },
      precompute(windowSize = 8, point = Point.BASE) {
        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_2n);
        return cached;
      },
      sha512Sync: void 0
    };
    Object.defineProperties(utils, {
      sha512Sync: {
        configurable: false,
        get() {
          return _sha512Sync;
        },
        set(val) {
          if (!_sha512Sync)
            _sha512Sync = val;
        }
      }
    });
  }
});

// browser-external:buffer
var require_buffer2 = __commonJS({
  "browser-external:buffer"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert5(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN3(number4, base, endian) {
        if (BN3.isBN(number4)) {
          return number4;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number4 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number4 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN3;
      } else {
        exports3.BN = BN3;
      }
      BN3.BN = BN3;
      BN3.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = require_buffer2().Buffer;
        }
      } catch (e) {
      }
      BN3.isBN = function isBN(num) {
        if (num instanceof BN3) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN3.wordSize && Array.isArray(num.words);
      };
      BN3.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN3.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN3.prototype._init = function init(number4, base, endian) {
        if (typeof number4 === "number") {
          return this._initNumber(number4, base, endian);
        }
        if (typeof number4 === "object") {
          return this._initArray(number4, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert5(base === (base | 0) && base >= 2 && base <= 36);
        number4 = number4.toString().replace(/\s+/g, "");
        var start = 0;
        if (number4[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number4.length) {
          if (base === 16) {
            this._parseHex(number4, start, endian);
          } else {
            this._parseBase(number4, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN3.prototype._initNumber = function _initNumber(number4, base, endian) {
        if (number4 < 0) {
          this.negative = 1;
          number4 = -number4;
        }
        if (number4 < 67108864) {
          this.words = [number4 & 67108863];
          this.length = 1;
        } else if (number4 < 4503599627370496) {
          this.words = [
            number4 & 67108863,
            number4 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert5(number4 < 9007199254740992);
          this.words = [
            number4 & 67108863,
            number4 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN3.prototype._initArray = function _initArray(number4, base, endian) {
        assert5(typeof number4.length === "number");
        if (number4.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number4.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number4.length - 1, j = 0; i >= 0; i -= 3) {
            w = number4[i] | number4[i - 1] << 8 | number4[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number4.length; i += 3) {
            w = number4[i] | number4[i + 1] << 8 | number4[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string3, index2) {
        var c = string3.charCodeAt(index2);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert5(false, "Invalid character in " + string3);
        }
      }
      function parseHexByte(string3, lowerBound, index2) {
        var r = parseHex4Bits(string3, index2);
        if (index2 - 1 >= lowerBound) {
          r |= parseHex4Bits(string3, index2 - 1) << 4;
        }
        return r;
      }
      BN3.prototype._parseHex = function _parseHex(number4, start, endian) {
        this.length = Math.ceil((number4.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number4.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number4, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number4.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number4.length; i += 2) {
            w = parseHexByte(number4, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str2, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str2.length, end);
        for (var i = start; i < len; i++) {
          var c = str2.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert5(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN3.prototype._parseBase = function _parseBase(number4, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number4.length - start;
        var mod3 = total % limbLen;
        var end = Math.min(total, total - mod3) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number4, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod3 !== 0) {
          var pow = 1;
          word = parseBase(number4, i, number4.length, base);
          for (i = 0; i < mod3; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN3.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN3.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN3.prototype.clone = function clone() {
        var r = new BN3(null);
        this.copy(r);
        return r;
      };
      BN3.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN3.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN3.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN3.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN3.prototype.inspect = inspect;
        }
      } else {
        BN3.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN3.prototype.toString = function toString2(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert5(false, "Base should be between 2 and 36");
      };
      BN3.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert5(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN3.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer3) {
        BN3.prototype.toBuffer = function toBuffer2(endian, length) {
          return this.toArrayLike(Buffer3, endian, length);
        };
      }
      BN3.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN3.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert5(byteLength <= reqLength, "byte array longer than desired length");
        assert5(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN3.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN3.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN3.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN3.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN3.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN3.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN3.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN3.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN3.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN3.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN3.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN3.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN3.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN3.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN3.prototype.ior = function ior(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN3.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN3.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN3.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN3.prototype.iand = function iand(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN3.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN3.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN3.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN3.prototype.ixor = function ixor(num) {
        assert5((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN3.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN3.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN3.prototype.inotn = function inotn(width) {
        assert5(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN3.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN3.prototype.setn = function setn(bit, val) {
        assert5(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN3.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN3.prototype.add = function add2(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN3.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN3.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN3.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN3.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert5(carry === 0);
        assert5((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN3.prototype.mul = function mul(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN3.prototype.mulf = function mulf(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN3.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN3.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(typeof num === "number");
        assert5(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN3.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN3.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN3.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN3(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN3.prototype.iushln = function iushln(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN3.prototype.ishln = function ishln(bits) {
        assert5(this.negative === 0);
        return this.iushln(bits);
      };
      BN3.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert5(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask3 = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask3;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN3.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert5(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN3.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN3.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN3.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN3.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN3.prototype.testn = function testn(bit) {
        assert5(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN3.prototype.imaskn = function imaskn(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert5(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask3 = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask3;
        }
        return this._strip();
      };
      BN3.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN3.prototype.iaddn = function iaddn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN3.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN3.prototype.isubn = function isubn(num) {
        assert5(typeof num === "number");
        assert5(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN3.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN3.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN3.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN3.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN3.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert5(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN3.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN3(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN3.prototype.divmod = function divmod(num, mode, positive) {
        assert5(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN3(0),
            mod: new BN3(0)
          };
        }
        var div, mod3, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive && mod3.negative !== 0) {
              mod3.iadd(num);
            }
          }
          return {
            div,
            mod: mod3
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive && mod3.negative !== 0) {
              mod3.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod3
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN3(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN3(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN3(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN3.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN3.prototype.mod = function mod3(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN3.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN3.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod3 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod3.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN3.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN3.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN3.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert5(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN3.prototype.egcd = function egcd(p) {
        assert5(p.negative === 0);
        assert5(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN3(1);
        var B = new BN3(0);
        var C = new BN3(0);
        var D = new BN3(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN3.prototype._invmp = function _invmp(p) {
        assert5(p.negative === 0);
        assert5(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN3(1);
        var x2 = new BN3(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN3.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN3.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN3.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN3.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN3.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN3.prototype.bincn = function bincn(bit) {
        assert5(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN3.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN3.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert5(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN3.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN3.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN3.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN3.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN3.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN3.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN3.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN3.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN3.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN3.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN3.red = function red(num) {
        return new Red(num);
      };
      BN3.prototype.toRed = function toRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        assert5(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN3.prototype.fromRed = function fromRed() {
        assert5(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN3.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN3.prototype.forceRed = function forceRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN3.prototype.redAdd = function redAdd(num) {
        assert5(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN3.prototype.redIAdd = function redIAdd(num) {
        assert5(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN3.prototype.redSub = function redSub(num) {
        assert5(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN3.prototype.redISub = function redISub(num) {
        assert5(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN3.prototype.redShl = function redShl(num) {
        assert5(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN3.prototype.redMul = function redMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN3.prototype.redIMul = function redIMul(num) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN3.prototype.redSqr = function redSqr() {
        assert5(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN3.prototype.redISqr = function redISqr() {
        assert5(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN3.prototype.redSqrt = function redSqrt() {
        assert5(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN3.prototype.redInvm = function redInvm() {
        assert5(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN3.prototype.redNeg = function redNeg() {
        assert5(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN3.prototype.redPow = function redPow(num) {
        assert5(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN3(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN3(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN3(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output2) {
        var mask3 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output2.words[i] = input.words[i];
        }
        output2.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output2.words[output2.length++] = prev & mask3;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask3) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN3._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN3._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert5(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert5(a.negative === 0, "red works only with positives");
        assert5(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert5((a.negative | b.negative) === 0, "red works only with positives");
        assert5(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add2(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert5(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN3(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert5(!q.isZero());
        var one = new BN3(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN3(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert5(i < m);
          var b = this.pow(c, new BN3(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN3(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN3(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN3.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN3(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN3(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require_buffer();
    var Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/base-x/src/index.js"(exports2, module2) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode3(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str2 = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str2 += ALPHABET.charAt(b58[it2]);
        }
        return str2;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0, 0, zeroes);
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode3(string3) {
        var buffer = decodeUnsafe(string3);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode3,
        decodeUnsafe,
        decode: decode3
      };
    }
    module2.exports = base;
  }
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bs58/index.js"(exports2, module2) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module2.exports = basex(ALPHABET);
  }
});

// node_modules/@noble/hashes/esm/sha256.js
var Chi, Maj, SHA256_K, IV, SHA256_W, SHA256, SHA224, sha256, sha224;
var init_sha256 = __esm({
  "node_modules/@noble/hashes/esm/sha256.js"() {
    init_sha2();
    init_utils();
    Chi = (a, b, c) => a & b ^ ~a & c;
    Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    SHA256_W = new Uint32Array(64);
    SHA256 = class extends SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset3) {
        for (let i = 0; i < 16; i++, offset3 += 4)
          SHA256_W[i] = view.getUint32(offset3, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
          const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    sha256 = wrapConstructor(() => new SHA256());
    sha224 = wrapConstructor(() => new SHA224());
  }
});

// node_modules/text-encoding-utf-8/src/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  TextDecoder: () => TextDecoder2,
  TextEncoder: () => TextEncoder2
});
function inRange(a, min, max) {
  return min <= a && a <= max;
}
function ToDictionary(o) {
  if (o === void 0)
    return {};
  if (o === Object(o))
    return o;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(string3) {
  var s = String(string3);
  var n = s.length;
  var i = 0;
  var u = [];
  while (i < n) {
    var c = s.charCodeAt(i);
    if (c < 55296 || c > 57343) {
      u.push(c);
    } else if (56320 <= c && c <= 57343) {
      u.push(65533);
    } else if (55296 <= c && c <= 56319) {
      if (i === n - 1) {
        u.push(65533);
      } else {
        var d = string3.charCodeAt(i + 1);
        if (56320 <= d && d <= 57343) {
          var a = c & 1023;
          var b = d & 1023;
          u.push(65536 + (a << 10) + b);
          i += 1;
        } else {
          u.push(65533);
        }
      }
    }
    i += 1;
  }
  return u;
}
function codePointsToString(code_points) {
  var s = "";
  for (var i = 0; i < code_points.length; ++i) {
    var cp = code_points[i];
    if (cp <= 65535) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 65536;
      s += String.fromCharCode(
        (cp >> 10) + 55296,
        (cp & 1023) + 56320
      );
    }
  }
  return s;
}
function Stream(tokens) {
  this.tokens = [].slice.call(tokens);
}
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
function Decoder() {
}
function Encoder() {
}
function TextDecoder2(encoding, options) {
  if (!(this instanceof TextDecoder2)) {
    return new TextDecoder2(encoding, options);
  }
  encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._BOMseen = false;
  this._decoder = null;
  this._fatal = Boolean(options["fatal"]);
  this._ignoreBOM = Boolean(options["ignoreBOM"]);
  Object.defineProperty(this, "encoding", { value: "utf-8" });
  Object.defineProperty(this, "fatal", { value: this._fatal });
  Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
function TextEncoder2(encoding, options) {
  if (!(this instanceof TextEncoder2))
    return new TextEncoder2(encoding, options);
  encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._encoder = null;
  this._options = { fatal: Boolean(options["fatal"]) };
  Object.defineProperty(this, "encoding", { value: "utf-8" });
}
function UTF8Decoder(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream)
      return finished;
    if (utf8_bytes_needed === 0) {
      if (inRange(bite, 0, 127)) {
        return bite;
      }
      if (inRange(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 192;
      } else if (inRange(bite, 224, 239)) {
        if (bite === 224)
          utf8_lower_boundary = 160;
        if (bite === 237)
          utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 224;
      } else if (inRange(bite, 240, 244)) {
        if (bite === 240)
          utf8_lower_boundary = 144;
        if (bite === 244)
          utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 240;
      } else {
        return decoderError(fatal);
      }
      utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
      return null;
    }
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream.prepend(bite);
      return decoderError(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_bytes_seen += 1;
    utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (inRange(code_point, 0, 127))
      return code_point;
    var count, offset3;
    if (inRange(code_point, 128, 2047)) {
      count = 1;
      offset3 = 192;
    } else if (inRange(code_point, 2048, 65535)) {
      count = 2;
      offset3 = 224;
    } else if (inRange(code_point, 65536, 1114111)) {
      count = 3;
      offset3 = 240;
    }
    var bytes2 = [(code_point >> 6 * count) + offset3];
    while (count > 0) {
      var temp = code_point >> 6 * (count - 1);
      bytes2.push(128 | temp & 63);
      count -= 1;
    }
    return bytes2;
  };
}
var end_of_stream, finished, DEFAULT_ENCODING;
var init_encoding = __esm({
  "node_modules/text-encoding-utf-8/src/encoding.js"() {
    "use strict";
    end_of_stream = -1;
    Stream.prototype = {
      /**
       * @return {boolean} True if end-of-stream has been hit.
       */
      endOfStream: function() {
        return !this.tokens.length;
      },
      /**
       * When a token is read from a stream, the first token in the
       * stream must be returned and subsequently removed, and
       * end-of-stream must be returned otherwise.
       *
       * @return {number} Get the next token from the stream, or
       * end_of_stream.
       */
      read: function() {
        if (!this.tokens.length)
          return end_of_stream;
        return this.tokens.shift();
      },
      /**
       * When one or more tokens are prepended to a stream, those tokens
       * must be inserted, in given order, before the first token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
       */
      prepend: function(token2) {
        if (Array.isArray(token2)) {
          var tokens = (
            /**@type {!Array.<number>}*/
            token2
          );
          while (tokens.length)
            this.tokens.unshift(tokens.pop());
        } else {
          this.tokens.unshift(token2);
        }
      },
      /**
       * When one or more tokens are pushed to a stream, those tokens
       * must be inserted, in given order, after the last token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
       */
      push: function(token2) {
        if (Array.isArray(token2)) {
          var tokens = (
            /**@type {!Array.<number>}*/
            token2
          );
          while (tokens.length)
            this.tokens.push(tokens.shift());
        } else {
          this.tokens.push(token2);
        }
      }
    };
    finished = -1;
    Decoder.prototype = {
      /**
       * @param {Stream} stream The stream of bytes being decoded.
       * @param {number} bite The next byte read from the stream.
       * @return {?(number|!Array.<number>)} The next code point(s)
       *     decoded, or null if not enough data exists in the input
       *     stream to decode a complete code point, or |finished|.
       */
      handler: function(stream, bite) {
      }
    };
    Encoder.prototype = {
      /**
       * @param {Stream} stream The stream of code points being encoded.
       * @param {number} code_point Next code point read from the stream.
       * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.
       */
      handler: function(stream, code_point) {
      }
    };
    DEFAULT_ENCODING = "utf-8";
    TextDecoder2.prototype = {
      /**
       * @param {ArrayBufferView=} input The buffer of bytes to decode.
       * @param {Object=} options
       * @return {string} The decoded string.
       */
      decode: function decode(input, options) {
        var bytes2;
        if (typeof input === "object" && input instanceof ArrayBuffer) {
          bytes2 = new Uint8Array(input);
        } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
          bytes2 = new Uint8Array(
            input.buffer,
            input.byteOffset,
            input.byteLength
          );
        } else {
          bytes2 = new Uint8Array(0);
        }
        options = ToDictionary(options);
        if (!this._streaming) {
          this._decoder = new UTF8Decoder({ fatal: this._fatal });
          this._BOMseen = false;
        }
        this._streaming = Boolean(options["stream"]);
        var input_stream = new Stream(bytes2);
        var code_points = [];
        var result;
        while (!input_stream.endOfStream()) {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (result === null)
            continue;
          if (Array.isArray(result))
            code_points.push.apply(
              code_points,
              /**@type {!Array.<number>}*/
              result
            );
          else
            code_points.push(result);
        }
        if (!this._streaming) {
          do {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(
                code_points,
                /**@type {!Array.<number>}*/
                result
              );
            else
              code_points.push(result);
          } while (!input_stream.endOfStream());
          this._decoder = null;
        }
        if (code_points.length) {
          if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
            if (code_points[0] === 65279) {
              this._BOMseen = true;
              code_points.shift();
            } else {
              this._BOMseen = true;
            }
          }
        }
        return codePointsToString(code_points);
      }
    };
    TextEncoder2.prototype = {
      /**
       * @param {string=} opt_string The string to encode.
       * @param {Object=} options
       * @return {Uint8Array} Encoded bytes, as a Uint8Array.
       */
      encode: function encode(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : "";
        options = ToDictionary(options);
        if (!this._streaming)
          this._encoder = new UTF8Encoder(this._options);
        this._streaming = Boolean(options["stream"]);
        var bytes2 = [];
        var input_stream = new Stream(stringToCodePoints(opt_string));
        var result;
        while (!input_stream.endOfStream()) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (Array.isArray(result))
            bytes2.push.apply(
              bytes2,
              /**@type {!Array.<number>}*/
              result
            );
          else
            bytes2.push(result);
        }
        if (!this._streaming) {
          while (true) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes2.push.apply(
                bytes2,
                /**@type {!Array.<number>}*/
                result
              );
            else
              bytes2.push(result);
          }
          this._encoder = null;
        }
        return new Uint8Array(bytes2);
      }
    };
  }
});

// node_modules/borsh/lib/index.js
var require_lib = __commonJS({
  "node_modules/borsh/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule)
        return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserializeUnchecked = exports2.deserialize = exports2.serialize = exports2.BinaryReader = exports2.BinaryWriter = exports2.BorshError = exports2.baseDecode = exports2.baseEncode = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var bs58_1 = __importDefault(require_bs58());
    var encoding = __importStar((init_encoding(), __toCommonJS(encoding_exports)));
    var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
    var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
    function baseEncode(value) {
      if (typeof value === "string") {
        value = Buffer.from(value, "utf8");
      }
      return bs58_1.default.encode(Buffer.from(value));
    }
    exports2.baseEncode = baseEncode;
    function baseDecode(value) {
      return Buffer.from(bs58_1.default.decode(value));
    }
    exports2.baseDecode = baseDecode;
    var INITIAL_LENGTH = 1024;
    var BorshError = class extends Error {
      constructor(message) {
        super(message);
        this.fieldPath = [];
        this.originalMessage = message;
      }
      addToFieldPath(fieldName) {
        this.fieldPath.splice(0, 0, fieldName);
        this.message = this.originalMessage + ": " + this.fieldPath.join(".");
      }
    };
    exports2.BorshError = BorshError;
    var BinaryWriter = class {
      constructor() {
        this.buf = Buffer.alloc(INITIAL_LENGTH);
        this.length = 0;
      }
      maybeResize() {
        if (this.buf.length < 16 + this.length) {
          this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
        }
      }
      writeU8(value) {
        this.maybeResize();
        this.buf.writeUInt8(value, this.length);
        this.length += 1;
      }
      writeU16(value) {
        this.maybeResize();
        this.buf.writeUInt16LE(value, this.length);
        this.length += 2;
      }
      writeU32(value) {
        this.maybeResize();
        this.buf.writeUInt32LE(value, this.length);
        this.length += 4;
      }
      writeU64(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
      }
      writeU128(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
      }
      writeU256(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
      }
      writeU512(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
      }
      writeBuffer(buffer) {
        this.buf = Buffer.concat([
          Buffer.from(this.buf.subarray(0, this.length)),
          buffer,
          Buffer.alloc(INITIAL_LENGTH)
        ]);
        this.length += buffer.length;
      }
      writeString(str2) {
        this.maybeResize();
        const b = Buffer.from(str2, "utf8");
        this.writeU32(b.length);
        this.writeBuffer(b);
      }
      writeFixedArray(array4) {
        this.writeBuffer(Buffer.from(array4));
      }
      writeArray(array4, fn) {
        this.maybeResize();
        this.writeU32(array4.length);
        for (const elem of array4) {
          this.maybeResize();
          fn(elem);
        }
      }
      toArray() {
        return this.buf.subarray(0, this.length);
      }
    };
    exports2.BinaryWriter = BinaryWriter;
    function handlingRangeError(target, propertyKey, propertyDescriptor) {
      const originalMethod = propertyDescriptor.value;
      propertyDescriptor.value = function(...args) {
        try {
          return originalMethod.apply(this, args);
        } catch (e) {
          if (e instanceof RangeError) {
            const code = e.code;
            if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
              throw new BorshError("Reached the end of buffer when deserializing");
            }
          }
          throw e;
        }
      };
    }
    var BinaryReader = class {
      constructor(buf) {
        this.buf = buf;
        this.offset = 0;
      }
      readU8() {
        const value = this.buf.readUInt8(this.offset);
        this.offset += 1;
        return value;
      }
      readU16() {
        const value = this.buf.readUInt16LE(this.offset);
        this.offset += 2;
        return value;
      }
      readU32() {
        const value = this.buf.readUInt32LE(this.offset);
        this.offset += 4;
        return value;
      }
      readU64() {
        const buf = this.readBuffer(8);
        return new bn_js_1.default(buf, "le");
      }
      readU128() {
        const buf = this.readBuffer(16);
        return new bn_js_1.default(buf, "le");
      }
      readU256() {
        const buf = this.readBuffer(32);
        return new bn_js_1.default(buf, "le");
      }
      readU512() {
        const buf = this.readBuffer(64);
        return new bn_js_1.default(buf, "le");
      }
      readBuffer(len) {
        if (this.offset + len > this.buf.length) {
          throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
        }
        const result = this.buf.slice(this.offset, this.offset + len);
        this.offset += len;
        return result;
      }
      readString() {
        const len = this.readU32();
        const buf = this.readBuffer(len);
        try {
          return textDecoder.decode(buf);
        } catch (e) {
          throw new BorshError(`Error decoding UTF-8 string: ${e}`);
        }
      }
      readFixedArray(len) {
        return new Uint8Array(this.readBuffer(len));
      }
      readArray(fn) {
        const len = this.readU32();
        const result = Array();
        for (let i = 0; i < len; ++i) {
          result.push(fn());
        }
        return result;
      }
    };
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU8", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU16", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU32", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU64", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU128", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU256", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU512", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readString", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readFixedArray", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readArray", null);
    exports2.BinaryReader = BinaryReader;
    function capitalizeFirstLetter(string3) {
      return string3.charAt(0).toUpperCase() + string3.slice(1);
    }
    function serializeField(schema, fieldName, value, fieldType, writer) {
      try {
        if (typeof fieldType === "string") {
          writer[`write${capitalizeFirstLetter(fieldType)}`](value);
        } else if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            if (value.length !== fieldType[0]) {
              throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
            }
            writer.writeFixedArray(value);
          } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
            if (value.length !== fieldType[1]) {
              throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
            }
            for (let i = 0; i < fieldType[1]; i++) {
              serializeField(schema, null, value[i], fieldType[0], writer);
            }
          } else {
            writer.writeArray(value, (item) => {
              serializeField(schema, fieldName, item, fieldType[0], writer);
            });
          }
        } else if (fieldType.kind !== void 0) {
          switch (fieldType.kind) {
            case "option": {
              if (value === null || value === void 0) {
                writer.writeU8(0);
              } else {
                writer.writeU8(1);
                serializeField(schema, fieldName, value, fieldType.type, writer);
              }
              break;
            }
            case "map": {
              writer.writeU32(value.size);
              value.forEach((val, key) => {
                serializeField(schema, fieldName, key, fieldType.key, writer);
                serializeField(schema, fieldName, val, fieldType.value, writer);
              });
              break;
            }
            default:
              throw new BorshError(`FieldType ${fieldType} unrecognized`);
          }
        } else {
          serializeStruct(schema, value, writer);
        }
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function serializeStruct(schema, obj, writer) {
      if (typeof obj.borshSerialize === "function") {
        obj.borshSerialize(writer);
        return;
      }
      const structSchema = schema.get(obj.constructor);
      if (!structSchema) {
        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
      }
      if (structSchema.kind === "struct") {
        structSchema.fields.map(([fieldName, fieldType]) => {
          serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
        });
      } else if (structSchema.kind === "enum") {
        const name = obj[structSchema.field];
        for (let idx = 0; idx < structSchema.values.length; ++idx) {
          const [fieldName, fieldType] = structSchema.values[idx];
          if (fieldName === name) {
            writer.writeU8(idx);
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
            break;
          }
        }
      } else {
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
      }
    }
    function serialize2(schema, obj, Writer = BinaryWriter) {
      const writer = new Writer();
      serializeStruct(schema, obj, writer);
      return writer.toArray();
    }
    exports2.serialize = serialize2;
    function deserializeField(schema, fieldName, fieldType, reader) {
      try {
        if (typeof fieldType === "string") {
          return reader[`read${capitalizeFirstLetter(fieldType)}`]();
        }
        if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            return reader.readFixedArray(fieldType[0]);
          } else if (typeof fieldType[1] === "number") {
            const arr = [];
            for (let i = 0; i < fieldType[1]; i++) {
              arr.push(deserializeField(schema, null, fieldType[0], reader));
            }
            return arr;
          } else {
            return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
          }
        }
        if (fieldType.kind === "option") {
          const option2 = reader.readU8();
          if (option2) {
            return deserializeField(schema, fieldName, fieldType.type, reader);
          }
          return void 0;
        }
        if (fieldType.kind === "map") {
          let map = /* @__PURE__ */ new Map();
          const length = reader.readU32();
          for (let i = 0; i < length; i++) {
            const key = deserializeField(schema, fieldName, fieldType.key, reader);
            const val = deserializeField(schema, fieldName, fieldType.value, reader);
            map.set(key, val);
          }
          return map;
        }
        return deserializeStruct(schema, fieldType, reader);
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function deserializeStruct(schema, classType, reader) {
      if (typeof classType.borshDeserialize === "function") {
        return classType.borshDeserialize(reader);
      }
      const structSchema = schema.get(classType);
      if (!structSchema) {
        throw new BorshError(`Class ${classType.name} is missing in schema`);
      }
      if (structSchema.kind === "struct") {
        const result = {};
        for (const [fieldName, fieldType] of schema.get(classType).fields) {
          result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
        }
        return new classType(result);
      }
      if (structSchema.kind === "enum") {
        const idx = reader.readU8();
        if (idx >= structSchema.values.length) {
          throw new BorshError(`Enum index: ${idx} is out of range`);
        }
        const [fieldName, fieldType] = structSchema.values[idx];
        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
        return new classType({ [fieldName]: fieldValue });
      }
      throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
    }
    function deserialize2(schema, classType, buffer, Reader = BinaryReader) {
      const reader = new Reader(buffer);
      const result = deserializeStruct(schema, classType, reader);
      if (reader.offset < buffer.length) {
        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
      }
      return result;
    }
    exports2.deserialize = deserialize2;
    function deserializeUnchecked2(schema, classType, buffer, Reader = BinaryReader) {
      const reader = new Reader(buffer);
      return deserializeStruct(schema, classType, reader);
    }
    exports2.deserializeUnchecked = deserializeUnchecked2;
  }
});

// node_modules/@solana/buffer-layout/lib/Layout.js
var require_Layout = __commonJS({
  "node_modules/@solana/buffer-layout/lib/Layout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.s16 = exports2.s8 = exports2.nu64be = exports2.u48be = exports2.u40be = exports2.u32be = exports2.u24be = exports2.u16be = exports2.nu64 = exports2.u48 = exports2.u40 = exports2.u32 = exports2.u24 = exports2.u16 = exports2.u8 = exports2.offset = exports2.greedy = exports2.Constant = exports2.UTF8 = exports2.CString = exports2.Blob = exports2.Boolean = exports2.BitField = exports2.BitStructure = exports2.VariantLayout = exports2.Union = exports2.UnionLayoutDiscriminator = exports2.UnionDiscriminator = exports2.Structure = exports2.Sequence = exports2.DoubleBE = exports2.Double = exports2.FloatBE = exports2.Float = exports2.NearInt64BE = exports2.NearInt64 = exports2.NearUInt64BE = exports2.NearUInt64 = exports2.IntBE = exports2.Int = exports2.UIntBE = exports2.UInt = exports2.OffsetLayout = exports2.GreedyCount = exports2.ExternalLayout = exports2.bindConstructorLayout = exports2.nameWithProperty = exports2.Layout = exports2.uint8ArrayToBuffer = exports2.checkUint8Array = void 0;
    exports2.constant = exports2.utf8 = exports2.cstr = exports2.blob = exports2.unionLayoutDiscriminator = exports2.union = exports2.seq = exports2.bits = exports2.struct = exports2.f64be = exports2.f64 = exports2.f32be = exports2.f32 = exports2.ns64be = exports2.s48be = exports2.s40be = exports2.s32be = exports2.s24be = exports2.s16be = exports2.ns64 = exports2.s48 = exports2.s40 = exports2.s32 = exports2.s24 = void 0;
    var buffer_1 = require_buffer();
    function checkUint8Array(b) {
      if (!(b instanceof Uint8Array)) {
        throw new TypeError("b must be a Uint8Array");
      }
    }
    exports2.checkUint8Array = checkUint8Array;
    function uint8ArrayToBuffer(b) {
      checkUint8Array(b);
      return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
    }
    exports2.uint8ArrayToBuffer = uint8ArrayToBuffer;
    var Layout2 = class {
      constructor(span, property) {
        if (!Number.isInteger(span)) {
          throw new TypeError("span must be an integer");
        }
        this.span = span;
        this.property = property;
      }
      /** Function to create an Object into which decoded properties will
       * be written.
       *
       * Used only for layouts that {@link Layout#decode|decode} to Object
       * instances, which means:
       * * {@link Structure}
       * * {@link Union}
       * * {@link VariantLayout}
       * * {@link BitStructure}
       *
       * If left undefined the JavaScript representation of these layouts
       * will be Object instances.
       *
       * See {@link bindConstructorLayout}.
       */
      makeDestinationObject() {
        return {};
      }
      /**
       * Calculate the span of a specific instance of a layout.
       *
       * @param {Uint8Array} b - the buffer that contains an encoded instance.
       *
       * @param {Number} [offset] - the offset at which the encoded instance
       * starts.  If absent a zero offset is inferred.
       *
       * @return {Number} - the number of bytes covered by the layout
       * instance.  If this method is not overridden in a subclass the
       * definition-time constant {@link Layout#span|span} will be
       * returned.
       *
       * @throws {RangeError} - if the length of the value cannot be
       * determined.
       */
      getSpan(b, offset3) {
        if (0 > this.span) {
          throw new RangeError("indeterminate span");
        }
        return this.span;
      }
      /**
       * Replicate the layout using a new property.
       *
       * This function must be used to get a structurally-equivalent layout
       * with a different name since all {@link Layout} instances are
       * immutable.
       *
       * **NOTE** This is a shallow copy.  All fields except {@link
       * Layout#property|property} are strictly equal to the origin layout.
       *
       * @param {String} property - the value for {@link
       * Layout#property|property} in the replica.
       *
       * @returns {Layout} - the copy with {@link Layout#property|property}
       * set to `property`.
       */
      replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      /**
       * Create an object from layout properties and an array of values.
       *
       * **NOTE** This function returns `undefined` if invoked on a layout
       * that does not return its value as an Object.  Objects are
       * returned for things that are a {@link Structure}, which includes
       * {@link VariantLayout|variant layouts} if they are structures, and
       * excludes {@link Union}s.  If you want this feature for a union
       * you must use {@link Union.getVariant|getVariant} to select the
       * desired layout.
       *
       * @param {Array} values - an array of values that correspond to the
       * default order for properties.  As with {@link Layout#decode|decode}
       * layout elements that have no property name are skipped when
       * iterating over the array values.  Only the top-level properties are
       * assigned; arguments are not assigned to properties of contained
       * layouts.  Any unused values are ignored.
       *
       * @return {(Object|undefined)}
       */
      fromArray(values) {
        return void 0;
      }
    };
    exports2.Layout = Layout2;
    function nameWithProperty2(name, lo) {
      if (lo.property) {
        return name + "[" + lo.property + "]";
      }
      return name;
    }
    exports2.nameWithProperty = nameWithProperty2;
    function bindConstructorLayout(Class, layout) {
      if ("function" !== typeof Class) {
        throw new TypeError("Class must be constructor");
      }
      if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
        throw new Error("Class is already bound to a layout");
      }
      if (!(layout && layout instanceof Layout2)) {
        throw new TypeError("layout must be a Layout");
      }
      if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
        throw new Error("layout is already bound to a constructor");
      }
      Class.layout_ = layout;
      layout.boundConstructor_ = Class;
      layout.makeDestinationObject = () => new Class();
      Object.defineProperty(Class.prototype, "encode", {
        value(b, offset3) {
          return layout.encode(this, b, offset3);
        },
        writable: true
      });
      Object.defineProperty(Class, "decode", {
        value(b, offset3) {
          return layout.decode(b, offset3);
        },
        writable: true
      });
    }
    exports2.bindConstructorLayout = bindConstructorLayout;
    var ExternalLayout2 = class extends Layout2 {
      /**
       * Return `true` iff the external layout decodes to an unsigned
       * integer layout.
       *
       * In that case it can be used as the source of {@link
       * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
       * or as {@link UnionLayoutDiscriminator#layout|external union
       * discriminators}.
       *
       * @abstract
       */
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    };
    exports2.ExternalLayout = ExternalLayout2;
    var GreedyCount = class extends ExternalLayout2 {
      constructor(elementSpan = 1, property) {
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
          throw new TypeError("elementSpan must be a (positive) integer");
        }
        super(-1, property);
        this.elementSpan = elementSpan;
      }
      /** @override */
      isCount() {
        return true;
      }
      /** @override */
      decode(b, offset3 = 0) {
        checkUint8Array(b);
        const rem = b.length - offset3;
        return Math.floor(rem / this.elementSpan);
      }
      /** @override */
      encode(src, b, offset3) {
        return 0;
      }
    };
    exports2.GreedyCount = GreedyCount;
    var OffsetLayout2 = class extends ExternalLayout2 {
      constructor(layout, offset3 = 0, property) {
        if (!(layout instanceof Layout2)) {
          throw new TypeError("layout must be a Layout");
        }
        if (!Number.isInteger(offset3)) {
          throw new TypeError("offset must be integer or undefined");
        }
        super(layout.span, property || layout.property);
        this.layout = layout;
        this.offset = offset3;
      }
      /** @override */
      isCount() {
        return this.layout instanceof UInt2 || this.layout instanceof UIntBE2;
      }
      /** @override */
      decode(b, offset3 = 0) {
        return this.layout.decode(b, offset3 + this.offset);
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        return this.layout.encode(src, b, offset3 + this.offset);
      }
    };
    exports2.OffsetLayout = OffsetLayout2;
    var UInt2 = class extends Layout2 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer(b).readUIntLE(offset3, this.span);
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        uint8ArrayToBuffer(b).writeUIntLE(src, offset3, this.span);
        return this.span;
      }
    };
    exports2.UInt = UInt2;
    var UIntBE2 = class extends Layout2 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer(b).readUIntBE(offset3, this.span);
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        uint8ArrayToBuffer(b).writeUIntBE(src, offset3, this.span);
        return this.span;
      }
    };
    exports2.UIntBE = UIntBE2;
    var Int = class extends Layout2 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer(b).readIntLE(offset3, this.span);
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        uint8ArrayToBuffer(b).writeIntLE(src, offset3, this.span);
        return this.span;
      }
    };
    exports2.Int = Int;
    var IntBE = class extends Layout2 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer(b).readIntBE(offset3, this.span);
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        uint8ArrayToBuffer(b).writeIntBE(src, offset3, this.span);
        return this.span;
      }
    };
    exports2.IntBE = IntBE;
    var V2E322 = Math.pow(2, 32);
    function divmodInt642(src) {
      const hi32 = Math.floor(src / V2E322);
      const lo32 = src - hi32 * V2E322;
      return { hi32, lo32 };
    }
    function roundedInt642(hi32, lo32) {
      return hi32 * V2E322 + lo32;
    }
    var NearUInt642 = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const lo32 = buffer.readUInt32LE(offset3);
        const hi32 = buffer.readUInt32LE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        const split2 = divmodInt642(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split2.lo32, offset3);
        buffer.writeUInt32LE(split2.hi32, offset3 + 4);
        return 8;
      }
    };
    exports2.NearUInt64 = NearUInt642;
    var NearUInt64BE = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const hi32 = buffer.readUInt32BE(offset3);
        const lo32 = buffer.readUInt32BE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        const split2 = divmodInt642(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32BE(split2.hi32, offset3);
        buffer.writeUInt32BE(split2.lo32, offset3 + 4);
        return 8;
      }
    };
    exports2.NearUInt64BE = NearUInt64BE;
    var NearInt642 = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const lo32 = buffer.readUInt32LE(offset3);
        const hi32 = buffer.readInt32LE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        const split2 = divmodInt642(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split2.lo32, offset3);
        buffer.writeInt32LE(split2.hi32, offset3 + 4);
        return 8;
      }
    };
    exports2.NearInt64 = NearInt642;
    var NearInt64BE = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const hi32 = buffer.readInt32BE(offset3);
        const lo32 = buffer.readUInt32BE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        const split2 = divmodInt642(src);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeInt32BE(split2.hi32, offset3);
        buffer.writeUInt32BE(split2.lo32, offset3 + 4);
        return 8;
      }
    };
    exports2.NearInt64BE = NearInt64BE;
    var Float = class extends Layout2 {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer(b).readFloatLE(offset3);
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        uint8ArrayToBuffer(b).writeFloatLE(src, offset3);
        return 4;
      }
    };
    exports2.Float = Float;
    var FloatBE = class extends Layout2 {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer(b).readFloatBE(offset3);
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        uint8ArrayToBuffer(b).writeFloatBE(src, offset3);
        return 4;
      }
    };
    exports2.FloatBE = FloatBE;
    var Double = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer(b).readDoubleLE(offset3);
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        uint8ArrayToBuffer(b).writeDoubleLE(src, offset3);
        return 8;
      }
    };
    exports2.Double = Double;
    var DoubleBE = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3 = 0) {
        return uint8ArrayToBuffer(b).readDoubleBE(offset3);
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        uint8ArrayToBuffer(b).writeDoubleBE(src, offset3);
        return 8;
      }
    };
    exports2.DoubleBE = DoubleBE;
    var Sequence = class extends Layout2 {
      constructor(elementLayout, count, property) {
        if (!(elementLayout instanceof Layout2)) {
          throw new TypeError("elementLayout must be a Layout");
        }
        if (!(count instanceof ExternalLayout2 && count.isCount() || Number.isInteger(count) && 0 <= count)) {
          throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(count instanceof ExternalLayout2) && 0 < elementLayout.span) {
          span = count * elementLayout.span;
        }
        super(span, property);
        this.elementLayout = elementLayout;
        this.count = count;
      }
      /** @override */
      getSpan(b, offset3 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout2) {
          count = count.decode(b, offset3);
        }
        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          let idx = 0;
          while (idx < count) {
            span += this.elementLayout.getSpan(b, offset3 + span);
            ++idx;
          }
        }
        return span;
      }
      /** @override */
      decode(b, offset3 = 0) {
        const rv = [];
        let i = 0;
        let count = this.count;
        if (count instanceof ExternalLayout2) {
          count = count.decode(b, offset3);
        }
        while (i < count) {
          rv.push(this.elementLayout.decode(b, offset3));
          offset3 += this.elementLayout.getSpan(b, offset3);
          i += 1;
        }
        return rv;
      }
      /** Implement {@link Layout#encode|encode} for {@link Sequence}.
       *
       * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
       * the unused space in the buffer is left unchanged.  If `src` is
       * longer than {@link Sequence#count|count} the unneeded elements are
       * ignored.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src, b, offset3 = 0) {
        const elo = this.elementLayout;
        const span = src.reduce((span2, v) => {
          return span2 + elo.encode(v, b, offset3 + span2);
        }, 0);
        if (this.count instanceof ExternalLayout2) {
          this.count.encode(src.length, b, offset3);
        }
        return span;
      }
    };
    exports2.Sequence = Sequence;
    var Structure2 = class extends Layout2 {
      constructor(fields, property, decodePrefixes) {
        if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout2, true))) {
          throw new TypeError("fields must be array of Layout instances");
        }
        if ("boolean" === typeof property && void 0 === decodePrefixes) {
          decodePrefixes = property;
          property = void 0;
        }
        for (const fd of fields) {
          if (0 > fd.span && void 0 === fd.property) {
            throw new Error("fields cannot contain unnamed variable-length layout");
          }
        }
        let span = -1;
        try {
          span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
        } catch (e) {
        }
        super(span, property);
        this.fields = fields;
        this.decodePrefixes = !!decodePrefixes;
      }
      /** @override */
      getSpan(b, offset3 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let span = 0;
        try {
          span = this.fields.reduce((span2, fd) => {
            const fsp = fd.getSpan(b, offset3);
            offset3 += fsp;
            return span2 + fsp;
          }, 0);
        } catch (e) {
          throw new RangeError("indeterminate span");
        }
        return span;
      }
      /** @override */
      decode(b, offset3 = 0) {
        checkUint8Array(b);
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b, offset3);
          }
          offset3 += fd.getSpan(b, offset3);
          if (this.decodePrefixes && b.length === offset3) {
            break;
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Structure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the buffer is
       * left unmodified. */
      encode(src, b, offset3 = 0) {
        const firstOffset = offset3;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd of this.fields) {
          let span = fd.span;
          lastWrote = 0 < span ? span : 0;
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              lastWrote = fd.encode(fv, b, offset3);
              if (0 > span) {
                span = fd.getSpan(b, offset3);
              }
            }
          }
          lastOffset = offset3;
          offset3 += span;
        }
        return lastOffset + lastWrote - firstOffset;
      }
      /** @override */
      fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property && 0 < values.length) {
            dest[fd.property] = values.shift();
          }
        }
        return dest;
      }
      /**
       * Get access to the layout of a given property.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Layout} - the layout associated with `property`, or
       * undefined if there is no such property.
       */
      layoutFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
        return void 0;
      }
      /**
       * Get the offset of a structure member.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Number} - the offset in bytes to the start of `property`
       * within the structure, or undefined if `property` is not a field
       * within the structure.  If the property is a member but follows a
       * variable-length structure member a negative number will be
       * returned.
       */
      offsetOf(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        let offset3 = 0;
        for (const fd of this.fields) {
          if (fd.property === property) {
            return offset3;
          }
          if (0 > fd.span) {
            offset3 = -1;
          } else if (0 <= offset3) {
            offset3 += fd.span;
          }
        }
        return void 0;
      }
    };
    exports2.Structure = Structure2;
    var UnionDiscriminator2 = class {
      constructor(property) {
        this.property = property;
      }
      /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
       *
       * The implementation of this method need not reference the buffer if
       * variant information is available through other means. */
      decode(b, offset3) {
        throw new Error("UnionDiscriminator is abstract");
      }
      /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
       *
       * The implementation of this method need not store the value if
       * variant information is maintained through other means. */
      encode(src, b, offset3) {
        throw new Error("UnionDiscriminator is abstract");
      }
    };
    exports2.UnionDiscriminator = UnionDiscriminator2;
    var UnionLayoutDiscriminator2 = class extends UnionDiscriminator2 {
      constructor(layout, property) {
        if (!(layout instanceof ExternalLayout2 && layout.isCount())) {
          throw new TypeError("layout must be an unsigned integer ExternalLayout");
        }
        super(property || layout.property || "variant");
        this.layout = layout;
      }
      /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      decode(b, offset3) {
        return this.layout.decode(b, offset3);
      }
      /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      encode(src, b, offset3) {
        return this.layout.encode(src, b, offset3);
      }
    };
    exports2.UnionLayoutDiscriminator = UnionLayoutDiscriminator2;
    var Union2 = class extends Layout2 {
      constructor(discr, defaultLayout, property) {
        let discriminator;
        if (discr instanceof UInt2 || discr instanceof UIntBE2) {
          discriminator = new UnionLayoutDiscriminator2(new OffsetLayout2(discr));
        } else if (discr instanceof ExternalLayout2 && discr.isCount()) {
          discriminator = new UnionLayoutDiscriminator2(discr);
        } else if (!(discr instanceof UnionDiscriminator2)) {
          throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        } else {
          discriminator = discr;
        }
        if (void 0 === defaultLayout) {
          defaultLayout = null;
        }
        if (!(null === defaultLayout || defaultLayout instanceof Layout2)) {
          throw new TypeError("defaultLayout must be null or a Layout");
        }
        if (null !== defaultLayout) {
          if (0 > defaultLayout.span) {
            throw new Error("defaultLayout must have constant span");
          }
          if (void 0 === defaultLayout.property) {
            defaultLayout = defaultLayout.replicate("content");
          }
        }
        let span = -1;
        if (defaultLayout) {
          span = defaultLayout.span;
          if (0 <= span && (discr instanceof UInt2 || discr instanceof UIntBE2)) {
            span += discriminator.layout.span;
          }
        }
        super(span, property);
        this.discriminator = discriminator;
        this.usesPrefixDiscriminator = discr instanceof UInt2 || discr instanceof UIntBE2;
        this.defaultLayout = defaultLayout;
        this.registry = {};
        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(src) {
          return boundGetSourceVariant(src);
        };
        this.configGetSourceVariant = function(gsv) {
          boundGetSourceVariant = gsv.bind(this);
        };
      }
      /** @override */
      getSpan(b, offset3 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        const vlo = this.getVariant(b, offset3);
        if (!vlo) {
          throw new Error("unable to determine span for unrecognized variant");
        }
        return vlo.getSpan(b, offset3);
      }
      /**
       * Method to infer a registered Union variant compatible with `src`.
       *
       * The first satisfied rule in the following sequence defines the
       * return value:
       * * If `src` has properties matching the Union discriminator and
       *   the default layout, `undefined` is returned regardless of the
       *   value of the discriminator property (this ensures the default
       *   layout will be used);
       * * If `src` has a property matching the Union discriminator, the
       *   value of the discriminator identifies a registered variant, and
       *   either (a) the variant has no layout, or (b) `src` has the
       *   variant's property, then the variant is returned (because the
       *   source satisfies the constraints of the variant it identifies);
       * * If `src` does not have a property matching the Union
       *   discriminator, but does have a property matching a registered
       *   variant, then the variant is returned (because the source
       *   matches a variant without an explicit conflict);
       * * An error is thrown (because we either can't identify a variant,
       *   or we were explicitly told the variant but can't satisfy it).
       *
       * @param {Object} src - an object presumed to be compatible with
       * the content of the Union.
       *
       * @return {(undefined|VariantLayout)} - as described above.
       *
       * @throws {Error} - if `src` cannot be associated with a default or
       * registered variant.
       */
      defaultGetSourceVariant(src) {
        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
          if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
            return void 0;
          }
          const vlo = this.registry[src[this.discriminator.property]];
          if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
            return vlo;
          }
        } else {
          for (const tag in this.registry) {
            const vlo = this.registry[tag];
            if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
              return vlo;
            }
          }
        }
        throw new Error("unable to infer src variant");
      }
      /** Implement {@link Layout#decode|decode} for {@link Union}.
       *
       * If the variant is {@link Union#addVariant|registered} the return
       * value is an instance of that variant, with no explicit
       * discriminator.  Otherwise the {@link Union#defaultLayout|default
       * layout} is used to decode the content. */
      decode(b, offset3 = 0) {
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b, offset3);
        const clo = this.registry[discr];
        if (void 0 === clo) {
          const defaultLayout = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[defaultLayout.property] = defaultLayout.decode(b, offset3 + contentOffset);
        } else {
          dest = clo.decode(b, offset3);
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Union}.
       *
       * This API assumes the `src` object is consistent with the union's
       * {@link Union#defaultLayout|default layout}.  To encode variants
       * use the appropriate variant-specific {@link VariantLayout#encode}
       * method. */
      encode(src, b, offset3 = 0) {
        const vlo = this.getSourceVariant(src);
        if (void 0 === vlo) {
          const dlo = this.discriminator;
          const clo = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dlo.encode(src[dlo.property], b, offset3);
          return contentOffset + clo.encode(src[clo.property], b, offset3 + contentOffset);
        }
        return vlo.encode(src, b, offset3);
      }
      /** Register a new variant structure within a union.  The newly
       * created variant is returned.
       *
       * @param {Number} variant - initializer for {@link
       * VariantLayout#variant|variant}.
       *
       * @param {Layout} layout - initializer for {@link
       * VariantLayout#layout|layout}.
       *
       * @param {String} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {VariantLayout} */
      addVariant(variant, layout, property) {
        const rv = new VariantLayout2(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      /**
       * Get the layout associated with a registered variant.
       *
       * If `vb` does not produce a registered variant the function returns
       * `undefined`.
       *
       * @param {(Number|Uint8Array)} vb - either the variant number, or a
       * buffer from which the discriminator is to be read.
       *
       * @param {Number} offset - offset into `vb` for the start of the
       * union.  Used only when `vb` is an instance of {Uint8Array}.
       *
       * @return {({VariantLayout}|undefined)}
       */
      getVariant(vb, offset3 = 0) {
        let variant;
        if (vb instanceof Uint8Array) {
          variant = this.discriminator.decode(vb, offset3);
        } else {
          variant = vb;
        }
        return this.registry[variant];
      }
    };
    exports2.Union = Union2;
    var VariantLayout2 = class extends Layout2 {
      constructor(union3, variant, layout, property) {
        if (!(union3 instanceof Union2)) {
          throw new TypeError("union must be a Union");
        }
        if (!Number.isInteger(variant) || 0 > variant) {
          throw new TypeError("variant must be a (non-negative) integer");
        }
        if ("string" === typeof layout && void 0 === property) {
          property = layout;
          layout = null;
        }
        if (layout) {
          if (!(layout instanceof Layout2)) {
            throw new TypeError("layout must be a Layout");
          }
          if (null !== union3.defaultLayout && 0 <= layout.span && layout.span > union3.defaultLayout.span) {
            throw new Error("variant span exceeds span of containing union");
          }
          if ("string" !== typeof property) {
            throw new TypeError("variant must have a String property");
          }
        }
        let span = union3.span;
        if (0 > union3.span) {
          span = layout ? layout.span : 0;
          if (0 <= span && union3.usesPrefixDiscriminator) {
            span += union3.discriminator.layout.span;
          }
        }
        super(span, property);
        this.union = union3;
        this.variant = variant;
        this.layout = layout || null;
      }
      /** @override */
      getSpan(b, offset3 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        let span = 0;
        if (this.layout) {
          span = this.layout.getSpan(b, offset3 + contentOffset);
        }
        return contentOffset + span;
      }
      /** @override */
      decode(b, offset3 = 0) {
        const dest = this.makeDestinationObject();
        if (this !== this.union.getVariant(b, offset3)) {
          throw new Error("variant mismatch");
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout) {
          dest[this.property] = this.layout.decode(b, offset3 + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {
          throw new TypeError("variant lacks property " + this.property);
        }
        this.union.discriminator.encode(this.variant, b, offset3);
        let span = contentOffset;
        if (this.layout) {
          this.layout.encode(src[this.property], b, offset3 + contentOffset);
          span += this.layout.getSpan(b, offset3 + contentOffset);
          if (0 <= this.union.span && span > this.union.span) {
            throw new Error("encoded variant overruns containing union");
          }
        }
        return span;
      }
      /** Delegate {@link Layout#fromArray|fromArray} to {@link
       * VariantLayout#layout|layout}. */
      fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
        return void 0;
      }
    };
    exports2.VariantLayout = VariantLayout2;
    function fixBitwiseResult(v) {
      if (0 > v) {
        v += 4294967296;
      }
      return v;
    }
    var BitStructure = class extends Layout2 {
      constructor(word, msb, property) {
        if (!(word instanceof UInt2 || word instanceof UIntBE2)) {
          throw new TypeError("word must be a UInt or UIntBE layout");
        }
        if ("string" === typeof msb && void 0 === property) {
          property = msb;
          msb = false;
        }
        if (4 < word.span) {
          throw new RangeError("word cannot exceed 32 bits");
        }
        super(word.span, property);
        this.word = word;
        this.msb = !!msb;
        this.fields = [];
        let value = 0;
        this._packedSetValue = function(v) {
          value = fixBitwiseResult(v);
          return this;
        };
        this._packedGetValue = function() {
          return value;
        };
      }
      /** @override */
      decode(b, offset3 = 0) {
        const dest = this.makeDestinationObject();
        const value = this.word.decode(b, offset3);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b);
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the packed
       * value is left unmodified.  Unused bits are also left unmodified. */
      encode(src, b, offset3 = 0) {
        const value = this.word.decode(b, offset3);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              fd.encode(fv);
            }
          }
        }
        return this.word.encode(this._packedGetValue(), b, offset3);
      }
      /** Register a new bitfield with a containing bit structure.  The
       * resulting bitfield is returned.
       *
       * @param {Number} bits - initializer for {@link BitField#bits|bits}.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {BitField} */
      addField(bits, property) {
        const bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
      }
      /** As with {@link BitStructure#addField|addField} for single-bit
       * fields with `boolean` value representation.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {Boolean} */
      // `Boolean` conflicts with the native primitive type
      // eslint-disable-next-line @typescript-eslint/ban-types
      addBoolean(property) {
        const bf = new Boolean2(this, property);
        this.fields.push(bf);
        return bf;
      }
      /**
       * Get access to the bit field for a given property.
       *
       * @param {String} property - the bit field of interest.
       *
       * @return {BitField} - the field associated with `property`, or
       * undefined if there is no such property.
       */
      fieldFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
        return void 0;
      }
    };
    exports2.BitStructure = BitStructure;
    var BitField = class {
      constructor(container, bits, property) {
        if (!(container instanceof BitStructure)) {
          throw new TypeError("container must be a BitStructure");
        }
        if (!Number.isInteger(bits) || 0 >= bits) {
          throw new TypeError("bits must be positive integer");
        }
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
        if (bits + usedBits > totalBits) {
          throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        }
        this.container = container;
        this.bits = bits;
        this.valueMask = (1 << bits) - 1;
        if (32 === bits) {
          this.valueMask = 4294967295;
        }
        this.start = usedBits;
        if (this.container.msb) {
          this.start = totalBits - usedBits - bits;
        }
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        this.property = property;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field. */
      decode(b, offset3) {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value = wordValue >>> this.start;
        return value;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field.
       *
       * **NOTE** This is not a specialization of {@link
       * Layout#encode|Layout.encode} and there is no return value. */
      encode(value) {
        if ("number" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
          throw new TypeError(nameWithProperty2("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        }
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      }
    };
    exports2.BitField = BitField;
    var Boolean2 = class extends BitField {
      constructor(container, property) {
        super(container, 1, property);
      }
      /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
       *
       * @returns {boolean} */
      decode(b, offset3) {
        return !!super.decode(b, offset3);
      }
      /** @override */
      encode(value) {
        if ("boolean" === typeof value) {
          value = +value;
        }
        super.encode(value);
      }
    };
    exports2.Boolean = Boolean2;
    var Blob2 = class extends Layout2 {
      constructor(length, property) {
        if (!(length instanceof ExternalLayout2 && length.isCount() || Number.isInteger(length) && 0 <= length)) {
          throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(length instanceof ExternalLayout2)) {
          span = length;
        }
        super(span, property);
        this.length = length;
      }
      /** @override */
      getSpan(b, offset3) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset3);
        }
        return span;
      }
      /** @override */
      decode(b, offset3 = 0) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset3);
        }
        return uint8ArrayToBuffer(b).slice(offset3, offset3 + span);
      }
      /** Implement {@link Layout#encode|encode} for {@link Blob}.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src, b, offset3) {
        let span = this.length;
        if (this.length instanceof ExternalLayout2) {
          span = src.length;
        }
        if (!(src instanceof Uint8Array && span === src.length)) {
          throw new TypeError(nameWithProperty2("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
        }
        if (offset3 + span > b.length) {
          throw new RangeError("encoding overruns Uint8Array");
        }
        const srcBuffer = uint8ArrayToBuffer(src);
        uint8ArrayToBuffer(b).write(srcBuffer.toString("hex"), offset3, span, "hex");
        if (this.length instanceof ExternalLayout2) {
          this.length.encode(span, b, offset3);
        }
        return span;
      }
    };
    exports2.Blob = Blob2;
    var CString = class extends Layout2 {
      constructor(property) {
        super(-1, property);
      }
      /** @override */
      getSpan(b, offset3 = 0) {
        checkUint8Array(b);
        let idx = offset3;
        while (idx < b.length && 0 !== b[idx]) {
          idx += 1;
        }
        return 1 + idx - offset3;
      }
      /** @override */
      decode(b, offset3 = 0) {
        const span = this.getSpan(b, offset3);
        return uint8ArrayToBuffer(b).slice(offset3, offset3 + span - 1).toString("utf-8");
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        if ("string" !== typeof src) {
          src = String(src);
        }
        const srcb = buffer_1.Buffer.from(src, "utf8");
        const span = srcb.length;
        if (offset3 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        const buffer = uint8ArrayToBuffer(b);
        srcb.copy(buffer, offset3);
        buffer[offset3 + span] = 0;
        return span + 1;
      }
    };
    exports2.CString = CString;
    var UTF8 = class extends Layout2 {
      constructor(maxSpan, property) {
        if ("string" === typeof maxSpan && void 0 === property) {
          property = maxSpan;
          maxSpan = void 0;
        }
        if (void 0 === maxSpan) {
          maxSpan = -1;
        } else if (!Number.isInteger(maxSpan)) {
          throw new TypeError("maxSpan must be an integer");
        }
        super(-1, property);
        this.maxSpan = maxSpan;
      }
      /** @override */
      getSpan(b, offset3 = 0) {
        checkUint8Array(b);
        return b.length - offset3;
      }
      /** @override */
      decode(b, offset3 = 0) {
        const span = this.getSpan(b, offset3);
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        return uint8ArrayToBuffer(b).slice(offset3, offset3 + span).toString("utf-8");
      }
      /** @override */
      encode(src, b, offset3 = 0) {
        if ("string" !== typeof src) {
          src = String(src);
        }
        const srcb = buffer_1.Buffer.from(src, "utf8");
        const span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        if (offset3 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(uint8ArrayToBuffer(b), offset3);
        return span;
      }
    };
    exports2.UTF8 = UTF8;
    var Constant = class extends Layout2 {
      constructor(value, property) {
        super(0, property);
        this.value = value;
      }
      /** @override */
      decode(b, offset3) {
        return this.value;
      }
      /** @override */
      encode(src, b, offset3) {
        return 0;
      }
    };
    exports2.Constant = Constant;
    exports2.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
    exports2.offset = (layout, offset3, property) => new OffsetLayout2(layout, offset3, property);
    exports2.u8 = (property) => new UInt2(1, property);
    exports2.u16 = (property) => new UInt2(2, property);
    exports2.u24 = (property) => new UInt2(3, property);
    exports2.u32 = (property) => new UInt2(4, property);
    exports2.u40 = (property) => new UInt2(5, property);
    exports2.u48 = (property) => new UInt2(6, property);
    exports2.nu64 = (property) => new NearUInt642(property);
    exports2.u16be = (property) => new UIntBE2(2, property);
    exports2.u24be = (property) => new UIntBE2(3, property);
    exports2.u32be = (property) => new UIntBE2(4, property);
    exports2.u40be = (property) => new UIntBE2(5, property);
    exports2.u48be = (property) => new UIntBE2(6, property);
    exports2.nu64be = (property) => new NearUInt64BE(property);
    exports2.s8 = (property) => new Int(1, property);
    exports2.s16 = (property) => new Int(2, property);
    exports2.s24 = (property) => new Int(3, property);
    exports2.s32 = (property) => new Int(4, property);
    exports2.s40 = (property) => new Int(5, property);
    exports2.s48 = (property) => new Int(6, property);
    exports2.ns64 = (property) => new NearInt642(property);
    exports2.s16be = (property) => new IntBE(2, property);
    exports2.s24be = (property) => new IntBE(3, property);
    exports2.s32be = (property) => new IntBE(4, property);
    exports2.s40be = (property) => new IntBE(5, property);
    exports2.s48be = (property) => new IntBE(6, property);
    exports2.ns64be = (property) => new NearInt64BE(property);
    exports2.f32 = (property) => new Float(property);
    exports2.f32be = (property) => new FloatBE(property);
    exports2.f64 = (property) => new Double(property);
    exports2.f64be = (property) => new DoubleBE(property);
    exports2.struct = (fields, property, decodePrefixes) => new Structure2(fields, property, decodePrefixes);
    exports2.bits = (word, msb, property) => new BitStructure(word, msb, property);
    exports2.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
    exports2.union = (discr, defaultLayout, property) => new Union2(discr, defaultLayout, property);
    exports2.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator2(layout, property);
    exports2.blob = (length, property) => new Blob2(length, property);
    exports2.cstr = (property) => new CString(property);
    exports2.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
    exports2.constant = (value, property) => new Constant(value, property);
  }
});

// node_modules/bigint-buffer/dist/browser.js
var require_browser = __commonJS({
  "node_modules/bigint-buffer/dist/browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var converter;
    function toBigIntLE2(buf) {
      {
        const reversed = Buffer.from(buf);
        reversed.reverse();
        const hex2 = reversed.toString("hex");
        if (hex2.length === 0) {
          return BigInt(0);
        }
        return BigInt(`0x${hex2}`);
      }
      return converter.toBigInt(buf, false);
    }
    exports2.toBigIntLE = toBigIntLE2;
    function toBigIntBE(buf) {
      {
        const hex2 = buf.toString("hex");
        if (hex2.length === 0) {
          return BigInt(0);
        }
        return BigInt(`0x${hex2}`);
      }
      return converter.toBigInt(buf, true);
    }
    exports2.toBigIntBE = toBigIntBE;
    function toBufferLE2(num, width) {
      {
        const hex2 = num.toString(16);
        const buffer = Buffer.from(hex2.padStart(width * 2, "0").slice(0, width * 2), "hex");
        buffer.reverse();
        return buffer;
      }
      return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
    }
    exports2.toBufferLE = toBufferLE2;
    function toBufferBE(num, width) {
      {
        const hex2 = num.toString(16);
        return Buffer.from(hex2.padStart(width * 2, "0").slice(0, width * 2), "hex");
      }
      return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
    }
    exports2.toBufferBE = toBufferBE;
  }
});

// node_modules/@solana/web3.js/node_modules/superstruct/lib/index.es.js
function isIterable(x) {
  return isObject(x) && typeof x[Symbol.iterator] === "function";
}
function isObject(x) {
  return typeof x === "object" && x != null;
}
function print(value) {
  return typeof value === "string" ? JSON.stringify(value) : "" + value;
}
function shiftIterator(input) {
  const {
    done,
    value
  } = input.next();
  return done ? void 0 : value;
}
function toFailure(result, context, struct4, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = {
      message: result
    };
  }
  const {
    path,
    branch
  } = context;
  const {
    type: type3
  } = struct4;
  const {
    refinement,
    message = "Expected a value of type `" + type3 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print(value) + "`"
  } = result;
  return {
    value,
    type: type3,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures(result, context, struct4, value) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const r of result) {
    const failure = toFailure(r, context, struct4, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct4, options = {}) {
  const {
    path = [],
    branch = [value],
    coerce: coerce3 = false,
    mask: mask3 = false
  } = options;
  const ctx = {
    path,
    branch
  };
  if (coerce3) {
    value = struct4.coercer(value, ctx);
    if (mask3 && struct4.type !== "type" && isObject(struct4.schema) && isObject(value) && !Array.isArray(value)) {
      for (const key in value) {
        if (struct4.schema[key] === void 0) {
          delete value[key];
        }
      }
    }
  }
  let valid = true;
  for (const failure of struct4.validator(value, ctx)) {
    valid = false;
    yield [failure, void 0];
  }
  for (let [k, v, s] of struct4.entries(value, ctx)) {
    const ts = run(v, s, {
      path: k === void 0 ? path : [...path, k],
      branch: k === void 0 ? branch : [...branch, v],
      coerce: coerce3,
      mask: mask3
    });
    for (const t of ts) {
      if (t[0]) {
        valid = false;
        yield [t[0], void 0];
      } else if (coerce3) {
        v = t[1];
        if (k === void 0) {
          value = v;
        } else if (value instanceof Map) {
          value.set(k, v);
        } else if (value instanceof Set) {
          value.add(v);
        } else if (isObject(value)) {
          value[k] = v;
        }
      }
    }
  }
  if (valid) {
    for (const failure of struct4.refiner(value, ctx)) {
      valid = false;
      yield [failure, void 0];
    }
  }
  if (valid) {
    yield [void 0, value];
  }
}
function assert2(value, struct4) {
  const result = validate(value, struct4);
  if (result[0]) {
    throw result[0];
  }
}
function create(value, struct4) {
  const result = validate(value, struct4, {
    coerce: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value, struct4) {
  const result = validate(value, struct4, {
    coerce: true,
    mask: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is(value, struct4) {
  const result = validate(value, struct4);
  return !result[0];
}
function validate(value, struct4, options = {}) {
  const tuples = run(value, struct4, options);
  const tuple2 = shiftIterator(tuples);
  if (tuple2[0]) {
    const error = new StructError(tuple2[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v = tuple2[1];
    return [void 0, v];
  }
}
function define2(name, validator) {
  return new Struct({
    type: name,
    schema: null,
    validator
  });
}
function any() {
  return define2("any", () => true);
}
function array(Element) {
  return new Struct({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i, v] of value.entries()) {
          yield [i, v, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || "Expected an array value, but received: " + print(value);
    }
  });
}
function boolean() {
  return define2("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function instance(Class) {
  return define2("instance", (value) => {
    return value instanceof Class || "Expected a `" + Class.name + "` instance, but received: " + print(value);
  });
}
function literal(constant) {
  const description = print(constant);
  const t = typeof constant;
  return new Struct({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
    validator(value) {
      return value === constant || "Expected the literal `" + description + "`, but received: " + print(value);
    }
  });
}
function never() {
  return define2("never", () => false);
}
function nullable(struct4) {
  return new Struct({
    ...struct4,
    validator: (value, ctx) => value === null || struct4.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct4.refiner(value, ctx)
  });
}
function number2() {
  return define2("number", (value) => {
    return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print(value);
  });
}
function optional(struct4) {
  return new Struct({
    ...struct4,
    validator: (value, ctx) => value === void 0 || struct4.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct4.refiner(value, ctx)
  });
}
function record(Key, Value) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject(value)) {
        for (const k in value) {
          const v = value[k];
          yield [k, k, Key];
          yield [k, v, Value];
        }
      }
    },
    validator(value) {
      return isObject(value) || "Expected an object, but received: " + print(value);
    }
  });
}
function string() {
  return define2("string", (value) => {
    return typeof value === "string" || "Expected a string, but received: " + print(value);
  });
}
function tuple(Elements) {
  const Never = never();
  return new Struct({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length = Math.max(Elements.length, value.length);
        for (let i = 0; i < length; i++) {
          yield [i, value[i], Elements[i] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || "Expected an array, but received: " + print(value);
    }
  });
}
function type(schema) {
  const keys = Object.keys(schema);
  return new Struct({
    type: "type",
    schema,
    *entries(value) {
      if (isObject(value)) {
        for (const k of keys) {
          yield [k, value[k], schema[k]];
        }
      }
    },
    validator(value) {
      return isObject(value) || "Expected an object, but received: " + print(value);
    }
  });
}
function union(Structs) {
  const description = Structs.map((s) => s.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    validator(value, ctx) {
      const failures = [];
      for (const S of Structs) {
        const [...tuples] = run(value, S, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value), ...failures];
    }
  });
}
function unknown() {
  return define2("unknown", () => true);
}
function coerce(struct4, condition, coercer) {
  return new Struct({
    ...struct4,
    coercer: (value, ctx) => {
      return is(value, condition) ? struct4.coercer(coercer(value, ctx), ctx) : struct4.coercer(value, ctx);
    }
  });
}
var StructError, Struct;
var init_index_es = __esm({
  "node_modules/@solana/web3.js/node_modules/superstruct/lib/index.es.js"() {
    StructError = class extends TypeError {
      constructor(failure, failures) {
        let cached;
        const {
          message,
          ...rest
        } = failure;
        const {
          path
        } = failure;
        const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
        super(msg);
        Object.assign(this, rest);
        this.name = this.constructor.name;
        this.failures = () => {
          var _cached;
          return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
        };
      }
    };
    Struct = class {
      constructor(props) {
        const {
          type: type3,
          schema,
          validator,
          refiner,
          coercer = (value) => value,
          entries = function* () {
          }
        } = props;
        this.type = type3;
        this.schema = schema;
        this.entries = entries;
        this.coercer = coercer;
        if (validator) {
          this.validator = (value, context) => {
            const result = validator(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.validator = () => [];
        }
        if (refiner) {
          this.refiner = (value, context) => {
            const result = refiner(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.refiner = () => [];
        }
      }
      /**
       * Assert that a value passes the struct's validation, throwing if it doesn't.
       */
      assert(value) {
        return assert2(value, this);
      }
      /**
       * Create a value with the struct's coercion logic, then validate it.
       */
      create(value) {
        return create(value, this);
      }
      /**
       * Check if a value passes the struct's validation.
       */
      is(value) {
        return is(value, this);
      }
      /**
       * Mask a value, coercing and validating it, but returning only the subset of
       * properties defined by the struct's schema.
       */
      mask(value) {
        return mask(value, this);
      }
      /**
       * Validate a value with the struct's validation logic, returning a tuple
       * representing the result.
       *
       * You may optionally pass `true` for the `withCoercion` argument to coerce
       * the value before attempting to validate it. If you do, the result will
       * contain the coerced result when successful.
       */
      validate(value, options = {}) {
        return validate(value, this, options);
      }
    };
  }
});

// node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-browser/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-browser/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-browser/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-browser/validate.js"() {
    init_regex();
    validate_default = validate2;
  }
});

// node_modules/uuid/dist/esm-browser/stringify.js
function stringify(arr) {
  var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset3 + 0]] + byteToHex[arr[offset3 + 1]] + byteToHex[arr[offset3 + 2]] + byteToHex[arr[offset3 + 3]] + "-" + byteToHex[arr[offset3 + 4]] + byteToHex[arr[offset3 + 5]] + "-" + byteToHex[arr[offset3 + 6]] + byteToHex[arr[offset3 + 7]] + "-" + byteToHex[arr[offset3 + 8]] + byteToHex[arr[offset3 + 9]] + "-" + byteToHex[arr[offset3 + 10]] + byteToHex[arr[offset3 + 11]] + byteToHex[arr[offset3 + 12]] + byteToHex[arr[offset3 + 13]] + byteToHex[arr[offset3 + 14]] + byteToHex[arr[offset3 + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, i, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-browser/v1.js
function v1(options, buf, offset3) {
  var i = buf && offset3 || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-browser/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/esm-browser/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str2) {
  str2 = unescape(encodeURIComponent(str2));
  var bytes2 = [];
  for (var i = 0; i < str2.length; ++i) {
    bytes2.push(str2.charCodeAt(i));
  }
  return bytes2;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset3) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version2;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset3 = offset3 || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset3 + i] = bytes2[i];
      }
      return buf;
    }
    return stringify_default(bytes2);
  }
  try {
    generateUUID.name = name;
  } catch (err2) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
var DNS, URL;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-browser/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes2) {
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes2[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output2 = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex2 = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output2.push(hex2);
  }
  return output2;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output2 = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output2[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output2;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-browser/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-browser/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-browser/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset3) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset3 = offset3 || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset3 + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-browser/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes2) {
  var K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes2.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  var l = bytes2.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes2[_i * 64 + j * 4] << 24 | bytes2[_i * 64 + j * 4 + 1] << 16 | bytes2[_i * 64 + j * 4 + 2] << 8 | bytes2[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K2[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-browser/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-browser/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-browser/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-browser/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/esm-browser/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/esm-browser/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/esm-browser/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/uuid/dist/esm-browser/index.js
var esm_browser_exports = {};
__export(esm_browser_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_browser = __esm({
  "node_modules/uuid/dist/esm-browser/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/jayson/lib/generateRequest.js
var require_generateRequest = __commonJS({
  "node_modules/jayson/lib/generateRequest.js"(exports2, module2) {
    "use strict";
    var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
    var generateRequest = function(method2, params, id, options) {
      if (typeof method2 !== "string") {
        throw new TypeError(method2 + " must be a string");
      }
      options = options || {};
      const version2 = typeof options.version === "number" ? options.version : 2;
      if (version2 !== 1 && version2 !== 2) {
        throw new TypeError(version2 + " must be 1 or 2");
      }
      const request = {
        method: method2
      };
      if (version2 === 2) {
        request.jsonrpc = "2.0";
      }
      if (params) {
        if (typeof params !== "object" && !Array.isArray(params)) {
          throw new TypeError(params + " must be an object, array or omitted");
        }
        request.params = params;
      }
      if (typeof id === "undefined") {
        const generator = typeof options.generator === "function" ? options.generator : function() {
          return uuid();
        };
        request.id = generator(request, options);
      } else if (version2 === 2 && id === null) {
        if (options.notificationIdNull) {
          request.id = null;
        }
      } else {
        request.id = id;
      }
      return request;
    };
    module2.exports = generateRequest;
  }
});

// node_modules/jayson/lib/client/browser/index.js
var require_browser2 = __commonJS({
  "node_modules/jayson/lib/client/browser/index.js"(exports2, module2) {
    "use strict";
    var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
    var generateRequest = require_generateRequest();
    var ClientBrowser = function(callServer, options) {
      if (!(this instanceof ClientBrowser)) {
        return new ClientBrowser(callServer, options);
      }
      if (!options) {
        options = {};
      }
      this.options = {
        reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
        replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
        generator: typeof options.generator !== "undefined" ? options.generator : function() {
          return uuid();
        },
        version: typeof options.version !== "undefined" ? options.version : 2,
        notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
      };
      this.callServer = callServer;
    };
    module2.exports = ClientBrowser;
    ClientBrowser.prototype.request = function(method2, params, id, callback) {
      const self2 = this;
      let request = null;
      const isBatch = Array.isArray(method2) && typeof params === "function";
      if (this.options.version === 1 && isBatch) {
        throw new TypeError("JSON-RPC 1.0 does not support batching");
      }
      const isRaw = !isBatch && method2 && typeof method2 === "object" && typeof params === "function";
      if (isBatch || isRaw) {
        callback = params;
        request = method2;
      } else {
        if (typeof id === "function") {
          callback = id;
          id = void 0;
        }
        const hasCallback = typeof callback === "function";
        try {
          request = generateRequest(method2, params, id, {
            generator: this.options.generator,
            version: this.options.version,
            notificationIdNull: this.options.notificationIdNull
          });
        } catch (err2) {
          if (hasCallback) {
            return callback(err2);
          }
          throw err2;
        }
        if (!hasCallback) {
          return request;
        }
      }
      let message;
      try {
        message = JSON.stringify(request, this.options.replacer);
      } catch (err2) {
        return callback(err2);
      }
      this.callServer(message, function(err2, response) {
        self2._parseResponse(err2, response, callback);
      });
      return request;
    };
    ClientBrowser.prototype._parseResponse = function(err2, responseText, callback) {
      if (err2) {
        callback(err2);
        return;
      }
      if (!responseText) {
        return callback();
      }
      let response;
      try {
        response = JSON.parse(responseText, this.options.reviver);
      } catch (err3) {
        return callback(err3);
      }
      if (callback.length === 3) {
        if (Array.isArray(response)) {
          const isError = function(res) {
            return typeof res.error !== "undefined";
          };
          const isNotError = function(res) {
            return !isError(res);
          };
          return callback(null, response.filter(isError), response.filter(isNotError));
        } else {
          return callback(null, response.error, response.result);
        }
      }
      callback(null, response);
    };
  }
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports2, module2) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module2.exports = _interopRequireDefault, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports2, module2) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return module2.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof(obj);
    }
    module2.exports = _typeof, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports2, module2) {
    var _typeof = require_typeof()["default"];
    function _regeneratorRuntime() {
      "use strict";
      module2.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
        return exports3;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      var exports3 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define4(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define4({}, "");
      } catch (err2) {
        define4 = function define5(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self2, context)
        }), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err2) {
          return {
            type: "throw",
            arg: err2
          };
        }
      }
      exports3.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define4(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method2) {
          define4(prototype, method2, function(arg) {
            return this._invoke(method2, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke2(method2, arg, resolve, reject) {
          var record2 = tryCatch(generator[method2], generator, arg);
          if ("throw" !== record2.type) {
            var result = record2.arg, value = result.value;
            return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke2("next", value2, resolve, reject);
            }, function(err2) {
              invoke2("throw", err2, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke2("throw", error, resolve, reject);
            });
          }
          reject(record2.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", {
          value: function value(method2, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke2(method2, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self2, context) {
        var state = "suspendedStart";
        return function(method2, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method2)
              throw arg;
            return doneResult();
          }
          for (context.method = method2, context.arg = arg; ; ) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context.method)
              context.sent = context._sent = context.arg;
            else if ("throw" === context.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else
              "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record2 = tryCatch(innerFn, self2, context);
            if ("normal" === record2.type) {
              if (state = context.done ? "completed" : "suspendedYield", record2.arg === ContinueSentinel)
                continue;
              return {
                value: record2.arg,
                done: context.done
              };
            }
            "throw" === record2.type && (state = "completed", context.method = "throw", context.arg = record2.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method, method2 = delegate.iterator[methodName];
        if (void 0 === method2)
          return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record2 = tryCatch(method2, delegate.iterator, context.arg);
        if ("throw" === record2.type)
          return context.method = "throw", context.arg = record2.arg, context.delegate = null, ContinueSentinel;
        var info = record2.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record2 = entry.completion || {};
        record2.type = "normal", delete record2.arg, entry.completion = record2;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              for (; ++i < iterable.length; )
                if (hasOwn.call(iterable, i))
                  return next2.value = iterable[i], next2.done = false, next2;
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: void 0,
          done: true
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define4(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports3.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports3.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define4(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports3.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define4(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports3.AsyncIterator = AsyncIterator, exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define4(Gp, toStringTagSymbol, "Generator"), define4(Gp, iteratorSymbol, function() {
        return this;
      }), define4(Gp, "toString", function() {
        return "[object Generator]";
      }), exports3.keys = function(val) {
        var object = Object(val), keys = [];
        for (var key in object)
          keys.push(key);
        return keys.reverse(), function next() {
          for (; keys.length; ) {
            var key2 = keys.pop();
            if (key2 in object)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports3.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this)
              "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        },
        stop: function stop() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done)
            throw exception;
          var context = this;
          function handle(loc, caught) {
            return record2.type = "throw", record2.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i], record2 = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type3, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type3 || "continue" === type3) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record2 = finallyEntry ? finallyEntry.completion : {};
          return record2.type = type3, record2.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record2);
        },
        complete: function complete(record2, afterLoc) {
          if ("throw" === record2.type)
            throw record2.arg;
          return "break" === record2.type || "continue" === record2.type ? this.next = record2.arg : "return" === record2.type ? (this.rval = this.arg = record2.arg, this.method = "return", this.next = "end") : "normal" === record2.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record2 = entry.completion;
              if ("throw" === record2.type) {
                var thrown = record2.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports3;
    }
    module2.exports = _regeneratorRuntime, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports2, module2) {
    var runtime = require_regeneratorRuntime()();
    module2.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@babel/runtime/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS({
  "node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports2, module2) {
    function asyncGeneratorStep(gen2, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen2[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen2 = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen2, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err2) {
            asyncGeneratorStep(gen2, resolve, reject, _next, _throw, "throw", err2);
          }
          _next(void 0);
        });
      };
    }
    module2.exports = _asyncToGenerator, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports2, module2) {
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    module2.exports = _classCallCheck, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports2, module2) {
    var _typeof = require_typeof()["default"];
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    module2.exports = _toPrimitive, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports2, module2) {
    var _typeof = require_typeof()["default"];
    var toPrimitive = require_toPrimitive();
    function _toPropertyKey(arg) {
      var key = toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    module2.exports = _toPropertyKey, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "node_modules/@babel/runtime/helpers/createClass.js"(exports2, module2) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    module2.exports = _createClass, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports2, module2) {
    function _setPrototypeOf(o, p) {
      module2.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      return _setPrototypeOf(o, p);
    }
    module2.exports = _setPrototypeOf, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/runtime/helpers/inherits.js"(exports2, module2) {
    var setPrototypeOf = require_setPrototypeOf();
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass)
        setPrototypeOf(subClass, superClass);
    }
    module2.exports = _inherits, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS({
  "node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports2, module2) {
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    module2.exports = _assertThisInitialized, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS({
  "node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports2, module2) {
    var _typeof = require_typeof()["default"];
    var assertThisInitialized = require_assertThisInitialized();
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return assertThisInitialized(self2);
    }
    module2.exports = _possibleConstructorReturn, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports2, module2) {
    function _getPrototypeOf(o) {
      module2.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      return _getPrototypeOf(o);
    }
    module2.exports = _getPrototypeOf, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter2;
    }
  }
});

// node_modules/rpc-websockets/dist/lib/client.js
var require_client = __commonJS({
  "node_modules/rpc-websockets/dist/lib/client.js"(exports2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _eventemitter = require_eventemitter3();
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var __rest = function(s, e) {
      var t = {};
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      }
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    var CommonClient = function(_EventEmitter) {
      (0, _inherits2["default"])(CommonClient2, _EventEmitter);
      var _super = _createSuper(CommonClient2);
      function CommonClient2(webSocketFactory) {
        var _this;
        var address = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ws://localhost:8080";
        var _a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var generate_request_id = arguments.length > 3 ? arguments[3] : void 0;
        (0, _classCallCheck2["default"])(this, CommonClient2);
        var _a$autoconnect = _a.autoconnect, autoconnect = _a$autoconnect === void 0 ? true : _a$autoconnect, _a$reconnect = _a.reconnect, reconnect = _a$reconnect === void 0 ? true : _a$reconnect, _a$reconnect_interval = _a.reconnect_interval, reconnect_interval = _a$reconnect_interval === void 0 ? 1e3 : _a$reconnect_interval, _a$max_reconnects = _a.max_reconnects, max_reconnects = _a$max_reconnects === void 0 ? 5 : _a$max_reconnects, rest_options = __rest(_a, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
        _this = _super.call(this);
        _this.webSocketFactory = webSocketFactory;
        _this.queue = {};
        _this.rpc_id = 0;
        _this.address = address;
        _this.autoconnect = autoconnect;
        _this.ready = false;
        _this.reconnect = reconnect;
        _this.reconnect_timer_id = void 0;
        _this.reconnect_interval = reconnect_interval;
        _this.max_reconnects = max_reconnects;
        _this.rest_options = rest_options;
        _this.current_reconnects = 0;
        _this.generate_request_id = generate_request_id || function() {
          return ++_this.rpc_id;
        };
        if (_this.autoconnect)
          _this._connect(_this.address, Object.assign({
            autoconnect: _this.autoconnect,
            reconnect: _this.reconnect,
            reconnect_interval: _this.reconnect_interval,
            max_reconnects: _this.max_reconnects
          }, _this.rest_options));
        return _this;
      }
      (0, _createClass2["default"])(CommonClient2, [{
        key: "connect",
        value: function connect() {
          if (this.socket)
            return;
          this._connect(this.address, Object.assign({
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects
          }, this.rest_options));
        }
        /**
         * Calls a registered RPC method on server.
         * @method
         * @param {String} method - RPC method name
         * @param {Object|Array} params - optional method parameters
         * @param {Number} timeout - RPC reply timeout value
         * @param {Object} ws_opts - options passed to ws
         * @return {Promise}
         */
      }, {
        key: "call",
        value: function call(method2, params, timeout, ws_opts) {
          var _this2 = this;
          if (!ws_opts && "object" === (0, _typeof2["default"])(timeout)) {
            ws_opts = timeout;
            timeout = null;
          }
          return new Promise(function(resolve, reject) {
            if (!_this2.ready)
              return reject(new Error("socket not ready"));
            var rpc_id = _this2.generate_request_id(method2, params);
            var message = {
              jsonrpc: "2.0",
              method: method2,
              params: params || null,
              id: rpc_id
            };
            _this2.socket.send(JSON.stringify(message), ws_opts, function(error) {
              if (error)
                return reject(error);
              _this2.queue[rpc_id] = {
                promise: [resolve, reject]
              };
              if (timeout) {
                _this2.queue[rpc_id].timeout = setTimeout(function() {
                  delete _this2.queue[rpc_id];
                  reject(new Error("reply timeout"));
                }, timeout);
              }
            });
          });
        }
        /**
         * Logins with the other side of the connection.
         * @method
         * @param {Object} params - Login credentials object
         * @return {Promise}
         */
      }, {
        key: "login",
        value: function() {
          var _login = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(params) {
            var resp;
            return _regenerator["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.call("rpc.login", params);
                  case 2:
                    resp = _context.sent;
                    if (resp) {
                      _context.next = 5;
                      break;
                    }
                    throw new Error("authentication failed");
                  case 5:
                    return _context.abrupt("return", resp);
                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function login(_x) {
            return _login.apply(this, arguments);
          }
          return login;
        }()
        /**
         * Fetches a list of client's methods registered on server.
         * @method
         * @return {Array}
         */
      }, {
        key: "listMethods",
        value: function() {
          var _listMethods = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
            return _regenerator["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.call("__listMethods");
                  case 2:
                    return _context2.abrupt("return", _context2.sent);
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function listMethods() {
            return _listMethods.apply(this, arguments);
          }
          return listMethods;
        }()
        /**
         * Sends a JSON-RPC 2.0 notification to server.
         * @method
         * @param {String} method - RPC method name
         * @param {Object} params - optional method parameters
         * @return {Promise}
         */
      }, {
        key: "notify",
        value: function notify(method2, params) {
          var _this3 = this;
          return new Promise(function(resolve, reject) {
            if (!_this3.ready)
              return reject(new Error("socket not ready"));
            var message = {
              jsonrpc: "2.0",
              method: method2,
              params: params || null
            };
            _this3.socket.send(JSON.stringify(message), function(error) {
              if (error)
                return reject(error);
              resolve();
            });
          });
        }
        /**
         * Subscribes for a defined event.
         * @method
         * @param {String|Array} event - event name
         * @return {Undefined}
         * @throws {Error}
         */
      }, {
        key: "subscribe",
        value: function() {
          var _subscribe = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(event) {
            var result;
            return _regenerator["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (typeof event === "string")
                      event = [event];
                    _context3.next = 3;
                    return this.call("rpc.on", event);
                  case 3:
                    result = _context3.sent;
                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context3.next = 6;
                      break;
                    }
                    throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);
                  case 6:
                    return _context3.abrupt("return", result);
                  case 7:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function subscribe(_x2) {
            return _subscribe.apply(this, arguments);
          }
          return subscribe;
        }()
        /**
         * Unsubscribes from a defined event.
         * @method
         * @param {String|Array} event - event name
         * @return {Undefined}
         * @throws {Error}
         */
      }, {
        key: "unsubscribe",
        value: function() {
          var _unsubscribe = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(event) {
            var result;
            return _regenerator["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (typeof event === "string")
                      event = [event];
                    _context4.next = 3;
                    return this.call("rpc.off", event);
                  case 3:
                    result = _context4.sent;
                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context4.next = 6;
                      break;
                    }
                    throw new Error("Failed unsubscribing from an event with: " + result);
                  case 6:
                    return _context4.abrupt("return", result);
                  case 7:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function unsubscribe(_x3) {
            return _unsubscribe.apply(this, arguments);
          }
          return unsubscribe;
        }()
        /**
         * Closes a WebSocket connection gracefully.
         * @method
         * @param {Number} code - socket close code
         * @param {String} data - optional data to be sent before closing
         * @return {Undefined}
         */
      }, {
        key: "close",
        value: function close(code, data) {
          this.socket.close(code || 1e3, data);
        }
        /**
         * Connection/Message handler.
         * @method
         * @private
         * @param {String} address - WebSocket API address
         * @param {Object} options - ws options object
         * @return {Undefined}
         */
      }, {
        key: "_connect",
        value: function _connect(address, options) {
          var _this4 = this;
          clearTimeout(this.reconnect_timer_id);
          this.socket = this.webSocketFactory(address, options);
          this.socket.addEventListener("open", function() {
            _this4.ready = true;
            _this4.emit("open");
            _this4.current_reconnects = 0;
          });
          this.socket.addEventListener("message", function(_ref) {
            var message = _ref.data;
            if (message instanceof ArrayBuffer)
              message = Buffer.from(message).toString();
            try {
              message = JSON.parse(message);
            } catch (error) {
              return;
            }
            if (message.notification && _this4.listeners(message.notification).length) {
              if (!Object.keys(message.params).length)
                return _this4.emit(message.notification);
              var args = [message.notification];
              if (message.params.constructor === Object)
                args.push(message.params);
              else
                for (var i = 0; i < message.params.length; i++) {
                  args.push(message.params[i]);
                }
              return Promise.resolve().then(function() {
                _this4.emit.apply(_this4, args);
              });
            }
            if (!_this4.queue[message.id]) {
              if (message.method && message.params) {
                return Promise.resolve().then(function() {
                  _this4.emit(message.method, message.params);
                });
              }
              return;
            }
            if ("error" in message === "result" in message)
              _this4.queue[message.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.'));
            if (_this4.queue[message.id].timeout)
              clearTimeout(_this4.queue[message.id].timeout);
            if (message.error)
              _this4.queue[message.id].promise[1](message.error);
            else
              _this4.queue[message.id].promise[0](message.result);
            delete _this4.queue[message.id];
          });
          this.socket.addEventListener("error", function(error) {
            return _this4.emit("error", error);
          });
          this.socket.addEventListener("close", function(_ref2) {
            var code = _ref2.code, reason = _ref2.reason;
            if (_this4.ready)
              setTimeout(function() {
                return _this4.emit("close", code, reason);
              }, 0);
            _this4.ready = false;
            _this4.socket = void 0;
            if (code === 1e3)
              return;
            _this4.current_reconnects++;
            if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0))
              _this4.reconnect_timer_id = setTimeout(function() {
                return _this4._connect(address, options);
              }, _this4.reconnect_interval);
          });
        }
      }]);
      return CommonClient2;
    }(_eventemitter.EventEmitter);
    exports2["default"] = CommonClient;
  }
});

// node_modules/rpc-websockets/dist/lib/client/websocket.browser.js
var require_websocket_browser = __commonJS({
  "node_modules/rpc-websockets/dist/lib/client/websocket.browser.js"(exports2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = _default;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _eventemitter = require_eventemitter3();
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var WebSocketBrowserImpl = function(_EventEmitter) {
      (0, _inherits2["default"])(WebSocketBrowserImpl2, _EventEmitter);
      var _super = _createSuper(WebSocketBrowserImpl2);
      function WebSocketBrowserImpl2(address, options, protocols) {
        var _this;
        (0, _classCallCheck2["default"])(this, WebSocketBrowserImpl2);
        _this = _super.call(this);
        _this.socket = new window.WebSocket(address, protocols);
        _this.socket.onopen = function() {
          return _this.emit("open");
        };
        _this.socket.onmessage = function(event) {
          return _this.emit("message", event.data);
        };
        _this.socket.onerror = function(error) {
          return _this.emit("error", error);
        };
        _this.socket.onclose = function(event) {
          _this.emit("close", event.code, event.reason);
        };
        return _this;
      }
      (0, _createClass2["default"])(WebSocketBrowserImpl2, [{
        key: "send",
        value: function send(data, optionsOrCallback, callback) {
          var cb = callback || optionsOrCallback;
          try {
            this.socket.send(data);
            cb();
          } catch (error) {
            cb(error);
          }
        }
        /**
         * Closes an underlying socket
         * @method
         * @param {Number} code - status code explaining why the connection is being closed
         * @param {String} reason - a description why the connection is closing
         * @return {Undefined}
         * @throws {Error}
         */
      }, {
        key: "close",
        value: function close(code, reason) {
          this.socket.close(code, reason);
        }
      }, {
        key: "addEventListener",
        value: function addEventListener(type3, listener, options) {
          this.socket.addEventListener(type3, listener, options);
        }
      }]);
      return WebSocketBrowserImpl2;
    }(_eventemitter.EventEmitter);
    function _default(address, options) {
      return new WebSocketBrowserImpl(address, options);
    }
  }
});

// node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n2, _1n2, _2n2, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake, shake128, shake256;
var init_sha3 = __esm({
  "node_modules/@noble/hashes/esm/sha3.js"() {
    init_assert();
    init_u64();
    init_utils();
    [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    _0n2 = BigInt(0);
    _1n2 = BigInt(1);
    _2n2 = BigInt(2);
    _7n = BigInt(7);
    _256n = BigInt(256);
    _0x71n = BigInt(113);
    for (let round = 0, R = _1n2, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n2;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n2 ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n2)
          t ^= _1n2 << (_1n2 << BigInt(j)) - _1n2;
      }
      _SHA3_IOTA.push(t);
    }
    [SHA3_IOTA_H, SHA3_IOTA_L] = u64_default.split(_SHA3_IOTA, true);
    rotlH = (h, l, s) => s > 32 ? u64_default.rotlBH(h, l, s) : u64_default.rotlSH(h, l, s);
    rotlL = (h, l, s) => s > 32 ? u64_default.rotlBL(h, l, s) : u64_default.rotlSL(h, l, s);
    Keccak = class extends Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        assert_default.number(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        assert_default.exists(this);
        const { blockLen, state } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        assert_default.exists(this, false);
        assert_default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes2) {
        assert_default.number(bytes2);
        return this.xofInto(new Uint8Array(bytes2));
      }
      digestInto(out) {
        assert_default.output(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
    sha3_224 = gen(6, 144, 224 / 8);
    sha3_256 = gen(6, 136, 256 / 8);
    sha3_384 = gen(6, 104, 384 / 8);
    sha3_512 = gen(6, 72, 512 / 8);
    keccak_224 = gen(1, 144, 224 / 8);
    keccak_256 = gen(1, 136, 256 / 8);
    keccak_384 = gen(1, 104, 384 / 8);
    keccak_512 = gen(1, 72, 512 / 8);
    genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    shake128 = genShake(31, 168, 128 / 8);
    shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/@noble/hashes/esm/hmac.js
var HMAC, hmac;
var init_hmac = __esm({
  "node_modules/@noble/hashes/esm/hmac.js"() {
    init_assert();
    init_utils();
    HMAC = class extends Hash {
      constructor(hash3, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        assert_default.hash(hash3);
        const key = toBytes(_key);
        this.iHash = hash3.create();
        if (typeof this.iHash.update !== "function")
          throw new TypeError("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash3.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        assert_default.exists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        assert_default.exists(this);
        assert_default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished: finished2, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished2;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
    hmac.create = (hash3, key) => new HMAC(hash3, key);
  }
});

// node_modules/@noble/secp256k1/lib/esm/index.js
function weierstrass(x) {
  const { a, b } = CURVE2;
  const x2 = mod2(x * x);
  const x3 = mod2(x2 * x);
  return mod2(x3 + a * x + b);
}
function assertJacPoint(other) {
  if (!(other instanceof JacobianPoint))
    throw new TypeError("JacobianPoint expected");
}
function constTimeNegate2(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function sliceDER(s) {
  return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex2(data)}`);
  }
  const len = data[1];
  const res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex2(data)}`);
  }
  if (data[1] !== data.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
  const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex2(rBytesLeft)}`);
  }
  return { r, s };
}
function concatBytes2(...arrays) {
  if (!arrays.every((b) => b instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
function bytesToHex2(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let hex2 = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex2 += hexes3[uint8a[i]];
  }
  return hex2;
}
function numTo32bStr(num) {
  if (typeof num !== "bigint")
    throw new Error("Expected bigint");
  if (!(_0n3 <= num && num < POW_2_2562))
    throw new Error("Expected number 0 <= n < 2^256");
  return num.toString(16).padStart(64, "0");
}
function numTo32b(num) {
  const b = hexToBytes2(numTo32bStr(num));
  if (b.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return b;
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex2);
  }
  return BigInt(`0x${hex2}`);
}
function hexToBytes2(hex2) {
  if (typeof hex2 !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex2);
  }
  if (hex2.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + hex2.length);
  const array4 = new Uint8Array(hex2.length / 2);
  for (let i = 0; i < array4.length; i++) {
    const j = i * 2;
    const hexByte = hex2.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array4[i] = byte;
  }
  return array4;
}
function bytesToNumber(bytes2) {
  return hexToNumber(bytesToHex2(bytes2));
}
function ensureBytes2(hex2) {
  return hex2 instanceof Uint8Array ? Uint8Array.from(hex2) : hexToBytes2(hex2);
}
function normalizeScalar2(num) {
  if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
    return BigInt(num);
  if (typeof num === "bigint" && isWithinCurveOrder(num))
    return num;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod2(a, b = CURVE2.P) {
  const result = a % b;
  return result >= _0n3 ? result : b + result;
}
function pow22(x, power) {
  const { P } = CURVE2;
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= P;
  }
  return res;
}
function sqrtMod(x) {
  const { P } = CURVE2;
  const _6n = BigInt(6);
  const _11n = BigInt(11);
  const _22n = BigInt(22);
  const _23n = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b2 = x * x * x % P;
  const b3 = b2 * b2 * x % P;
  const b6 = pow22(b3, _3n) * b3 % P;
  const b9 = pow22(b6, _3n) * b3 % P;
  const b11 = pow22(b9, _2n3) * b2 % P;
  const b22 = pow22(b11, _11n) * b11 % P;
  const b44 = pow22(b22, _22n) * b22 % P;
  const b88 = pow22(b44, _44n) * b44 % P;
  const b176 = pow22(b88, _88n) * b88 % P;
  const b220 = pow22(b176, _44n) * b44 % P;
  const b223 = pow22(b220, _3n) * b3 % P;
  const t1 = pow22(b223, _23n) * b22 % P;
  const t2 = pow22(t1, _6n) * b2 % P;
  const rt = pow22(t2, _2n3);
  const xc = rt * rt % P;
  if (xc !== x)
    throw new Error("Cannot find square root");
  return rt;
}
function invert2(number4, modulo = CURVE2.P) {
  if (number4 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number4} mod=${modulo}`);
  }
  let a = mod2(number4, modulo);
  let b = modulo;
  let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
  while (a !== _0n3) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function invertBatch2(nums, p = CURVE2.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n3)
      return acc;
    scratch[i] = acc;
    return mod2(acc * num, p);
  }, _1n3);
  const inverted = invert2(lastMultiplied, p);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n3)
      return acc;
    scratch[i] = mod2(acc * scratch[i], p);
    return mod2(acc * num, p);
  }, inverted);
  return scratch;
}
function bits2int_2(bytes2) {
  const delta = bytes2.length * 8 - groupLen * 8;
  const num = bytesToNumber(bytes2);
  return delta > 0 ? num >> BigInt(delta) : num;
}
function truncateHash(hash3, truncateOnly = false) {
  const h = bits2int_2(hash3);
  if (truncateOnly)
    return h;
  const { n } = CURVE2;
  return h >= n ? h - n : h;
}
function isWithinCurveOrder(num) {
  return _0n3 < num && num < CURVE2.n;
}
function isValidFieldElement(num) {
  return _0n3 < num && num < CURVE2.P;
}
function kmdToSig(kBytes, m, d, lowS = true) {
  const { n } = CURVE2;
  const k = truncateHash(kBytes, true);
  if (!isWithinCurveOrder(k))
    return;
  const kinv = invert2(k, n);
  const q = Point2.BASE.multiply(k);
  const r = mod2(q.x, n);
  if (r === _0n3)
    return;
  const s = mod2(kinv * mod2(m + d * r, n), n);
  if (s === _0n3)
    return;
  let sig = new Signature2(r, s);
  let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n3);
  if (lowS && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  return { sig, recovery };
}
function normalizePrivateKey(key) {
  let num;
  if (typeof key === "bigint") {
    num = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 2 * groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = hexToNumber(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = bytesToNumber(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num))
    throw new Error("Expected private key: 0 < key < n");
  return num;
}
function normalizeSignature(signature2) {
  if (signature2 instanceof Signature2) {
    signature2.assertValidity();
    return signature2;
  }
  try {
    return Signature2.fromDER(signature2);
  } catch (error) {
    return Signature2.fromCompact(signature2);
  }
}
function getPublicKey(privateKey, isCompressed = false) {
  return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
function bits2int(bytes2) {
  const slice = bytes2.length > fieldLen ? bytes2.slice(0, fieldLen) : bytes2;
  return bytesToNumber(slice);
}
function bits2octets(bytes2) {
  const z1 = bits2int(bytes2);
  const z2 = mod2(z1, CURVE2.n);
  return int2octets(z2 < _0n3 ? z1 : z2);
}
function int2octets(num) {
  return numTo32b(num);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null)
    throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
  const h1 = ensureBytes2(msgHash);
  const d = normalizePrivateKey(privateKey);
  const seedArgs = [int2octets(d), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true)
      extraEntropy = utils2.randomBytes(fieldLen);
    const e = ensureBytes2(extraEntropy);
    if (e.length !== fieldLen)
      throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
    seedArgs.push(e);
  }
  const seed2 = concatBytes2(...seedArgs);
  const m = bits2int(h1);
  return { seed: seed2, m, d };
}
function finalizeSig(recSig, opts) {
  const { sig, recovery } = recSig;
  const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
function signSync2(msgHash, privKey, opts = {}) {
  const { seed: seed2, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
  const drbg = new HmacDrbg(hashLen, groupLen);
  drbg.reseedSync(seed2);
  let sig;
  while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))
    drbg.reseedSync();
  return finalizeSig(sig, opts);
}
var nodeCrypto2, _0n3, _1n3, _2n3, _3n, _8n2, CURVE2, divNearest, endo, fieldLen, groupLen, hashLen, compressedLen, uncompressedLen, USE_ENDOMORPHISM, ShaError, JacobianPoint, pointPrecomputes2, Point2, Signature2, hexes3, POW_2_2562, _sha256Sync, _hmacSha256Sync, HmacDrbg, crypto4, TAGGED_HASH_PREFIXES, utils2;
var init_esm2 = __esm({
  "node_modules/@noble/secp256k1/lib/esm/index.js"() {
    nodeCrypto2 = __toESM(require_crypto());
    _0n3 = BigInt(0);
    _1n3 = BigInt(1);
    _2n3 = BigInt(2);
    _3n = BigInt(3);
    _8n2 = BigInt(8);
    CURVE2 = Object.freeze({
      a: _0n3,
      b: BigInt(7),
      P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: _1n3,
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
    });
    divNearest = (a, b) => (a + b / _2n3) / b;
    endo = {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar(k) {
        const { n } = CURVE2;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n3 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod2(k - c1 * a1 - c2 * a2, n);
        let k2 = mod2(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    };
    fieldLen = 32;
    groupLen = 32;
    hashLen = 32;
    compressedLen = fieldLen + 1;
    uncompressedLen = 2 * fieldLen + 1;
    USE_ENDOMORPHISM = CURVE2.a === _0n3;
    ShaError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    JacobianPoint = class {
      constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      }
      static fromAffine(p) {
        if (!(p instanceof Point2)) {
          throw new TypeError("JacobianPoint#fromAffine: expected Point");
        }
        if (p.equals(Point2.ZERO))
          return JacobianPoint.ZERO;
        return new JacobianPoint(p.x, p.y, _1n3);
      }
      static toAffineBatch(points) {
        const toInv = invertBatch2(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
      }
      static normalizeZ(points) {
        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
      }
      equals(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const Z1Z1 = mod2(Z1 * Z1);
        const Z2Z2 = mod2(Z2 * Z2);
        const U1 = mod2(X1 * Z2Z2);
        const U2 = mod2(X2 * Z1Z1);
        const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
        const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
      }
      negate() {
        return new JacobianPoint(this.x, mod2(-this.y), this.z);
      }
      double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const A = mod2(X1 * X1);
        const B = mod2(Y1 * Y1);
        const C = mod2(B * B);
        const x1b = X1 + B;
        const D = mod2(_2n3 * (mod2(x1b * x1b) - A - C));
        const E = mod2(_3n * A);
        const F = mod2(E * E);
        const X3 = mod2(F - _2n3 * D);
        const Y3 = mod2(E * (D - X3) - _8n2 * C);
        const Z3 = mod2(_2n3 * Y1 * Z1);
        return new JacobianPoint(X3, Y3, Z3);
      }
      add(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        if (X2 === _0n3 || Y2 === _0n3)
          return this;
        if (X1 === _0n3 || Y1 === _0n3)
          return other;
        const Z1Z1 = mod2(Z1 * Z1);
        const Z2Z2 = mod2(Z2 * Z2);
        const U1 = mod2(X1 * Z2Z2);
        const U2 = mod2(X2 * Z1Z1);
        const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
        const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
        const H = mod2(U2 - U1);
        const r = mod2(S2 - S1);
        if (H === _0n3) {
          if (r === _0n3) {
            return this.double();
          } else {
            return JacobianPoint.ZERO;
          }
        }
        const HH = mod2(H * H);
        const HHH = mod2(H * HH);
        const V = mod2(U1 * HH);
        const X3 = mod2(r * r - HHH - _2n3 * V);
        const Y3 = mod2(r * (V - X3) - S1 * HHH);
        const Z3 = mod2(Z1 * Z2 * H);
        return new JacobianPoint(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiplyUnsafe(scalar) {
        const P0 = JacobianPoint.ZERO;
        if (typeof scalar === "bigint" && scalar === _0n3)
          return P0;
        let n = normalizeScalar2(scalar);
        if (n === _1n3)
          return this;
        if (!USE_ENDOMORPHISM) {
          let p = P0;
          let d2 = this;
          while (n > _0n3) {
            if (n & _1n3)
              p = p.add(d2);
            d2 = d2.double();
            n >>= _1n3;
          }
          return p;
        }
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let k1p = P0;
        let k2p = P0;
        let d = this;
        while (k1 > _0n3 || k2 > _0n3) {
          if (k1 & _1n3)
            k1p = k1p.add(d);
          if (k2 & _1n3)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n3;
          k2 >>= _1n3;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new JacobianPoint(mod2(k2p.x * endo.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
      }
      precomputeWindow(W) {
        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
        const points = [];
        let p = this;
        let base = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1; i < 2 ** (W - 1); i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      }
      wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(JacobianPoint.BASE))
          affinePoint = Point2.BASE;
        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W) {
          throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
        }
        let precomputes = affinePoint && pointPrecomputes2.get(affinePoint);
        if (!precomputes) {
          precomputes = this.precomputeWindow(W);
          if (affinePoint && W !== 1) {
            precomputes = JacobianPoint.normalizeZ(precomputes);
            pointPrecomputes2.set(affinePoint, precomputes);
          }
        }
        let p = JacobianPoint.ZERO;
        let f2 = JacobianPoint.BASE;
        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
        const windowSize = 2 ** (W - 1);
        const mask3 = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset3 = window2 * windowSize;
          let wbits = Number(n & mask3);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n3;
          }
          const offset1 = offset3;
          const offset22 = offset3 + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f2 = f2.add(constTimeNegate2(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate2(cond2, precomputes[offset22]));
          }
        }
        return { p, f: f2 };
      }
      multiply(scalar, affinePoint) {
        let n = normalizeScalar2(scalar);
        let point;
        let fake;
        if (USE_ENDOMORPHISM) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
          let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
          k1p = constTimeNegate2(k1neg, k1p);
          k2p = constTimeNegate2(k2neg, k2p);
          k2p = new JacobianPoint(mod2(k2p.x * endo.beta), k2p.y, k2p.z);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f: f2 } = this.wNAF(n, affinePoint);
          point = p;
          fake = f2;
        }
        return JacobianPoint.normalizeZ([point, fake])[0];
      }
      toAffine(invZ) {
        const { x, y, z } = this;
        const is0 = this.equals(JacobianPoint.ZERO);
        if (invZ == null)
          invZ = is0 ? _8n2 : invert2(z);
        const iz1 = invZ;
        const iz2 = mod2(iz1 * iz1);
        const iz3 = mod2(iz2 * iz1);
        const ax = mod2(x * iz2);
        const ay = mod2(y * iz3);
        const zz = mod2(z * iz1);
        if (is0)
          return Point2.ZERO;
        if (zz !== _1n3)
          throw new Error("invZ was invalid");
        return new Point2(ax, ay);
      }
    };
    JacobianPoint.BASE = new JacobianPoint(CURVE2.Gx, CURVE2.Gy, _1n3);
    JacobianPoint.ZERO = new JacobianPoint(_0n3, _1n3, _0n3);
    pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
    Point2 = class {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes2.delete(this);
      }
      hasEvenY() {
        return this.y % _2n3 === _0n3;
      }
      static fromCompressedHex(bytes2) {
        const isShort = bytes2.length === 32;
        const x = bytesToNumber(isShort ? bytes2 : bytes2.subarray(1));
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrass(x);
        let y = sqrtMod(y2);
        const isYOdd = (y & _1n3) === _1n3;
        if (isShort) {
          if (isYOdd)
            y = mod2(-y);
        } else {
          const isFirstByteOdd = (bytes2[0] & 1) === 1;
          if (isFirstByteOdd !== isYOdd)
            y = mod2(-y);
        }
        const point = new Point2(x, y);
        point.assertValidity();
        return point;
      }
      static fromUncompressedHex(bytes2) {
        const x = bytesToNumber(bytes2.subarray(1, fieldLen + 1));
        const y = bytesToNumber(bytes2.subarray(fieldLen + 1, fieldLen * 2 + 1));
        const point = new Point2(x, y);
        point.assertValidity();
        return point;
      }
      static fromHex(hex2) {
        const bytes2 = ensureBytes2(hex2);
        const len = bytes2.length;
        const header = bytes2[0];
        if (len === fieldLen)
          return this.fromCompressedHex(bytes2);
        if (len === compressedLen && (header === 2 || header === 3)) {
          return this.fromCompressedHex(bytes2);
        }
        if (len === uncompressedLen && header === 4)
          return this.fromUncompressedHex(bytes2);
        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
      }
      static fromPrivateKey(privateKey) {
        return Point2.BASE.multiply(normalizePrivateKey(privateKey));
      }
      static fromSignature(msgHash, signature2, recovery) {
        const { r, s } = normalizeSignature(signature2);
        if (![0, 1, 2, 3].includes(recovery))
          throw new Error("Cannot recover: invalid recovery bit");
        const h = truncateHash(ensureBytes2(msgHash));
        const { n } = CURVE2;
        const radj = recovery === 2 || recovery === 3 ? r + n : r;
        const rinv = invert2(radj, n);
        const u1 = mod2(-h * rinv, n);
        const u2 = mod2(s * rinv, n);
        const prefix = recovery & 1 ? "03" : "02";
        const R = Point2.fromHex(prefix + numTo32bStr(radj));
        const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
          throw new Error("Cannot recover signature: point at infinify");
        Q.assertValidity();
        return Q;
      }
      toRawBytes(isCompressed = false) {
        return hexToBytes2(this.toHex(isCompressed));
      }
      toHex(isCompressed = false) {
        const x = numTo32bStr(this.x);
        if (isCompressed) {
          const prefix = this.hasEvenY() ? "02" : "03";
          return `${prefix}${x}`;
        } else {
          return `04${x}${numTo32bStr(this.y)}`;
        }
      }
      toHexX() {
        return this.toHex(true).slice(2);
      }
      toRawX() {
        return this.toRawBytes(true).slice(1);
      }
      assertValidity() {
        const msg = "Point is not on elliptic curve";
        const { x, y } = this;
        if (!isValidFieldElement(x) || !isValidFieldElement(y))
          throw new Error(msg);
        const left = mod2(y * y);
        const right = weierstrass(x);
        if (mod2(left - right) !== _0n3)
          throw new Error(msg);
      }
      equals(other) {
        return this.x === other.x && this.y === other.y;
      }
      negate() {
        return new Point2(this.x, mod2(-this.y));
      }
      double() {
        return JacobianPoint.fromAffine(this).double().toAffine();
      }
      add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const P = JacobianPoint.fromAffine(this);
        const aP = a === _0n3 || a === _1n3 || this !== Point2.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
        const sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
      }
    };
    Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy);
    Point2.ZERO = new Point2(_0n3, _0n3);
    Signature2 = class {
      constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
      }
      static fromCompact(hex2) {
        const arr = hex2 instanceof Uint8Array;
        const name = "Signature.fromCompact";
        if (typeof hex2 !== "string" && !arr)
          throw new TypeError(`${name}: Expected string or Uint8Array`);
        const str2 = arr ? bytesToHex2(hex2) : hex2;
        if (str2.length !== 128)
          throw new Error(`${name}: Expected 64-byte hex`);
        return new Signature2(hexToNumber(str2.slice(0, 64)), hexToNumber(str2.slice(64, 128)));
      }
      static fromDER(hex2) {
        const arr = hex2 instanceof Uint8Array;
        if (typeof hex2 !== "string" && !arr)
          throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
        const { r, s } = parseDERSignature(arr ? hex2 : hexToBytes2(hex2));
        return new Signature2(r, s);
      }
      static fromHex(hex2) {
        return this.fromDER(hex2);
      }
      assertValidity() {
        const { r, s } = this;
        if (!isWithinCurveOrder(r))
          throw new Error("Invalid Signature: r must be 0 < r < n");
        if (!isWithinCurveOrder(s))
          throw new Error("Invalid Signature: s must be 0 < s < n");
      }
      hasHighS() {
        const HALF = CURVE2.n >> _1n3;
        return this.s > HALF;
      }
      normalizeS() {
        return this.hasHighS() ? new Signature2(this.r, mod2(-this.s, CURVE2.n)) : this;
      }
      toDERRawBytes() {
        return hexToBytes2(this.toDERHex());
      }
      toDERHex() {
        const sHex = sliceDER(numberToHexUnpadded(this.s));
        const rHex = sliceDER(numberToHexUnpadded(this.r));
        const sHexL = sHex.length / 2;
        const rHexL = rHex.length / 2;
        const sLen = numberToHexUnpadded(sHexL);
        const rLen = numberToHexUnpadded(rHexL);
        const length = numberToHexUnpadded(rHexL + sHexL + 4);
        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
      }
      toRawBytes() {
        return this.toDERRawBytes();
      }
      toHex() {
        return this.toDERHex();
      }
      toCompactRawBytes() {
        return hexToBytes2(this.toCompactHex());
      }
      toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
      }
    };
    hexes3 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    POW_2_2562 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    HmacDrbg = class {
      constructor(hashLen2, qByteLen) {
        this.hashLen = hashLen2;
        this.qByteLen = qByteLen;
        if (typeof hashLen2 !== "number" || hashLen2 < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        this.v = new Uint8Array(hashLen2).fill(1);
        this.k = new Uint8Array(hashLen2).fill(0);
        this.counter = 0;
      }
      hmac(...values) {
        return utils2.hmacSha256(this.k, ...values);
      }
      hmacSync(...values) {
        return _hmacSha256Sync(this.k, ...values);
      }
      checkSync() {
        if (typeof _hmacSha256Sync !== "function")
          throw new ShaError("hmacSha256Sync needs to be set");
      }
      incr() {
        if (this.counter >= 1e3)
          throw new Error("Tried 1,000 k values for sign(), all were invalid");
        this.counter += 1;
      }
      async reseed(seed2 = new Uint8Array()) {
        this.k = await this.hmac(this.v, Uint8Array.from([0]), seed2);
        this.v = await this.hmac(this.v);
        if (seed2.length === 0)
          return;
        this.k = await this.hmac(this.v, Uint8Array.from([1]), seed2);
        this.v = await this.hmac(this.v);
      }
      reseedSync(seed2 = new Uint8Array()) {
        this.checkSync();
        this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed2);
        this.v = this.hmacSync(this.v);
        if (seed2.length === 0)
          return;
        this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed2);
        this.v = this.hmacSync(this.v);
      }
      async generate() {
        this.incr();
        let len = 0;
        const out = [];
        while (len < this.qByteLen) {
          this.v = await this.hmac(this.v);
          const sl = this.v.slice();
          out.push(sl);
          len += this.v.length;
        }
        return concatBytes2(...out);
      }
      generateSync() {
        this.checkSync();
        this.incr();
        let len = 0;
        const out = [];
        while (len < this.qByteLen) {
          this.v = this.hmacSync(this.v);
          const sl = this.v.slice();
          out.push(sl);
          len += this.v.length;
        }
        return concatBytes2(...out);
      }
    };
    Point2.BASE._setWindowSize(8);
    crypto4 = {
      node: nodeCrypto2,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
    TAGGED_HASH_PREFIXES = {};
    utils2 = {
      bytesToHex: bytesToHex2,
      hexToBytes: hexToBytes2,
      concatBytes: concatBytes2,
      mod: mod2,
      invert: invert2,
      isValidPrivateKey(privateKey) {
        try {
          normalizePrivateKey(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      _bigintTo32Bytes: numTo32b,
      _normalizePrivateKey: normalizePrivateKey,
      hashToPrivateKey: (hash3) => {
        hash3 = ensureBytes2(hash3);
        const minLen = groupLen + 8;
        if (hash3.length < minLen || hash3.length > 1024) {
          throw new Error(`Expected valid bytes of private key as per FIPS 186`);
        }
        const num = mod2(bytesToNumber(hash3), CURVE2.n - _1n3) + _1n3;
        return numTo32b(num);
      },
      randomBytes: (bytesLength = 32) => {
        if (crypto4.web) {
          return crypto4.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto4.node) {
          const { randomBytes } = crypto4.node;
          return Uint8Array.from(randomBytes(bytesLength));
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      },
      randomPrivateKey: () => utils2.hashToPrivateKey(utils2.randomBytes(groupLen + 8)),
      precompute(windowSize = 8, point = Point2.BASE) {
        const cached = point === Point2.BASE ? point : new Point2(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_3n);
        return cached;
      },
      sha256: async (...messages2) => {
        if (crypto4.web) {
          const buffer = await crypto4.web.subtle.digest("SHA-256", concatBytes2(...messages2));
          return new Uint8Array(buffer);
        } else if (crypto4.node) {
          const { createHash } = crypto4.node;
          const hash3 = createHash("sha256");
          messages2.forEach((m) => hash3.update(m));
          return Uint8Array.from(hash3.digest());
        } else {
          throw new Error("The environment doesn't have sha256 function");
        }
      },
      hmacSha256: async (key, ...messages2) => {
        if (crypto4.web) {
          const ckey = await crypto4.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
          const message = concatBytes2(...messages2);
          const buffer = await crypto4.web.subtle.sign("HMAC", ckey, message);
          return new Uint8Array(buffer);
        } else if (crypto4.node) {
          const { createHmac } = crypto4.node;
          const hash3 = createHmac("sha256", key);
          messages2.forEach((m) => hash3.update(m));
          return Uint8Array.from(hash3.digest());
        } else {
          throw new Error("The environment doesn't have hmac-sha256 function");
        }
      },
      sha256Sync: void 0,
      hmacSha256Sync: void 0,
      taggedHash: async (tag, ...messages2) => {
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === void 0) {
          const tagH = await utils2.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
          tagP = concatBytes2(tagH, tagH);
          TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return utils2.sha256(tagP, ...messages2);
      },
      taggedHashSync: (tag, ...messages2) => {
        if (typeof _sha256Sync !== "function")
          throw new ShaError("sha256Sync is undefined, you need to set it");
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === void 0) {
          const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
          tagP = concatBytes2(tagH, tagH);
          TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return _sha256Sync(tagP, ...messages2);
      },
      _JacobianPoint: JacobianPoint
    };
    Object.defineProperties(utils2, {
      sha256Sync: {
        configurable: false,
        get() {
          return _sha256Sync;
        },
        set(val) {
          if (!_sha256Sync)
            _sha256Sync = val;
        }
      },
      hmacSha256Sync: {
        configurable: false,
        get() {
          return _hmacSha256Sync;
        },
        set(val) {
          if (!_hmacSha256Sync)
            _hmacSha256Sync = val;
        }
      }
    });
  }
});

// node_modules/@solana/web3.js/lib/index.browser.esm.js
var index_browser_esm_exports = {};
__export(index_browser_esm_exports, {
  Account: () => Account,
  AddressLookupTableAccount: () => AddressLookupTableAccount,
  AddressLookupTableInstruction: () => AddressLookupTableInstruction,
  AddressLookupTableProgram: () => AddressLookupTableProgram,
  Authorized: () => Authorized,
  BLOCKHASH_CACHE_TIMEOUT_MS: () => BLOCKHASH_CACHE_TIMEOUT_MS,
  BPF_LOADER_DEPRECATED_PROGRAM_ID: () => BPF_LOADER_DEPRECATED_PROGRAM_ID,
  BPF_LOADER_PROGRAM_ID: () => BPF_LOADER_PROGRAM_ID,
  BpfLoader: () => BpfLoader,
  COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,
  ComputeBudgetInstruction: () => ComputeBudgetInstruction,
  ComputeBudgetProgram: () => ComputeBudgetProgram,
  Connection: () => Connection,
  Ed25519Program: () => Ed25519Program,
  Enum: () => Enum,
  EpochSchedule: () => EpochSchedule,
  FeeCalculatorLayout: () => FeeCalculatorLayout,
  Keypair: () => Keypair,
  LAMPORTS_PER_SOL: () => LAMPORTS_PER_SOL,
  LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => LOOKUP_TABLE_INSTRUCTION_LAYOUTS,
  Loader: () => Loader,
  Lockup: () => Lockup,
  MAX_SEED_LENGTH: () => MAX_SEED_LENGTH,
  Message: () => Message,
  MessageAccountKeys: () => MessageAccountKeys,
  MessageV0: () => MessageV0,
  NONCE_ACCOUNT_LENGTH: () => NONCE_ACCOUNT_LENGTH,
  NonceAccount: () => NonceAccount,
  PACKET_DATA_SIZE: () => PACKET_DATA_SIZE,
  PUBLIC_KEY_LENGTH: () => PUBLIC_KEY_LENGTH,
  PublicKey: () => PublicKey,
  SIGNATURE_LENGTH_IN_BYTES: () => SIGNATURE_LENGTH_IN_BYTES,
  SOLANA_SCHEMA: () => SOLANA_SCHEMA,
  STAKE_CONFIG_ID: () => STAKE_CONFIG_ID,
  STAKE_INSTRUCTION_LAYOUTS: () => STAKE_INSTRUCTION_LAYOUTS,
  SYSTEM_INSTRUCTION_LAYOUTS: () => SYSTEM_INSTRUCTION_LAYOUTS,
  SYSVAR_CLOCK_PUBKEY: () => SYSVAR_CLOCK_PUBKEY,
  SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => SYSVAR_EPOCH_SCHEDULE_PUBKEY,
  SYSVAR_INSTRUCTIONS_PUBKEY: () => SYSVAR_INSTRUCTIONS_PUBKEY,
  SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
  SYSVAR_RENT_PUBKEY: () => SYSVAR_RENT_PUBKEY,
  SYSVAR_REWARDS_PUBKEY: () => SYSVAR_REWARDS_PUBKEY,
  SYSVAR_SLOT_HASHES_PUBKEY: () => SYSVAR_SLOT_HASHES_PUBKEY,
  SYSVAR_SLOT_HISTORY_PUBKEY: () => SYSVAR_SLOT_HISTORY_PUBKEY,
  SYSVAR_STAKE_HISTORY_PUBKEY: () => SYSVAR_STAKE_HISTORY_PUBKEY,
  Secp256k1Program: () => Secp256k1Program,
  SendTransactionError: () => SendTransactionError,
  SolanaJSONRPCError: () => SolanaJSONRPCError,
  SolanaJSONRPCErrorCode: () => SolanaJSONRPCErrorCode,
  StakeAuthorizationLayout: () => StakeAuthorizationLayout,
  StakeInstruction: () => StakeInstruction,
  StakeProgram: () => StakeProgram,
  Struct: () => Struct2,
  SystemInstruction: () => SystemInstruction,
  SystemProgram: () => SystemProgram,
  Transaction: () => Transaction,
  TransactionExpiredBlockheightExceededError: () => TransactionExpiredBlockheightExceededError,
  TransactionExpiredNonceInvalidError: () => TransactionExpiredNonceInvalidError,
  TransactionExpiredTimeoutError: () => TransactionExpiredTimeoutError,
  TransactionInstruction: () => TransactionInstruction,
  TransactionMessage: () => TransactionMessage,
  TransactionStatus: () => TransactionStatus,
  VALIDATOR_INFO_KEY: () => VALIDATOR_INFO_KEY,
  VERSION_PREFIX_MASK: () => VERSION_PREFIX_MASK,
  VOTE_PROGRAM_ID: () => VOTE_PROGRAM_ID,
  ValidatorInfo: () => ValidatorInfo,
  VersionedMessage: () => VersionedMessage,
  VersionedTransaction: () => VersionedTransaction,
  VoteAccount: () => VoteAccount,
  VoteAuthorizationLayout: () => VoteAuthorizationLayout,
  VoteInit: () => VoteInit,
  VoteInstruction: () => VoteInstruction,
  VoteProgram: () => VoteProgram,
  clusterApiUrl: () => clusterApiUrl,
  sendAndConfirmRawTransaction: () => sendAndConfirmRawTransaction,
  sendAndConfirmTransaction: () => sendAndConfirmTransaction
});
function isOnCurve(publicKey4) {
  try {
    Point.fromHex(
      publicKey4,
      true
      /* strict */
    );
    return true;
  } catch {
    return false;
  }
}
function isPublicKeyData(value) {
  return value._bn !== void 0;
}
function getAlloc(type3, fields) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc({
        layout: item
      }, fields[item.property]);
    }
    return 0;
  };
  let alloc = 0;
  type3.layout.fields.forEach((item) => {
    alloc += getItemAlloc(item);
  });
  return alloc;
}
function decodeLength(bytes2) {
  let len = 0;
  let size = 0;
  for (; ; ) {
    let elem = bytes2.shift();
    len |= (elem & 127) << size * 7;
    size += 1;
    if ((elem & 128) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength(bytes2, len) {
  let rem_len = len;
  for (; ; ) {
    let elem = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes2.push(elem);
      break;
    } else {
      elem |= 128;
      bytes2.push(elem);
    }
  }
}
function assert3(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
async function sendAndConfirmTransaction(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature2 = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      signature: signature2,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature: signature2
    }, options && options.commitment)).value;
  } else {
    if ((options == null ? void 0 : options.abortSignal) != null) {
      console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
    }
    status = (await connection.confirmTransaction(signature2, options && options.commitment)).value;
  }
  if (status.err) {
    throw new Error(`Transaction ${signature2} failed (${JSON.stringify(status)})`);
  }
  return signature2;
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function encodeData(type3, fields) {
  const allocLength = type3.layout.span >= 0 ? type3.layout.span : getAlloc(type3, fields);
  const data = import_buffer.Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type3.index
  }, fields);
  type3.layout.encode(layoutFields, data);
  return data;
}
function decodeData$1(type3, buffer) {
  let data;
  try {
    data = type3.layout.decode(buffer);
  } catch (err2) {
    throw new Error("invalid instruction; " + err2);
  }
  if (data.instruction !== type3.index) {
    throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type3.index}`);
  }
  return data;
}
function stringify2(val, isArrayProp) {
  var i, max, str2, keys, key, propVal, toStr;
  if (val === true) {
    return "true";
  }
  if (val === false) {
    return "false";
  }
  switch (typeof val) {
    case "object":
      if (val === null) {
        return null;
      } else if (val.toJSON && typeof val.toJSON === "function") {
        return stringify2(val.toJSON(), isArrayProp);
      } else {
        toStr = objToString.call(val);
        if (toStr === "[object Array]") {
          str2 = "[";
          max = val.length - 1;
          for (i = 0; i < max; i++) {
            str2 += stringify2(val[i], true) + ",";
          }
          if (max > -1) {
            str2 += stringify2(val[i], true);
          }
          return str2 + "]";
        } else if (toStr === "[object Object]") {
          keys = objKeys(val).sort();
          max = keys.length;
          str2 = "";
          i = 0;
          while (i < max) {
            key = keys[i];
            propVal = stringify2(val[key], false);
            if (propVal !== void 0) {
              if (str2) {
                str2 += ",";
              }
              str2 += JSON.stringify(key) + ":" + propVal;
            }
            i++;
          }
          return "{" + str2 + "}";
        } else {
          return JSON.stringify(val);
        }
      }
    case "function":
    case "undefined":
      return isArrayProp ? null : void 0;
    case "string":
      return JSON.stringify(val);
    default:
      return isFinite(val) ? val : null;
  }
}
function trailingZeros(n) {
  let trailingZeros2 = 0;
  while (n > 1) {
    n /= 2;
    trailingZeros2++;
  }
  return trailingZeros2;
}
function nextPowerOfTwo(n) {
  if (n === 0)
    return 1;
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n |= n >> 32;
  return n + 1;
}
function decodeData(type3, data) {
  let decoded;
  try {
    decoded = type3.layout.decode(data);
  } catch (err2) {
    throw new Error("invalid instruction; " + err2);
  }
  if (decoded.typeIndex !== type3.index) {
    throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type3.index}`);
  }
  return decoded;
}
function makeWebsocketUrl(endpoint2) {
  const matches = endpoint2.match(URL_RE);
  if (matches == null) {
    throw TypeError(`Failed to validate endpoint URL \`${endpoint2}\``);
  }
  const [
    _,
    // eslint-disable-line @typescript-eslint/no-unused-vars
    hostish,
    portWithColon,
    rest
  ] = matches;
  const protocol = endpoint2.startsWith("https:") ? "wss:" : "ws:";
  const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
  const websocketPort = (
    // Only shift the port by +1 as a convention for ws(s) only if given endpoint
    // is explictly specifying the endpoint port (HTTP-based RPC), assuming
    // we're directly trying to connect to solana-validator's ws listening port.
    // When the endpoint omits the port, we're connecting to the protocol
    // default ports: http(80) or https(443) and it's assumed we're behind a reverse
    // proxy which manages WebSocket upgrade and backend port redirection.
    startPort == null ? "" : `:${startPort + 1}`
  );
  return `${protocol}//${hostish}${websocketPort}${rest}`;
}
function assertEndpointUrl(putativeUrl) {
  if (/^https?:/.test(putativeUrl) === false) {
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  }
  return putativeUrl;
}
function extractCommitmentFromConfig(commitmentOrConfig) {
  let commitment;
  let config;
  if (typeof commitmentOrConfig === "string") {
    commitment = commitmentOrConfig;
  } else if (commitmentOrConfig) {
    const {
      commitment: specifiedCommitment,
      ...specifiedConfig
    } = commitmentOrConfig;
    commitment = specifiedCommitment;
    config = specifiedConfig;
  }
  return {
    commitment,
    config
  };
}
function createRpcResult(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
function jsonRpcResult(schema) {
  return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create(value.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext(value) {
  return jsonRpcResult(type({
    context: type({
      slot: number2()
    }),
    value
  }));
}
function notificationResultAndContext(value) {
  return type({
    context: type({
      slot: number2()
    }),
    value
  });
}
function versionedMessageFromResponse(version2, response) {
  if (version2 === 0) {
    return new MessageV0({
      header: response.header,
      staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey(accountKey)),
      recentBlockhash: response.recentBlockhash,
      compiledInstructions: response.instructions.map((ix) => ({
        programIdIndex: ix.programIdIndex,
        accountKeyIndexes: ix.accounts,
        data: import_bs58.default.decode(ix.data)
      })),
      addressTableLookups: response.addressTableLookups
    });
  } else {
    return new Message(response);
  }
}
function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
  const fetch2 = customFetch ? customFetch : fetchImpl;
  let agent;
  {
    if (httpAgent != null) {
      console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
    }
  }
  let fetchWithMiddleware;
  if (fetchMiddleware) {
    fetchWithMiddleware = async (info, init) => {
      const modifiedFetchArgs = await new Promise((resolve, reject) => {
        try {
          fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
        } catch (error) {
          reject(error);
        }
      });
      return await fetch2(...modifiedFetchArgs);
    };
  }
  const clientBrowser = new import_browser.default(async (request, callback) => {
    const options = {
      method: "POST",
      body: request,
      agent,
      headers: Object.assign({
        "Content-Type": "application/json"
      }, httpHeaders || {}, COMMON_HTTP_HEADERS)
    };
    try {
      let too_many_requests_retries = 5;
      let res;
      let waitTime = 500;
      for (; ; ) {
        if (fetchWithMiddleware) {
          res = await fetchWithMiddleware(url, options);
        } else {
          res = await fetch2(url, options);
        }
        if (res.status !== 429) {
          break;
        }
        if (disableRetryOnRateLimit === true) {
          break;
        }
        too_many_requests_retries -= 1;
        if (too_many_requests_retries === 0) {
          break;
        }
        console.log(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
        await sleep(waitTime);
        waitTime *= 2;
      }
      const text = await res.text();
      if (res.ok) {
        callback(null, text);
      } else {
        callback(new Error(`${res.status} ${res.statusText}: ${text}`));
      }
    } catch (err2) {
      if (err2 instanceof Error)
        callback(err2);
    }
  }, {});
  return clientBrowser;
}
function createRpcRequest(client) {
  return (method2, args) => {
    return new Promise((resolve, reject) => {
      client.request(method2, args, (err2, response) => {
        if (err2) {
          reject(err2);
          return;
        }
        resolve(response);
      });
    });
  };
}
function createRpcBatchRequest(client) {
  return (requests) => {
    return new Promise((resolve, reject) => {
      if (requests.length === 0)
        resolve([]);
      const batch = requests.map((params) => {
        return client.request(params.methodName, params.args);
      });
      client.request(batch, (err2, response) => {
        if (err2) {
          reject(err2);
          return;
        }
        resolve(response);
      });
    });
  };
}
function parseAuthorizedVoter({
  authorizedVoter,
  epoch
}) {
  return {
    epoch,
    authorizedVoter: new PublicKey(authorizedVoter)
  };
}
function parsePriorVoters({
  authorizedPubkey,
  epochOfLastAuthorizedSwitch,
  targetEpoch
}) {
  return {
    authorizedPubkey: new PublicKey(authorizedPubkey),
    epochOfLastAuthorizedSwitch,
    targetEpoch
  };
}
function getPriorVoters({
  buf,
  idx,
  isEmpty
}) {
  if (isEmpty) {
    return [];
  }
  return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx).map(parsePriorVoters)];
}
function clusterApiUrl(cluster, tls) {
  const key = tls === false ? "http" : "https";
  if (!cluster) {
    return endpoint[key]["devnet"];
  }
  const url = endpoint[key][cluster];
  if (!url) {
    throw new Error(`Unknown ${key} cluster: ${cluster}`);
  }
  return url;
}
async function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
  let confirmationStrategy;
  let options;
  if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "lastValidBlockHeight")) {
    confirmationStrategy = confirmationStrategyOrConfirmOptions;
    options = maybeConfirmOptions;
  } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "nonceValue")) {
    confirmationStrategy = confirmationStrategyOrConfirmOptions;
    options = maybeConfirmOptions;
  } else {
    options = confirmationStrategyOrConfirmOptions;
  }
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    minContextSlot: options.minContextSlot
  };
  const signature2 = await connection.sendRawTransaction(rawTransaction, sendOptions);
  const commitment = options && options.commitment;
  const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature2, commitment);
  const status = (await confirmationPromise).value;
  if (status.err) {
    throw new Error(`Raw transaction ${signature2} failed (${JSON.stringify(status)})`);
  }
  return signature2;
}
var import_buffer, import_bn, import_bs58, import_borsh, BufferLayout, import_buffer_layout, import_bigint_buffer, import_browser, import_client, import_websocket, generatePrivateKey, generateKeypair, getPublicKey2, sign, verify, toBuffer, Struct2, Enum, SOLANA_SCHEMA, _Symbol$toStringTag, MAX_SEED_LENGTH, PUBLIC_KEY_LENGTH, uniquePublicKeyCounter, PublicKey, Account, BPF_LOADER_DEPRECATED_PROGRAM_ID, PACKET_DATA_SIZE, VERSION_PREFIX_MASK, SIGNATURE_LENGTH_IN_BYTES, TransactionExpiredBlockheightExceededError, TransactionExpiredTimeoutError, TransactionExpiredNonceInvalidError, MessageAccountKeys, publicKey, signature, rustString, authorized, lockup, voteInit, voteAuthorizeWithSeedArgs, CompiledKeys, Message, MessageV0, VersionedMessage, TransactionStatus, DEFAULT_SIGNATURE, TransactionInstruction, Transaction, TransactionMessage, VersionedTransaction, SYSVAR_CLOCK_PUBKEY, SYSVAR_EPOCH_SCHEDULE_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY, SYSVAR_RECENT_BLOCKHASHES_PUBKEY, SYSVAR_RENT_PUBKEY, SYSVAR_REWARDS_PUBKEY, SYSVAR_SLOT_HASHES_PUBKEY, SYSVAR_SLOT_HISTORY_PUBKEY, SYSVAR_STAKE_HISTORY_PUBKEY, FeeCalculatorLayout, NonceAccountLayout, NONCE_ACCOUNT_LENGTH, NonceAccount, encodeDecode, bigInt, u642, SystemInstruction, SYSTEM_INSTRUCTION_LAYOUTS, SystemProgram, CHUNK_SIZE, Loader, BPF_LOADER_PROGRAM_ID, BpfLoader, objToString, objKeys, fastStableStringify, fastStableStringify$1, MINIMUM_SLOT_PER_EPOCH, EpochSchedule, SendTransactionError, SolanaJSONRPCErrorCode, SolanaJSONRPCError, fetchImpl, RpcWebSocketClient, NUM_TICKS_PER_SECOND, DEFAULT_TICKS_PER_SLOT, NUM_SLOTS_PER_SECOND, MS_PER_SLOT, LOOKUP_TABLE_META_SIZE, AddressLookupTableAccount, LookupTableMetaLayout, URL_RE, PublicKeyFromString, RawAccountDataResult, BufferFromRawAccountData, BLOCKHASH_CACHE_TIMEOUT_MS, UnknownRpcResult, GetInflationGovernorResult, GetInflationRewardResult, GetRecentPrioritizationFeesResult, GetInflationRateResult, GetEpochInfoResult, GetEpochScheduleResult, GetLeaderScheduleResult, TransactionErrorResult, SignatureStatusResult, SignatureReceivedResult, VersionResult, SimulatedTransactionResponseStruct, BlockProductionResponseStruct, GetInflationGovernorRpcResult, GetInflationRateRpcResult, GetRecentPrioritizationFeesRpcResult, GetEpochInfoRpcResult, GetEpochScheduleRpcResult, GetLeaderScheduleRpcResult, SlotRpcResult, GetSupplyRpcResult, TokenAmountResult, GetTokenLargestAccountsResult, GetTokenAccountsByOwner, ParsedAccountDataResult, GetParsedTokenAccountsByOwner, GetLargestAccountsRpcResult, AccountInfoResult, KeyedAccountInfoResult, ParsedOrRawAccountData, ParsedAccountInfoResult, KeyedParsedAccountInfoResult, StakeActivationResult, GetConfirmedSignaturesForAddress2RpcResult, GetSignaturesForAddressRpcResult, AccountNotificationResult, ProgramAccountInfoResult, ProgramAccountNotificationResult, SlotInfoResult, SlotNotificationResult, SlotUpdateResult, SlotUpdateNotificationResult, SignatureNotificationResult, RootNotificationResult, ContactInfoResult, VoteAccountInfoResult, GetVoteAccounts, ConfirmationStatus, SignatureStatusResponse, GetSignatureStatusesRpcResult, GetMinimumBalanceForRentExemptionRpcResult, AddressTableLookupStruct, ConfirmedTransactionResult, AnnotatedAccountKey, ConfirmedTransactionAccountsModeResult, ParsedInstructionResult, RawInstructionResult, InstructionResult, UnknownInstructionResult, ParsedOrRawInstruction, ParsedConfirmedTransactionResult, TokenBalanceResult, LoadedAddressesResult, ConfirmedTransactionMetaResult, ParsedConfirmedTransactionMetaResult, TransactionVersionStruct, RewardsResult, GetBlockRpcResult, GetNoneModeBlockRpcResult, GetAccountsModeBlockRpcResult, GetParsedBlockRpcResult, GetParsedAccountsModeBlockRpcResult, GetParsedNoneModeBlockRpcResult, GetConfirmedBlockRpcResult, GetBlockSignaturesRpcResult, GetTransactionRpcResult, GetParsedTransactionRpcResult, GetRecentBlockhashAndContextRpcResult, GetLatestBlockhashRpcResult, PerfSampleResult, GetRecentPerformanceSamplesRpcResult, GetFeeCalculatorRpcResult, RequestAirdropRpcResult, SendTransactionRpcResult, LogsResult, LogsNotificationResult, COMMON_HTTP_HEADERS, Connection, Keypair, LOOKUP_TABLE_INSTRUCTION_LAYOUTS, AddressLookupTableInstruction, AddressLookupTableProgram, ComputeBudgetInstruction, COMPUTE_BUDGET_INSTRUCTION_LAYOUTS, ComputeBudgetProgram, PRIVATE_KEY_BYTES$1, PUBLIC_KEY_BYTES$1, SIGNATURE_BYTES, ED25519_INSTRUCTION_LAYOUT, Ed25519Program, ecdsaSign, publicKeyCreate, PRIVATE_KEY_BYTES, ETHEREUM_ADDRESS_BYTES, PUBLIC_KEY_BYTES, SIGNATURE_OFFSETS_SERIALIZED_SIZE, SECP256K1_INSTRUCTION_LAYOUT, Secp256k1Program, STAKE_CONFIG_ID, Authorized, Lockup, StakeInstruction, STAKE_INSTRUCTION_LAYOUTS, StakeAuthorizationLayout, StakeProgram, VoteInit, VoteInstruction, VOTE_INSTRUCTION_LAYOUTS, VoteAuthorizationLayout, VoteProgram, VALIDATOR_INFO_KEY, InfoString, ValidatorInfo, VOTE_PROGRAM_ID, VoteAccountLayout, VoteAccount, endpoint, LAMPORTS_PER_SOL;
var init_index_browser_esm = __esm({
  "node_modules/@solana/web3.js/lib/index.browser.esm.js"() {
    import_buffer = __toESM(require_buffer());
    init_sha512();
    init_esm();
    import_bn = __toESM(require_bn());
    import_bs58 = __toESM(require_bs58());
    init_sha256();
    import_borsh = __toESM(require_lib());
    BufferLayout = __toESM(require_Layout());
    import_buffer_layout = __toESM(require_Layout());
    import_bigint_buffer = __toESM(require_browser());
    init_index_es();
    import_browser = __toESM(require_browser2());
    import_client = __toESM(require_client());
    import_websocket = __toESM(require_websocket_browser());
    init_sha3();
    init_hmac();
    init_esm2();
    utils.sha512Sync = (...m) => sha512(utils.concatBytes(...m));
    generatePrivateKey = utils.randomPrivateKey;
    generateKeypair = () => {
      const privateScalar = utils.randomPrivateKey();
      const publicKey4 = getPublicKey2(privateScalar);
      const secretKey = new Uint8Array(64);
      secretKey.set(privateScalar);
      secretKey.set(publicKey4, 32);
      return {
        publicKey: publicKey4,
        secretKey
      };
    };
    getPublicKey2 = sync.getPublicKey;
    sign = (message, secretKey) => sync.sign(message, secretKey.slice(0, 32));
    verify = sync.verify;
    toBuffer = (arr) => {
      if (import_buffer.Buffer.isBuffer(arr)) {
        return arr;
      } else if (arr instanceof Uint8Array) {
        return import_buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
      } else {
        return import_buffer.Buffer.from(arr);
      }
    };
    Struct2 = class {
      constructor(properties) {
        Object.assign(this, properties);
      }
      encode() {
        return import_buffer.Buffer.from((0, import_borsh.serialize)(SOLANA_SCHEMA, this));
      }
      static decode(data) {
        return (0, import_borsh.deserialize)(SOLANA_SCHEMA, this, data);
      }
      static decodeUnchecked(data) {
        return (0, import_borsh.deserializeUnchecked)(SOLANA_SCHEMA, this, data);
      }
    };
    Enum = class extends Struct2 {
      constructor(properties) {
        super(properties);
        this.enum = "";
        if (Object.keys(properties).length !== 1) {
          throw new Error("Enum can only take single value");
        }
        Object.keys(properties).map((key) => {
          this.enum = key;
        });
      }
    };
    SOLANA_SCHEMA = /* @__PURE__ */ new Map();
    MAX_SEED_LENGTH = 32;
    PUBLIC_KEY_LENGTH = 32;
    uniquePublicKeyCounter = 1;
    _Symbol$toStringTag = Symbol.toStringTag;
    PublicKey = class extends Struct2 {
      /** @internal */
      /**
       * Create a new PublicKey object
       * @param value ed25519 public key as buffer or base-58 encoded string
       */
      constructor(value) {
        super({});
        this._bn = void 0;
        if (isPublicKeyData(value)) {
          this._bn = value._bn;
        } else {
          if (typeof value === "string") {
            const decoded = import_bs58.default.decode(value);
            if (decoded.length != PUBLIC_KEY_LENGTH) {
              throw new Error(`Invalid public key input`);
            }
            this._bn = new import_bn.default(decoded);
          } else {
            this._bn = new import_bn.default(value);
          }
          if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
            throw new Error(`Invalid public key input`);
          }
        }
      }
      /**
       * Returns a unique PublicKey for tests and benchmarks using a counter
       */
      static unique() {
        const key = new PublicKey(uniquePublicKeyCounter);
        uniquePublicKeyCounter += 1;
        return new PublicKey(key.toBuffer());
      }
      /**
       * Default public key value. The base58-encoded string representation is all ones (as seen below)
       * The underlying BN number is 32 bytes that are all zeros
       */
      /**
       * Checks if two publicKeys are equal
       */
      equals(publicKey4) {
        return this._bn.eq(publicKey4._bn);
      }
      /**
       * Return the base-58 representation of the public key
       */
      toBase58() {
        return import_bs58.default.encode(this.toBytes());
      }
      toJSON() {
        return this.toBase58();
      }
      /**
       * Return the byte array representation of the public key in big endian
       */
      toBytes() {
        const buf = this.toBuffer();
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      /**
       * Return the Buffer representation of the public key in big endian
       */
      toBuffer() {
        const b = this._bn.toArrayLike(import_buffer.Buffer);
        if (b.length === PUBLIC_KEY_LENGTH) {
          return b;
        }
        const zeroPad = import_buffer.Buffer.alloc(32);
        b.copy(zeroPad, 32 - b.length);
        return zeroPad;
      }
      get [_Symbol$toStringTag]() {
        return `PublicKey(${this.toString()})`;
      }
      /**
       * Return the base-58 representation of the public key
       */
      toString() {
        return this.toBase58();
      }
      /**
       * Derive a public key from another key, a seed, and a program ID.
       * The program ID will also serve as the owner of the public key, giving
       * it permission to write data to the account.
       */
      /* eslint-disable require-await */
      static async createWithSeed(fromPublicKey, seed2, programId) {
        const buffer = import_buffer.Buffer.concat([fromPublicKey.toBuffer(), import_buffer.Buffer.from(seed2), programId.toBuffer()]);
        const publicKeyBytes = sha256(buffer);
        return new PublicKey(publicKeyBytes);
      }
      /**
       * Derive a program address from seeds and a program ID.
       */
      /* eslint-disable require-await */
      static createProgramAddressSync(seeds, programId) {
        let buffer = import_buffer.Buffer.alloc(0);
        seeds.forEach(function(seed2) {
          if (seed2.length > MAX_SEED_LENGTH) {
            throw new TypeError(`Max seed length exceeded`);
          }
          buffer = import_buffer.Buffer.concat([buffer, toBuffer(seed2)]);
        });
        buffer = import_buffer.Buffer.concat([buffer, programId.toBuffer(), import_buffer.Buffer.from("ProgramDerivedAddress")]);
        const publicKeyBytes = sha256(buffer);
        if (isOnCurve(publicKeyBytes)) {
          throw new Error(`Invalid seeds, address must fall off the curve`);
        }
        return new PublicKey(publicKeyBytes);
      }
      /**
       * Async version of createProgramAddressSync
       * For backwards compatibility
       *
       * @deprecated Use {@link createProgramAddressSync} instead
       */
      /* eslint-disable require-await */
      static async createProgramAddress(seeds, programId) {
        return this.createProgramAddressSync(seeds, programId);
      }
      /**
       * Find a valid program address
       *
       * Valid program addresses must fall off the ed25519 curve.  This function
       * iterates a nonce until it finds one that when combined with the seeds
       * results in a valid program address.
       */
      static findProgramAddressSync(seeds, programId) {
        let nonce = 255;
        let address;
        while (nonce != 0) {
          try {
            const seedsWithNonce = seeds.concat(import_buffer.Buffer.from([nonce]));
            address = this.createProgramAddressSync(seedsWithNonce, programId);
          } catch (err2) {
            if (err2 instanceof TypeError) {
              throw err2;
            }
            nonce--;
            continue;
          }
          return [address, nonce];
        }
        throw new Error(`Unable to find a viable program address nonce`);
      }
      /**
       * Async version of findProgramAddressSync
       * For backwards compatibility
       *
       * @deprecated Use {@link findProgramAddressSync} instead
       */
      static async findProgramAddress(seeds, programId) {
        return this.findProgramAddressSync(seeds, programId);
      }
      /**
       * Check that a pubkey is on the ed25519 curve.
       */
      static isOnCurve(pubkeyData) {
        const pubkey2 = new PublicKey(pubkeyData);
        return isOnCurve(pubkey2.toBytes());
      }
    };
    PublicKey.default = new PublicKey("11111111111111111111111111111111");
    SOLANA_SCHEMA.set(PublicKey, {
      kind: "struct",
      fields: [["_bn", "u256"]]
    });
    Account = class {
      /** @internal */
      /** @internal */
      /**
       * Create a new Account object
       *
       * If the secretKey parameter is not provided a new key pair is randomly
       * created for the account
       *
       * @param secretKey Secret key for the account
       */
      constructor(secretKey) {
        this._publicKey = void 0;
        this._secretKey = void 0;
        if (secretKey) {
          const secretKeyBuffer = toBuffer(secretKey);
          if (secretKey.length !== 64) {
            throw new Error("bad secret key size");
          }
          this._publicKey = secretKeyBuffer.slice(32, 64);
          this._secretKey = secretKeyBuffer.slice(0, 32);
        } else {
          this._secretKey = toBuffer(generatePrivateKey());
          this._publicKey = toBuffer(getPublicKey2(this._secretKey));
        }
      }
      /**
       * The public key for this account
       */
      get publicKey() {
        return new PublicKey(this._publicKey);
      }
      /**
       * The **unencrypted** secret key for this account. The first 32 bytes
       * is the private scalar and the last 32 bytes is the public key.
       * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
       */
      get secretKey() {
        return import_buffer.Buffer.concat([this._secretKey, this._publicKey], 64);
      }
    };
    BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111");
    PACKET_DATA_SIZE = 1280 - 40 - 8;
    VERSION_PREFIX_MASK = 127;
    SIGNATURE_LENGTH_IN_BYTES = 64;
    TransactionExpiredBlockheightExceededError = class extends Error {
      constructor(signature2) {
        super(`Signature ${signature2} has expired: block height exceeded.`);
        this.signature = void 0;
        this.signature = signature2;
      }
    };
    Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
      value: "TransactionExpiredBlockheightExceededError"
    });
    TransactionExpiredTimeoutError = class extends Error {
      constructor(signature2, timeoutSeconds) {
        super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature2} using the Solana Explorer or CLI tools.`);
        this.signature = void 0;
        this.signature = signature2;
      }
    };
    Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
      value: "TransactionExpiredTimeoutError"
    });
    TransactionExpiredNonceInvalidError = class extends Error {
      constructor(signature2) {
        super(`Signature ${signature2} has expired: the nonce is no longer valid.`);
        this.signature = void 0;
        this.signature = signature2;
      }
    };
    Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
      value: "TransactionExpiredNonceInvalidError"
    });
    MessageAccountKeys = class {
      constructor(staticAccountKeys, accountKeysFromLookups) {
        this.staticAccountKeys = void 0;
        this.accountKeysFromLookups = void 0;
        this.staticAccountKeys = staticAccountKeys;
        this.accountKeysFromLookups = accountKeysFromLookups;
      }
      keySegments() {
        const keySegments = [this.staticAccountKeys];
        if (this.accountKeysFromLookups) {
          keySegments.push(this.accountKeysFromLookups.writable);
          keySegments.push(this.accountKeysFromLookups.readonly);
        }
        return keySegments;
      }
      get(index2) {
        for (const keySegment of this.keySegments()) {
          if (index2 < keySegment.length) {
            return keySegment[index2];
          } else {
            index2 -= keySegment.length;
          }
        }
        return;
      }
      get length() {
        return this.keySegments().flat().length;
      }
      compileInstructions(instructions) {
        const U8_MAX = 255;
        if (this.length > U8_MAX + 1) {
          throw new Error("Account index overflow encountered during compilation");
        }
        const keyIndexMap = /* @__PURE__ */ new Map();
        this.keySegments().flat().forEach((key, index2) => {
          keyIndexMap.set(key.toBase58(), index2);
        });
        const findKeyIndex = (key) => {
          const keyIndex = keyIndexMap.get(key.toBase58());
          if (keyIndex === void 0)
            throw new Error("Encountered an unknown instruction account key during compilation");
          return keyIndex;
        };
        return instructions.map((instruction) => {
          return {
            programIdIndex: findKeyIndex(instruction.programId),
            accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
            data: instruction.data
          };
        });
      }
    };
    publicKey = (property = "publicKey") => {
      return BufferLayout.blob(32, property);
    };
    signature = (property = "signature") => {
      return BufferLayout.blob(64, property);
    };
    rustString = (property = "string") => {
      const rsl = BufferLayout.struct([BufferLayout.u32("length"), BufferLayout.u32("lengthPadding"), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), "chars")], property);
      const _decode = rsl.decode.bind(rsl);
      const _encode = rsl.encode.bind(rsl);
      const rslShim = rsl;
      rslShim.decode = (b, offset3) => {
        const data = _decode(b, offset3);
        return data["chars"].toString();
      };
      rslShim.encode = (str2, b, offset3) => {
        const data = {
          chars: import_buffer.Buffer.from(str2, "utf8")
        };
        return _encode(data, b, offset3);
      };
      rslShim.alloc = (str2) => {
        return BufferLayout.u32().span + BufferLayout.u32().span + import_buffer.Buffer.from(str2, "utf8").length;
      };
      return rslShim;
    };
    authorized = (property = "authorized") => {
      return BufferLayout.struct([publicKey("staker"), publicKey("withdrawer")], property);
    };
    lockup = (property = "lockup") => {
      return BufferLayout.struct([BufferLayout.ns64("unixTimestamp"), BufferLayout.ns64("epoch"), publicKey("custodian")], property);
    };
    voteInit = (property = "voteInit") => {
      return BufferLayout.struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), BufferLayout.u8("commission")], property);
    };
    voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
      return BufferLayout.struct([BufferLayout.u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], property);
    };
    CompiledKeys = class {
      constructor(payer, keyMetaMap) {
        this.payer = void 0;
        this.keyMetaMap = void 0;
        this.payer = payer;
        this.keyMetaMap = keyMetaMap;
      }
      static compile(instructions, payer) {
        const keyMetaMap = /* @__PURE__ */ new Map();
        const getOrInsertDefault = (pubkey2) => {
          const address = pubkey2.toBase58();
          let keyMeta = keyMetaMap.get(address);
          if (keyMeta === void 0) {
            keyMeta = {
              isSigner: false,
              isWritable: false,
              isInvoked: false
            };
            keyMetaMap.set(address, keyMeta);
          }
          return keyMeta;
        };
        const payerKeyMeta = getOrInsertDefault(payer);
        payerKeyMeta.isSigner = true;
        payerKeyMeta.isWritable = true;
        for (const ix of instructions) {
          getOrInsertDefault(ix.programId).isInvoked = true;
          for (const accountMeta of ix.keys) {
            const keyMeta = getOrInsertDefault(accountMeta.pubkey);
            keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
            keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
          }
        }
        return new CompiledKeys(payer, keyMetaMap);
      }
      getMessageComponents() {
        const mapEntries = [...this.keyMetaMap.entries()];
        assert3(mapEntries.length <= 256, "Max static account keys length exceeded");
        const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
        const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
        const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
        const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
        const header = {
          numRequiredSignatures: writableSigners.length + readonlySigners.length,
          numReadonlySignedAccounts: readonlySigners.length,
          numReadonlyUnsignedAccounts: readonlyNonSigners.length
        };
        {
          assert3(writableSigners.length > 0, "Expected at least one writable signer key");
          const [payerAddress] = writableSigners[0];
          assert3(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
        }
        const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];
        return [header, staticAccountKeys];
      }
      extractTableLookup(lookupTable) {
        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
          return;
        }
        return [{
          accountKey: lookupTable.key,
          writableIndexes,
          readonlyIndexes
        }, {
          writable: drainedWritableKeys,
          readonly: drainedReadonlyKeys
        }];
      }
      /** @internal */
      drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
        const lookupTableIndexes = new Array();
        const drainedKeys = new Array();
        for (const [address, keyMeta] of this.keyMetaMap.entries()) {
          if (keyMetaFilter(keyMeta)) {
            const key = new PublicKey(address);
            const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
            if (lookupTableIndex >= 0) {
              assert3(lookupTableIndex < 256, "Max lookup table index exceeded");
              lookupTableIndexes.push(lookupTableIndex);
              drainedKeys.push(key);
              this.keyMetaMap.delete(address);
            }
          }
        }
        return [lookupTableIndexes, drainedKeys];
      }
    };
    Message = class {
      constructor(args) {
        this.header = void 0;
        this.accountKeys = void 0;
        this.recentBlockhash = void 0;
        this.instructions = void 0;
        this.indexToProgramIds = /* @__PURE__ */ new Map();
        this.header = args.header;
        this.accountKeys = args.accountKeys.map((account) => new PublicKey(account));
        this.recentBlockhash = args.recentBlockhash;
        this.instructions = args.instructions;
        this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
      }
      get version() {
        return "legacy";
      }
      get staticAccountKeys() {
        return this.accountKeys;
      }
      get compiledInstructions() {
        return this.instructions.map((ix) => ({
          programIdIndex: ix.programIdIndex,
          accountKeyIndexes: ix.accounts,
          data: import_bs58.default.decode(ix.data)
        }));
      }
      get addressTableLookups() {
        return [];
      }
      getAccountKeys() {
        return new MessageAccountKeys(this.staticAccountKeys);
      }
      static compile(args) {
        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
        const accountKeys = new MessageAccountKeys(staticAccountKeys);
        const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
          programIdIndex: ix.programIdIndex,
          accounts: ix.accountKeyIndexes,
          data: import_bs58.default.encode(ix.data)
        }));
        return new Message({
          header,
          accountKeys: staticAccountKeys,
          recentBlockhash: args.recentBlockhash,
          instructions
        });
      }
      isAccountSigner(index2) {
        return index2 < this.header.numRequiredSignatures;
      }
      isAccountWritable(index2) {
        const numSignedAccounts = this.header.numRequiredSignatures;
        if (index2 >= this.header.numRequiredSignatures) {
          const unsignedAccountIndex = index2 - numSignedAccounts;
          const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
          const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
          return unsignedAccountIndex < numWritableUnsignedAccounts;
        } else {
          const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
          return index2 < numWritableSignedAccounts;
        }
      }
      isProgramId(index2) {
        return this.indexToProgramIds.has(index2);
      }
      programIds() {
        return [...this.indexToProgramIds.values()];
      }
      nonProgramIds() {
        return this.accountKeys.filter((_, index2) => !this.isProgramId(index2));
      }
      serialize() {
        const numKeys = this.accountKeys.length;
        let keyCount = [];
        encodeLength(keyCount, numKeys);
        const instructions = this.instructions.map((instruction) => {
          const {
            accounts,
            programIdIndex
          } = instruction;
          const data = Array.from(import_bs58.default.decode(instruction.data));
          let keyIndicesCount = [];
          encodeLength(keyIndicesCount, accounts.length);
          let dataCount = [];
          encodeLength(dataCount, data.length);
          return {
            programIdIndex,
            keyIndicesCount: import_buffer.Buffer.from(keyIndicesCount),
            keyIndices: accounts,
            dataLength: import_buffer.Buffer.from(dataCount),
            data
          };
        });
        let instructionCount = [];
        encodeLength(instructionCount, instructions.length);
        let instructionBuffer = import_buffer.Buffer.alloc(PACKET_DATA_SIZE);
        import_buffer.Buffer.from(instructionCount).copy(instructionBuffer);
        let instructionBufferLength = instructionCount.length;
        instructions.forEach((instruction) => {
          const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout.seq(BufferLayout.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout.blob(instruction.dataLength.length, "dataLength"), BufferLayout.seq(BufferLayout.u8("userdatum"), instruction.data.length, "data")]);
          const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
          instructionBufferLength += length2;
        });
        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
        const signDataLayout = BufferLayout.struct([BufferLayout.blob(1, "numRequiredSignatures"), BufferLayout.blob(1, "numReadonlySignedAccounts"), BufferLayout.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout.blob(keyCount.length, "keyCount"), BufferLayout.seq(publicKey("key"), numKeys, "keys"), publicKey("recentBlockhash")]);
        const transaction = {
          numRequiredSignatures: import_buffer.Buffer.from([this.header.numRequiredSignatures]),
          numReadonlySignedAccounts: import_buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
          numReadonlyUnsignedAccounts: import_buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
          keyCount: import_buffer.Buffer.from(keyCount),
          keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
          recentBlockhash: import_bs58.default.decode(this.recentBlockhash)
        };
        let signData = import_buffer.Buffer.alloc(2048);
        const length = signDataLayout.encode(transaction, signData);
        instructionBuffer.copy(signData, length);
        return signData.slice(0, length + instructionBuffer.length);
      }
      /**
       * Decode a compiled message into a Message object.
       */
      static from(buffer) {
        let byteArray = [...buffer];
        const numRequiredSignatures = byteArray.shift();
        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
          throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
        }
        const numReadonlySignedAccounts = byteArray.shift();
        const numReadonlyUnsignedAccounts = byteArray.shift();
        const accountCount = decodeLength(byteArray);
        let accountKeys = [];
        for (let i = 0; i < accountCount; i++) {
          const account = byteArray.slice(0, PUBLIC_KEY_LENGTH);
          byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
          accountKeys.push(new PublicKey(import_buffer.Buffer.from(account)));
        }
        const recentBlockhash = byteArray.slice(0, PUBLIC_KEY_LENGTH);
        byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
        const instructionCount = decodeLength(byteArray);
        let instructions = [];
        for (let i = 0; i < instructionCount; i++) {
          const programIdIndex = byteArray.shift();
          const accountCount2 = decodeLength(byteArray);
          const accounts = byteArray.slice(0, accountCount2);
          byteArray = byteArray.slice(accountCount2);
          const dataLength = decodeLength(byteArray);
          const dataSlice = byteArray.slice(0, dataLength);
          const data = import_bs58.default.encode(import_buffer.Buffer.from(dataSlice));
          byteArray = byteArray.slice(dataLength);
          instructions.push({
            programIdIndex,
            accounts,
            data
          });
        }
        const messageArgs = {
          header: {
            numRequiredSignatures,
            numReadonlySignedAccounts,
            numReadonlyUnsignedAccounts
          },
          recentBlockhash: import_bs58.default.encode(import_buffer.Buffer.from(recentBlockhash)),
          accountKeys,
          instructions
        };
        return new Message(messageArgs);
      }
    };
    MessageV0 = class {
      constructor(args) {
        this.header = void 0;
        this.staticAccountKeys = void 0;
        this.recentBlockhash = void 0;
        this.compiledInstructions = void 0;
        this.addressTableLookups = void 0;
        this.header = args.header;
        this.staticAccountKeys = args.staticAccountKeys;
        this.recentBlockhash = args.recentBlockhash;
        this.compiledInstructions = args.compiledInstructions;
        this.addressTableLookups = args.addressTableLookups;
      }
      get version() {
        return 0;
      }
      get numAccountKeysFromLookups() {
        let count = 0;
        for (const lookup of this.addressTableLookups) {
          count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
        }
        return count;
      }
      getAccountKeys(args) {
        let accountKeysFromLookups;
        if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
          if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
            throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
          }
          accountKeysFromLookups = args.accountKeysFromLookups;
        } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) {
          accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
        } else if (this.addressTableLookups.length > 0) {
          throw new Error("Failed to get account keys because address table lookups were not resolved");
        }
        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
      }
      isAccountSigner(index2) {
        return index2 < this.header.numRequiredSignatures;
      }
      isAccountWritable(index2) {
        const numSignedAccounts = this.header.numRequiredSignatures;
        const numStaticAccountKeys = this.staticAccountKeys.length;
        if (index2 >= numStaticAccountKeys) {
          const lookupAccountKeysIndex = index2 - numStaticAccountKeys;
          const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);
          return lookupAccountKeysIndex < numWritableLookupAccountKeys;
        } else if (index2 >= this.header.numRequiredSignatures) {
          const unsignedAccountIndex = index2 - numSignedAccounts;
          const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
          const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
          return unsignedAccountIndex < numWritableUnsignedAccounts;
        } else {
          const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
          return index2 < numWritableSignedAccounts;
        }
      }
      resolveAddressTableLookups(addressLookupTableAccounts) {
        const accountKeysFromLookups = {
          writable: [],
          readonly: []
        };
        for (const tableLookup of this.addressTableLookups) {
          const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
          if (!tableAccount) {
            throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
          }
          for (const index2 of tableLookup.writableIndexes) {
            if (index2 < tableAccount.state.addresses.length) {
              accountKeysFromLookups.writable.push(tableAccount.state.addresses[index2]);
            } else {
              throw new Error(`Failed to find address for index ${index2} in address lookup table ${tableLookup.accountKey.toBase58()}`);
            }
          }
          for (const index2 of tableLookup.readonlyIndexes) {
            if (index2 < tableAccount.state.addresses.length) {
              accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index2]);
            } else {
              throw new Error(`Failed to find address for index ${index2} in address lookup table ${tableLookup.accountKey.toBase58()}`);
            }
          }
        }
        return accountKeysFromLookups;
      }
      static compile(args) {
        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
        const addressTableLookups = new Array();
        const accountKeysFromLookups = {
          writable: new Array(),
          readonly: new Array()
        };
        const lookupTableAccounts = args.addressLookupTableAccounts || [];
        for (const lookupTable of lookupTableAccounts) {
          const extractResult = compiledKeys.extractTableLookup(lookupTable);
          if (extractResult !== void 0) {
            const [addressTableLookup, {
              writable,
              readonly
            }] = extractResult;
            addressTableLookups.push(addressTableLookup);
            accountKeysFromLookups.writable.push(...writable);
            accountKeysFromLookups.readonly.push(...readonly);
          }
        }
        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
        const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
        const compiledInstructions = accountKeys.compileInstructions(args.instructions);
        return new MessageV0({
          header,
          staticAccountKeys,
          recentBlockhash: args.recentBlockhash,
          compiledInstructions,
          addressTableLookups
        });
      }
      serialize() {
        const encodedStaticAccountKeysLength = Array();
        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
        const serializedInstructions = this.serializeInstructions();
        const encodedInstructionsLength = Array();
        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
        const serializedAddressTableLookups = this.serializeAddressTableLookups();
        const encodedAddressTableLookupsLength = Array();
        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
        const messageLayout = BufferLayout.struct([BufferLayout.u8("prefix"), BufferLayout.struct([BufferLayout.u8("numRequiredSignatures"), BufferLayout.u8("numReadonlySignedAccounts"), BufferLayout.u8("numReadonlyUnsignedAccounts")], "header"), BufferLayout.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), BufferLayout.seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey("recentBlockhash"), BufferLayout.blob(encodedInstructionsLength.length, "instructionsLength"), BufferLayout.blob(serializedInstructions.length, "serializedInstructions"), BufferLayout.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), BufferLayout.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
        const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
        const MESSAGE_VERSION_0_PREFIX = 1 << 7;
        const serializedMessageLength = messageLayout.encode({
          prefix: MESSAGE_VERSION_0_PREFIX,
          header: this.header,
          staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
          staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
          recentBlockhash: import_bs58.default.decode(this.recentBlockhash),
          instructionsLength: new Uint8Array(encodedInstructionsLength),
          serializedInstructions,
          addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
          serializedAddressTableLookups
        }, serializedMessage);
        return serializedMessage.slice(0, serializedMessageLength);
      }
      serializeInstructions() {
        let serializedLength = 0;
        const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
        for (const instruction of this.compiledInstructions) {
          const encodedAccountKeyIndexesLength = Array();
          encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
          const encodedDataLength = Array();
          encodeLength(encodedDataLength, instruction.data.length);
          const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), BufferLayout.seq(BufferLayout.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), BufferLayout.blob(encodedDataLength.length, "encodedDataLength"), BufferLayout.blob(instruction.data.length, "data")]);
          serializedLength += instructionLayout.encode({
            programIdIndex: instruction.programIdIndex,
            encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
            accountKeyIndexes: instruction.accountKeyIndexes,
            encodedDataLength: new Uint8Array(encodedDataLength),
            data: instruction.data
          }, serializedInstructions, serializedLength);
        }
        return serializedInstructions.slice(0, serializedLength);
      }
      serializeAddressTableLookups() {
        let serializedLength = 0;
        const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
        for (const lookup of this.addressTableLookups) {
          const encodedWritableIndexesLength = Array();
          encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
          const encodedReadonlyIndexesLength = Array();
          encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
          const addressTableLookupLayout = BufferLayout.struct([publicKey("accountKey"), BufferLayout.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), BufferLayout.seq(BufferLayout.u8(), lookup.writableIndexes.length, "writableIndexes"), BufferLayout.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), BufferLayout.seq(BufferLayout.u8(), lookup.readonlyIndexes.length, "readonlyIndexes")]);
          serializedLength += addressTableLookupLayout.encode({
            accountKey: lookup.accountKey.toBytes(),
            encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
            writableIndexes: lookup.writableIndexes,
            encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
            readonlyIndexes: lookup.readonlyIndexes
          }, serializedAddressTableLookups, serializedLength);
        }
        return serializedAddressTableLookups.slice(0, serializedLength);
      }
      static deserialize(serializedMessage) {
        let byteArray = [...serializedMessage];
        const prefix = byteArray.shift();
        const maskedPrefix = prefix & VERSION_PREFIX_MASK;
        assert3(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
        const version2 = maskedPrefix;
        assert3(version2 === 0, `Expected versioned message with version 0 but found version ${version2}`);
        const header = {
          numRequiredSignatures: byteArray.shift(),
          numReadonlySignedAccounts: byteArray.shift(),
          numReadonlyUnsignedAccounts: byteArray.shift()
        };
        const staticAccountKeys = [];
        const staticAccountKeysLength = decodeLength(byteArray);
        for (let i = 0; i < staticAccountKeysLength; i++) {
          staticAccountKeys.push(new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH)));
        }
        const recentBlockhash = import_bs58.default.encode(byteArray.splice(0, PUBLIC_KEY_LENGTH));
        const instructionCount = decodeLength(byteArray);
        const compiledInstructions = [];
        for (let i = 0; i < instructionCount; i++) {
          const programIdIndex = byteArray.shift();
          const accountKeyIndexesLength = decodeLength(byteArray);
          const accountKeyIndexes = byteArray.splice(0, accountKeyIndexesLength);
          const dataLength = decodeLength(byteArray);
          const data = new Uint8Array(byteArray.splice(0, dataLength));
          compiledInstructions.push({
            programIdIndex,
            accountKeyIndexes,
            data
          });
        }
        const addressTableLookupsCount = decodeLength(byteArray);
        const addressTableLookups = [];
        for (let i = 0; i < addressTableLookupsCount; i++) {
          const accountKey = new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH));
          const writableIndexesLength = decodeLength(byteArray);
          const writableIndexes = byteArray.splice(0, writableIndexesLength);
          const readonlyIndexesLength = decodeLength(byteArray);
          const readonlyIndexes = byteArray.splice(0, readonlyIndexesLength);
          addressTableLookups.push({
            accountKey,
            writableIndexes,
            readonlyIndexes
          });
        }
        return new MessageV0({
          header,
          staticAccountKeys,
          recentBlockhash,
          compiledInstructions,
          addressTableLookups
        });
      }
    };
    VersionedMessage = {
      deserializeMessageVersion(serializedMessage) {
        const prefix = serializedMessage[0];
        const maskedPrefix = prefix & VERSION_PREFIX_MASK;
        if (maskedPrefix === prefix) {
          return "legacy";
        }
        return maskedPrefix;
      },
      deserialize: (serializedMessage) => {
        const version2 = VersionedMessage.deserializeMessageVersion(serializedMessage);
        if (version2 === "legacy") {
          return Message.from(serializedMessage);
        }
        if (version2 === 0) {
          return MessageV0.deserialize(serializedMessage);
        } else {
          throw new Error(`Transaction message version ${version2} deserialization is not supported`);
        }
      }
    };
    (function(TransactionStatus2) {
      TransactionStatus2[TransactionStatus2["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
      TransactionStatus2[TransactionStatus2["PROCESSED"] = 1] = "PROCESSED";
      TransactionStatus2[TransactionStatus2["TIMED_OUT"] = 2] = "TIMED_OUT";
      TransactionStatus2[TransactionStatus2["NONCE_INVALID"] = 3] = "NONCE_INVALID";
    })(TransactionStatus || (TransactionStatus = {}));
    DEFAULT_SIGNATURE = import_buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
    TransactionInstruction = class {
      /**
       * Public keys to include in this transaction
       * Boolean represents whether this pubkey needs to sign the transaction
       */
      /**
       * Program Id to execute
       */
      /**
       * Program input
       */
      constructor(opts) {
        this.keys = void 0;
        this.programId = void 0;
        this.data = import_buffer.Buffer.alloc(0);
        this.programId = opts.programId;
        this.keys = opts.keys;
        if (opts.data) {
          this.data = opts.data;
        }
      }
      /**
       * @internal
       */
      toJSON() {
        return {
          keys: this.keys.map(({
            pubkey: pubkey2,
            isSigner,
            isWritable
          }) => ({
            pubkey: pubkey2.toJSON(),
            isSigner,
            isWritable
          })),
          programId: this.programId.toJSON(),
          data: [...this.data]
        };
      }
    };
    Transaction = class {
      /**
       * Signatures for the transaction.  Typically created by invoking the
       * `sign()` method
       */
      /**
       * The first (payer) Transaction signature
       */
      get signature() {
        if (this.signatures.length > 0) {
          return this.signatures[0].signature;
        }
        return null;
      }
      /**
       * The transaction fee payer
       */
      /**
       * Construct an empty Transaction
       */
      constructor(opts) {
        this.signatures = [];
        this.feePayer = void 0;
        this.instructions = [];
        this.recentBlockhash = void 0;
        this.lastValidBlockHeight = void 0;
        this.nonceInfo = void 0;
        this.minNonceContextSlot = void 0;
        this._message = void 0;
        this._json = void 0;
        if (!opts) {
          return;
        }
        if (opts.feePayer) {
          this.feePayer = opts.feePayer;
        }
        if (opts.signatures) {
          this.signatures = opts.signatures;
        }
        if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
          const {
            minContextSlot,
            nonceInfo
          } = opts;
          this.minNonceContextSlot = minContextSlot;
          this.nonceInfo = nonceInfo;
        } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
          const {
            blockhash,
            lastValidBlockHeight
          } = opts;
          this.recentBlockhash = blockhash;
          this.lastValidBlockHeight = lastValidBlockHeight;
        } else {
          const {
            recentBlockhash,
            nonceInfo
          } = opts;
          if (nonceInfo) {
            this.nonceInfo = nonceInfo;
          }
          this.recentBlockhash = recentBlockhash;
        }
      }
      /**
       * @internal
       */
      toJSON() {
        return {
          recentBlockhash: this.recentBlockhash || null,
          feePayer: this.feePayer ? this.feePayer.toJSON() : null,
          nonceInfo: this.nonceInfo ? {
            nonce: this.nonceInfo.nonce,
            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
          } : null,
          instructions: this.instructions.map((instruction) => instruction.toJSON()),
          signers: this.signatures.map(({
            publicKey: publicKey4
          }) => {
            return publicKey4.toJSON();
          })
        };
      }
      /**
       * Add one or more instructions to this Transaction
       */
      add(...items) {
        if (items.length === 0) {
          throw new Error("No instructions");
        }
        items.forEach((item) => {
          if ("instructions" in item) {
            this.instructions = this.instructions.concat(item.instructions);
          } else if ("data" in item && "programId" in item && "keys" in item) {
            this.instructions.push(item);
          } else {
            this.instructions.push(new TransactionInstruction(item));
          }
        });
        return this;
      }
      /**
       * Compile transaction data
       */
      compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
          return this._message;
        }
        let recentBlockhash;
        let instructions;
        if (this.nonceInfo) {
          recentBlockhash = this.nonceInfo.nonce;
          if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
            instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
          } else {
            instructions = this.instructions;
          }
        } else {
          recentBlockhash = this.recentBlockhash;
          instructions = this.instructions;
        }
        if (!recentBlockhash) {
          throw new Error("Transaction recentBlockhash required");
        }
        if (instructions.length < 1) {
          console.warn("No instructions provided");
        }
        let feePayer;
        if (this.feePayer) {
          feePayer = this.feePayer;
        } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
          feePayer = this.signatures[0].publicKey;
        } else {
          throw new Error("Transaction fee payer required");
        }
        for (let i = 0; i < instructions.length; i++) {
          if (instructions[i].programId === void 0) {
            throw new Error(`Transaction instruction index ${i} has undefined program id`);
          }
        }
        const programIds = [];
        const accountMetas = [];
        instructions.forEach((instruction) => {
          instruction.keys.forEach((accountMeta) => {
            accountMetas.push({
              ...accountMeta
            });
          });
          const programId = instruction.programId.toString();
          if (!programIds.includes(programId)) {
            programIds.push(programId);
          }
        });
        programIds.forEach((programId) => {
          accountMetas.push({
            pubkey: new PublicKey(programId),
            isSigner: false,
            isWritable: false
          });
        });
        const uniqueMetas = [];
        accountMetas.forEach((accountMeta) => {
          const pubkeyString = accountMeta.pubkey.toString();
          const uniqueIndex = uniqueMetas.findIndex((x) => {
            return x.pubkey.toString() === pubkeyString;
          });
          if (uniqueIndex > -1) {
            uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
            uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
          } else {
            uniqueMetas.push(accountMeta);
          }
        });
        uniqueMetas.sort(function(x, y) {
          if (x.isSigner !== y.isSigner) {
            return x.isSigner ? -1 : 1;
          }
          if (x.isWritable !== y.isWritable) {
            return x.isWritable ? -1 : 1;
          }
          return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58());
        });
        const feePayerIndex = uniqueMetas.findIndex((x) => {
          return x.pubkey.equals(feePayer);
        });
        if (feePayerIndex > -1) {
          const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
          payerMeta.isSigner = true;
          payerMeta.isWritable = true;
          uniqueMetas.unshift(payerMeta);
        } else {
          uniqueMetas.unshift({
            pubkey: feePayer,
            isSigner: true,
            isWritable: true
          });
        }
        for (const signature2 of this.signatures) {
          const uniqueIndex = uniqueMetas.findIndex((x) => {
            return x.pubkey.equals(signature2.publicKey);
          });
          if (uniqueIndex > -1) {
            if (!uniqueMetas[uniqueIndex].isSigner) {
              uniqueMetas[uniqueIndex].isSigner = true;
              console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
            }
          } else {
            throw new Error(`unknown signer: ${signature2.publicKey.toString()}`);
          }
        }
        let numRequiredSignatures = 0;
        let numReadonlySignedAccounts = 0;
        let numReadonlyUnsignedAccounts = 0;
        const signedKeys = [];
        const unsignedKeys = [];
        uniqueMetas.forEach(({
          pubkey: pubkey2,
          isSigner,
          isWritable
        }) => {
          if (isSigner) {
            signedKeys.push(pubkey2.toString());
            numRequiredSignatures += 1;
            if (!isWritable) {
              numReadonlySignedAccounts += 1;
            }
          } else {
            unsignedKeys.push(pubkey2.toString());
            if (!isWritable) {
              numReadonlyUnsignedAccounts += 1;
            }
          }
        });
        const accountKeys = signedKeys.concat(unsignedKeys);
        const compiledInstructions = instructions.map((instruction) => {
          const {
            data,
            programId
          } = instruction;
          return {
            programIdIndex: accountKeys.indexOf(programId.toString()),
            accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
            data: import_bs58.default.encode(data)
          };
        });
        compiledInstructions.forEach((instruction) => {
          assert3(instruction.programIdIndex >= 0);
          instruction.accounts.forEach((keyIndex) => assert3(keyIndex >= 0));
        });
        return new Message({
          header: {
            numRequiredSignatures,
            numReadonlySignedAccounts,
            numReadonlyUnsignedAccounts
          },
          accountKeys,
          recentBlockhash,
          instructions: compiledInstructions
        });
      }
      /**
       * @internal
       */
      _compile() {
        const message = this.compileMessage();
        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
        if (this.signatures.length === signedKeys.length) {
          const valid = this.signatures.every((pair, index2) => {
            return signedKeys[index2].equals(pair.publicKey);
          });
          if (valid)
            return message;
        }
        this.signatures = signedKeys.map((publicKey4) => ({
          signature: null,
          publicKey: publicKey4
        }));
        return message;
      }
      /**
       * Get a buffer of the Transaction data that need to be covered by signatures
       */
      serializeMessage() {
        return this._compile().serialize();
      }
      /**
       * Get the estimated fee associated with a transaction
       */
      async getEstimatedFee(connection) {
        return (await connection.getFeeForMessage(this.compileMessage())).value;
      }
      /**
       * Specify the public keys which will be used to sign the Transaction.
       * The first signer will be used as the transaction fee payer account.
       *
       * Signatures can be added with either `partialSign` or `addSignature`
       *
       * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
       * specified and it can be set in the Transaction constructor or with the
       * `feePayer` property.
       */
      setSigners(...signers) {
        if (signers.length === 0) {
          throw new Error("No signers");
        }
        const seen = /* @__PURE__ */ new Set();
        this.signatures = signers.filter((publicKey4) => {
          const key = publicKey4.toString();
          if (seen.has(key)) {
            return false;
          } else {
            seen.add(key);
            return true;
          }
        }).map((publicKey4) => ({
          signature: null,
          publicKey: publicKey4
        }));
      }
      /**
       * Sign the Transaction with the specified signers. Multiple signatures may
       * be applied to a Transaction. The first signature is considered "primary"
       * and is used identify and confirm transactions.
       *
       * If the Transaction `feePayer` is not set, the first signer will be used
       * as the transaction fee payer account.
       *
       * Transaction fields should not be modified after the first call to `sign`,
       * as doing so may invalidate the signature and cause the Transaction to be
       * rejected.
       *
       * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
       */
      sign(...signers) {
        if (signers.length === 0) {
          throw new Error("No signers");
        }
        const seen = /* @__PURE__ */ new Set();
        const uniqueSigners = [];
        for (const signer of signers) {
          const key = signer.publicKey.toString();
          if (seen.has(key)) {
            continue;
          } else {
            seen.add(key);
            uniqueSigners.push(signer);
          }
        }
        this.signatures = uniqueSigners.map((signer) => ({
          signature: null,
          publicKey: signer.publicKey
        }));
        const message = this._compile();
        this._partialSign(message, ...uniqueSigners);
      }
      /**
       * Partially sign a transaction with the specified accounts. All accounts must
       * correspond to either the fee payer or a signer account in the transaction
       * instructions.
       *
       * All the caveats from the `sign` method apply to `partialSign`
       */
      partialSign(...signers) {
        if (signers.length === 0) {
          throw new Error("No signers");
        }
        const seen = /* @__PURE__ */ new Set();
        const uniqueSigners = [];
        for (const signer of signers) {
          const key = signer.publicKey.toString();
          if (seen.has(key)) {
            continue;
          } else {
            seen.add(key);
            uniqueSigners.push(signer);
          }
        }
        const message = this._compile();
        this._partialSign(message, ...uniqueSigners);
      }
      /**
       * @internal
       */
      _partialSign(message, ...signers) {
        const signData = message.serialize();
        signers.forEach((signer) => {
          const signature2 = sign(signData, signer.secretKey);
          this._addSignature(signer.publicKey, toBuffer(signature2));
        });
      }
      /**
       * Add an externally created signature to a transaction. The public key
       * must correspond to either the fee payer or a signer account in the transaction
       * instructions.
       */
      addSignature(pubkey2, signature2) {
        this._compile();
        this._addSignature(pubkey2, signature2);
      }
      /**
       * @internal
       */
      _addSignature(pubkey2, signature2) {
        assert3(signature2.length === 64);
        const index2 = this.signatures.findIndex((sigpair) => pubkey2.equals(sigpair.publicKey));
        if (index2 < 0) {
          throw new Error(`unknown signer: ${pubkey2.toString()}`);
        }
        this.signatures[index2].signature = import_buffer.Buffer.from(signature2);
      }
      /**
       * Verify signatures of a Transaction
       * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
       * If no boolean is provided, we expect a fully signed Transaction by default.
       */
      verifySignatures(requireAllSignatures) {
        return this._verifySignatures(this.serializeMessage(), requireAllSignatures === void 0 ? true : requireAllSignatures);
      }
      /**
       * @internal
       */
      _verifySignatures(signData, requireAllSignatures) {
        for (const {
          signature: signature2,
          publicKey: publicKey4
        } of this.signatures) {
          if (signature2 === null) {
            if (requireAllSignatures) {
              return false;
            }
          } else {
            if (!verify(signature2, signData, publicKey4.toBytes())) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * Serialize the Transaction in the wire format.
       */
      serialize(config) {
        const {
          requireAllSignatures,
          verifySignatures
        } = Object.assign({
          requireAllSignatures: true,
          verifySignatures: true
        }, config);
        const signData = this.serializeMessage();
        if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {
          throw new Error("Signature verification failed");
        }
        return this._serialize(signData);
      }
      /**
       * @internal
       */
      _serialize(signData) {
        const {
          signatures
        } = this;
        const signatureCount = [];
        encodeLength(signatureCount, signatures.length);
        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
        const wireTransaction = import_buffer.Buffer.alloc(transactionLength);
        assert3(signatures.length < 256);
        import_buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);
        signatures.forEach(({
          signature: signature2
        }, index2) => {
          if (signature2 !== null) {
            assert3(signature2.length === 64, `signature has invalid length`);
            import_buffer.Buffer.from(signature2).copy(wireTransaction, signatureCount.length + index2 * 64);
          }
        });
        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
        assert3(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
        return wireTransaction;
      }
      /**
       * Deprecated method
       * @internal
       */
      get keys() {
        assert3(this.instructions.length === 1);
        return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
      }
      /**
       * Deprecated method
       * @internal
       */
      get programId() {
        assert3(this.instructions.length === 1);
        return this.instructions[0].programId;
      }
      /**
       * Deprecated method
       * @internal
       */
      get data() {
        assert3(this.instructions.length === 1);
        return this.instructions[0].data;
      }
      /**
       * Parse a wire transaction into a Transaction object.
       */
      static from(buffer) {
        let byteArray = [...buffer];
        const signatureCount = decodeLength(byteArray);
        let signatures = [];
        for (let i = 0; i < signatureCount; i++) {
          const signature2 = byteArray.slice(0, SIGNATURE_LENGTH_IN_BYTES);
          byteArray = byteArray.slice(SIGNATURE_LENGTH_IN_BYTES);
          signatures.push(import_bs58.default.encode(import_buffer.Buffer.from(signature2)));
        }
        return Transaction.populate(Message.from(byteArray), signatures);
      }
      /**
       * Populate Transaction object from message and signatures
       */
      static populate(message, signatures = []) {
        const transaction = new Transaction();
        transaction.recentBlockhash = message.recentBlockhash;
        if (message.header.numRequiredSignatures > 0) {
          transaction.feePayer = message.accountKeys[0];
        }
        signatures.forEach((signature2, index2) => {
          const sigPubkeyPair = {
            signature: signature2 == import_bs58.default.encode(DEFAULT_SIGNATURE) ? null : import_bs58.default.decode(signature2),
            publicKey: message.accountKeys[index2]
          };
          transaction.signatures.push(sigPubkeyPair);
        });
        message.instructions.forEach((instruction) => {
          const keys = instruction.accounts.map((account) => {
            const pubkey2 = message.accountKeys[account];
            return {
              pubkey: pubkey2,
              isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey2.toString()) || message.isAccountSigner(account),
              isWritable: message.isAccountWritable(account)
            };
          });
          transaction.instructions.push(new TransactionInstruction({
            keys,
            programId: message.accountKeys[instruction.programIdIndex],
            data: import_bs58.default.decode(instruction.data)
          }));
        });
        transaction._message = message;
        transaction._json = transaction.toJSON();
        return transaction;
      }
    };
    TransactionMessage = class {
      constructor(args) {
        this.payerKey = void 0;
        this.instructions = void 0;
        this.recentBlockhash = void 0;
        this.payerKey = args.payerKey;
        this.instructions = args.instructions;
        this.recentBlockhash = args.recentBlockhash;
      }
      static decompile(message, args) {
        const {
          header,
          compiledInstructions,
          recentBlockhash
        } = message;
        const {
          numRequiredSignatures,
          numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts
        } = header;
        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
        assert3(numWritableSignedAccounts > 0, "Message header is invalid");
        const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
        assert3(numWritableUnsignedAccounts >= 0, "Message header is invalid");
        const accountKeys = message.getAccountKeys(args);
        const payerKey = accountKeys.get(0);
        if (payerKey === void 0) {
          throw new Error("Failed to decompile message because no account keys were found");
        }
        const instructions = [];
        for (const compiledIx of compiledInstructions) {
          const keys = [];
          for (const keyIndex of compiledIx.accountKeyIndexes) {
            const pubkey2 = accountKeys.get(keyIndex);
            if (pubkey2 === void 0) {
              throw new Error(`Failed to find key for account key index ${keyIndex}`);
            }
            const isSigner = keyIndex < numRequiredSignatures;
            let isWritable;
            if (isSigner) {
              isWritable = keyIndex < numWritableSignedAccounts;
            } else if (keyIndex < accountKeys.staticAccountKeys.length) {
              isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
            } else {
              isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
              accountKeys.accountKeysFromLookups.writable.length;
            }
            keys.push({
              pubkey: pubkey2,
              isSigner: keyIndex < header.numRequiredSignatures,
              isWritable
            });
          }
          const programId = accountKeys.get(compiledIx.programIdIndex);
          if (programId === void 0) {
            throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
          }
          instructions.push(new TransactionInstruction({
            programId,
            data: toBuffer(compiledIx.data),
            keys
          }));
        }
        return new TransactionMessage({
          payerKey,
          instructions,
          recentBlockhash
        });
      }
      compileToLegacyMessage() {
        return Message.compile({
          payerKey: this.payerKey,
          recentBlockhash: this.recentBlockhash,
          instructions: this.instructions
        });
      }
      compileToV0Message(addressLookupTableAccounts) {
        return MessageV0.compile({
          payerKey: this.payerKey,
          recentBlockhash: this.recentBlockhash,
          instructions: this.instructions,
          addressLookupTableAccounts
        });
      }
    };
    VersionedTransaction = class {
      get version() {
        return this.message.version;
      }
      constructor(message, signatures) {
        this.signatures = void 0;
        this.message = void 0;
        if (signatures !== void 0) {
          assert3(signatures.length === message.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
          this.signatures = signatures;
        } else {
          const defaultSignatures = [];
          for (let i = 0; i < message.header.numRequiredSignatures; i++) {
            defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
          }
          this.signatures = defaultSignatures;
        }
        this.message = message;
      }
      serialize() {
        const serializedMessage = this.message.serialize();
        const encodedSignaturesLength = Array();
        encodeLength(encodedSignaturesLength, this.signatures.length);
        const transactionLayout = BufferLayout.struct([BufferLayout.blob(encodedSignaturesLength.length, "encodedSignaturesLength"), BufferLayout.seq(signature(), this.signatures.length, "signatures"), BufferLayout.blob(serializedMessage.length, "serializedMessage")]);
        const serializedTransaction = new Uint8Array(2048);
        const serializedTransactionLength = transactionLayout.encode({
          encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
          signatures: this.signatures,
          serializedMessage
        }, serializedTransaction);
        return serializedTransaction.slice(0, serializedTransactionLength);
      }
      static deserialize(serializedTransaction) {
        let byteArray = [...serializedTransaction];
        const signatures = [];
        const signaturesLength = decodeLength(byteArray);
        for (let i = 0; i < signaturesLength; i++) {
          signatures.push(new Uint8Array(byteArray.splice(0, SIGNATURE_LENGTH_IN_BYTES)));
        }
        const message = VersionedMessage.deserialize(new Uint8Array(byteArray));
        return new VersionedTransaction(message, signatures);
      }
      sign(signers) {
        const messageData = this.message.serialize();
        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        for (const signer of signers) {
          const signerIndex = signerPubkeys.findIndex((pubkey2) => pubkey2.equals(signer.publicKey));
          assert3(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
          this.signatures[signerIndex] = sign(messageData, signer.secretKey);
        }
      }
      addSignature(publicKey4, signature2) {
        assert3(signature2.byteLength === 64, "Signature must be 64 bytes long");
        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        const signerIndex = signerPubkeys.findIndex((pubkey2) => pubkey2.equals(publicKey4));
        assert3(signerIndex >= 0, `Can not add signature; \`${publicKey4.toBase58()}\` is not required to sign this transaction`);
        this.signatures[signerIndex] = signature2;
      }
    };
    SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111");
    SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
    SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111");
    SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
    SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
    SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111");
    SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111");
    SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111");
    SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
    FeeCalculatorLayout = BufferLayout.nu64("lamportsPerSignature");
    NonceAccountLayout = BufferLayout.struct([BufferLayout.u32("version"), BufferLayout.u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), BufferLayout.struct([FeeCalculatorLayout], "feeCalculator")]);
    NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
    NonceAccount = class {
      /**
       * @internal
       */
      constructor(args) {
        this.authorizedPubkey = void 0;
        this.nonce = void 0;
        this.feeCalculator = void 0;
        this.authorizedPubkey = args.authorizedPubkey;
        this.nonce = args.nonce;
        this.feeCalculator = args.feeCalculator;
      }
      /**
       * Deserialize NonceAccount from the account data.
       *
       * @param buffer account data
       * @return NonceAccount
       */
      static fromAccountData(buffer) {
        const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);
        return new NonceAccount({
          authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
          nonce: new PublicKey(nonceAccount.nonce).toString(),
          feeCalculator: nonceAccount.feeCalculator
        });
      }
    };
    encodeDecode = (layout) => {
      const decode3 = layout.decode.bind(layout);
      const encode3 = layout.encode.bind(layout);
      return {
        decode: decode3,
        encode: encode3
      };
    };
    bigInt = (length) => (property) => {
      const layout = (0, import_buffer_layout.blob)(length, property);
      const {
        encode: encode3,
        decode: decode3
      } = encodeDecode(layout);
      const bigIntLayout = layout;
      bigIntLayout.decode = (buffer, offset3) => {
        const src = decode3(buffer, offset3);
        return (0, import_bigint_buffer.toBigIntLE)(import_buffer.Buffer.from(src));
      };
      bigIntLayout.encode = (bigInt2, buffer, offset3) => {
        const src = (0, import_bigint_buffer.toBufferLE)(bigInt2, length);
        return encode3(src, buffer, offset3);
      };
      return bigIntLayout;
    };
    u642 = bigInt(8);
    SystemInstruction = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Decode a system instruction and retrieve the instruction type.
       */
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout.u32("instruction");
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type3;
        for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) {
          if (layout.index == typeIndex) {
            type3 = ixType;
            break;
          }
        }
        if (!type3) {
          throw new Error("Instruction type incorrect; not a SystemInstruction");
        }
        return type3;
      }
      /**
       * Decode a create account system instruction and retrieve the instruction params.
       */
      static decodeCreateAccount(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          lamports,
          space,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);
        return {
          fromPubkey: instruction.keys[0].pubkey,
          newAccountPubkey: instruction.keys[1].pubkey,
          lamports,
          space,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode a transfer system instruction and retrieve the instruction params.
       */
      static decodeTransfer(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          lamports
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);
        return {
          fromPubkey: instruction.keys[0].pubkey,
          toPubkey: instruction.keys[1].pubkey,
          lamports
        };
      }
      /**
       * Decode a transfer with seed system instruction and retrieve the instruction params.
       */
      static decodeTransferWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          lamports,
          seed: seed2,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);
        return {
          fromPubkey: instruction.keys[0].pubkey,
          basePubkey: instruction.keys[1].pubkey,
          toPubkey: instruction.keys[2].pubkey,
          lamports,
          seed: seed2,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode an allocate system instruction and retrieve the instruction params.
       */
      static decodeAllocate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const {
          space
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);
        return {
          accountPubkey: instruction.keys[0].pubkey,
          space
        };
      }
      /**
       * Decode an allocate with seed system instruction and retrieve the instruction params.
       */
      static decodeAllocateWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const {
          base,
          seed: seed2,
          space,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);
        return {
          accountPubkey: instruction.keys[0].pubkey,
          basePubkey: new PublicKey(base),
          seed: seed2,
          space,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode an assign system instruction and retrieve the instruction params.
       */
      static decodeAssign(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const {
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);
        return {
          accountPubkey: instruction.keys[0].pubkey,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode an assign with seed system instruction and retrieve the instruction params.
       */
      static decodeAssignWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const {
          base,
          seed: seed2,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);
        return {
          accountPubkey: instruction.keys[0].pubkey,
          basePubkey: new PublicKey(base),
          seed: seed2,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode a create account with seed system instruction and retrieve the instruction params.
       */
      static decodeCreateWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          base,
          seed: seed2,
          lamports,
          space,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);
        return {
          fromPubkey: instruction.keys[0].pubkey,
          newAccountPubkey: instruction.keys[1].pubkey,
          basePubkey: new PublicKey(base),
          seed: seed2,
          lamports,
          space,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode a nonce initialize system instruction and retrieve the instruction params.
       */
      static decodeNonceInitialize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          authorized: authorized2
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);
        return {
          noncePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: new PublicKey(authorized2)
        };
      }
      /**
       * Decode a nonce advance system instruction and retrieve the instruction params.
       */
      static decodeNonceAdvance(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
        return {
          noncePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey
        };
      }
      /**
       * Decode a nonce withdraw system instruction and retrieve the instruction params.
       */
      static decodeNonceWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 5);
        const {
          lamports
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);
        return {
          noncePubkey: instruction.keys[0].pubkey,
          toPubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[4].pubkey,
          lamports
        };
      }
      /**
       * Decode a nonce authorize system instruction and retrieve the instruction params.
       */
      static decodeNonceAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          authorized: authorized2
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);
        return {
          noncePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[1].pubkey,
          newAuthorizedPubkey: new PublicKey(authorized2)
        };
      }
      /**
       * @internal
       */
      static checkProgramId(programId) {
        if (!programId.equals(SystemProgram.programId)) {
          throw new Error("invalid instruction; programId is not SystemProgram");
        }
      }
      /**
       * @internal
       */
      static checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
        }
      }
    };
    SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
      Create: {
        index: 0,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
      },
      Assign: {
        index: 1,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("programId")])
      },
      Transfer: {
        index: 2,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("lamports")])
      },
      CreateWithSeed: {
        index: 3,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
      },
      AdvanceNonceAccount: {
        index: 4,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      },
      WithdrawNonceAccount: {
        index: 5,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
      },
      InitializeNonceAccount: {
        index: 6,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
      },
      AuthorizeNonceAccount: {
        index: 7,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
      },
      Allocate: {
        index: 8,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("space")])
      },
      AllocateWithSeed: {
        index: 9,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("space"), publicKey("programId")])
      },
      AssignWithSeed: {
        index: 10,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
      },
      TransferWithSeed: {
        index: 11,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("lamports"), rustString("seed"), publicKey("programId")])
      },
      UpgradeNonceAccount: {
        index: 12,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      }
    });
    SystemProgram = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Public key that identifies the System program
       */
      /**
       * Generate a transaction instruction that creates a new account
       */
      static createAccount(params) {
        const type3 = SYSTEM_INSTRUCTION_LAYOUTS.Create;
        const data = encodeData(type3, {
          lamports: params.lamports,
          space: params.space,
          programId: toBuffer(params.programId.toBuffer())
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: params.fromPubkey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: params.newAccountPubkey,
            isSigner: true,
            isWritable: true
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that transfers lamports from one account to another
       */
      static transfer(params) {
        let data;
        let keys;
        if ("basePubkey" in params) {
          const type3 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
          data = encodeData(type3, {
            lamports: BigInt(params.lamports),
            seed: params.seed,
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.fromPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: params.toPubkey,
            isSigner: false,
            isWritable: true
          }];
        } else {
          const type3 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
          data = encodeData(type3, {
            lamports: BigInt(params.lamports)
          });
          keys = [{
            pubkey: params.fromPubkey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: params.toPubkey,
            isSigner: false,
            isWritable: true
          }];
        }
        return new TransactionInstruction({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that assigns an account to a program
       */
      static assign(params) {
        let data;
        let keys;
        if ("basePubkey" in params) {
          const type3 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
          data = encodeData(type3, {
            base: toBuffer(params.basePubkey.toBuffer()),
            seed: params.seed,
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          }];
        } else {
          const type3 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
          data = encodeData(type3, {
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: true,
            isWritable: true
          }];
        }
        return new TransactionInstruction({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that creates a new account at
       *   an address generated with `from`, a seed, and programId
       */
      static createAccountWithSeed(params) {
        const type3 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
        const data = encodeData(type3, {
          base: toBuffer(params.basePubkey.toBuffer()),
          seed: params.seed,
          lamports: params.lamports,
          space: params.space,
          programId: toBuffer(params.programId.toBuffer())
        });
        let keys = [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.newAccountPubkey,
          isSigner: false,
          isWritable: true
        }];
        if (params.basePubkey != params.fromPubkey) {
          keys.push({
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          });
        }
        return new TransactionInstruction({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction that creates a new Nonce account
       */
      static createNonceAccount(params) {
        const transaction = new Transaction();
        if ("basePubkey" in params && "seed" in params) {
          transaction.add(SystemProgram.createAccountWithSeed({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.noncePubkey,
            basePubkey: params.basePubkey,
            seed: params.seed,
            lamports: params.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
          }));
        } else {
          transaction.add(SystemProgram.createAccount({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.noncePubkey,
            lamports: params.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
          }));
        }
        const initParams = {
          noncePubkey: params.noncePubkey,
          authorizedPubkey: params.authorizedPubkey
        };
        transaction.add(this.nonceInitialize(initParams));
        return transaction;
      }
      /**
       * Generate an instruction to initialize a Nonce account
       */
      static nonceInitialize(params) {
        const type3 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
        const data = encodeData(type3, {
          authorized: toBuffer(params.authorizedPubkey.toBuffer())
        });
        const instructionData = {
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }],
          programId: this.programId,
          data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate an instruction to advance the nonce in a Nonce account
       */
      static nonceAdvance(params) {
        const type3 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
        const data = encodeData(type3);
        const instructionData = {
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: params.authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate a transaction instruction that withdraws lamports from a Nonce account
       */
      static nonceWithdraw(params) {
        const type3 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
        const data = encodeData(type3, {
          lamports: params.lamports
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.toPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: params.authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that authorizes a new PublicKey as the authority
       * on a Nonce account.
       */
      static nonceAuthorize(params) {
        const type3 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
        const data = encodeData(type3, {
          authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that allocates space in an account without funding
       */
      static allocate(params) {
        let data;
        let keys;
        if ("basePubkey" in params) {
          const type3 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
          data = encodeData(type3, {
            base: toBuffer(params.basePubkey.toBuffer()),
            seed: params.seed,
            space: params.space,
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          }];
        } else {
          const type3 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
          data = encodeData(type3, {
            space: params.space
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: true,
            isWritable: true
          }];
        }
        return new TransactionInstruction({
          keys,
          programId: this.programId,
          data
        });
      }
    };
    SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
    CHUNK_SIZE = PACKET_DATA_SIZE - 300;
    Loader = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Amount of program data placed in each load Transaction
       */
      /**
       * Minimum number of signatures required to load a program not including
       * retries
       *
       * Can be used to calculate transaction fees
       */
      static getMinNumSignatures(dataLength) {
        return 2 * // Every transaction requires two signatures (payer + program)
        (Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction
        1);
      }
      /**
       * Loads a generic program
       *
       * @param connection The connection to use
       * @param payer System account that pays to load the program
       * @param program Account to load the program into
       * @param programId Public key that identifies the loader
       * @param data Program octets
       * @return true if program was loaded successfully, false if program was already loaded
       */
      static async load(connection, payer, program2, programId, data) {
        {
          const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
          const programInfo = await connection.getAccountInfo(program2.publicKey, "confirmed");
          let transaction = null;
          if (programInfo !== null) {
            if (programInfo.executable) {
              console.error("Program load failed, account is already executable");
              return false;
            }
            if (programInfo.data.length !== data.length) {
              transaction = transaction || new Transaction();
              transaction.add(SystemProgram.allocate({
                accountPubkey: program2.publicKey,
                space: data.length
              }));
            }
            if (!programInfo.owner.equals(programId)) {
              transaction = transaction || new Transaction();
              transaction.add(SystemProgram.assign({
                accountPubkey: program2.publicKey,
                programId
              }));
            }
            if (programInfo.lamports < balanceNeeded) {
              transaction = transaction || new Transaction();
              transaction.add(SystemProgram.transfer({
                fromPubkey: payer.publicKey,
                toPubkey: program2.publicKey,
                lamports: balanceNeeded - programInfo.lamports
              }));
            }
          } else {
            transaction = new Transaction().add(SystemProgram.createAccount({
              fromPubkey: payer.publicKey,
              newAccountPubkey: program2.publicKey,
              lamports: balanceNeeded > 0 ? balanceNeeded : 1,
              space: data.length,
              programId
            }));
          }
          if (transaction !== null) {
            await sendAndConfirmTransaction(connection, transaction, [payer, program2], {
              commitment: "confirmed"
            });
          }
        }
        const dataLayout = BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.u32("offset"), BufferLayout.u32("bytesLength"), BufferLayout.u32("bytesLengthPadding"), BufferLayout.seq(BufferLayout.u8("byte"), BufferLayout.offset(BufferLayout.u32(), -8), "bytes")]);
        const chunkSize = Loader.chunkSize;
        let offset3 = 0;
        let array4 = data;
        let transactions = [];
        while (array4.length > 0) {
          const bytes2 = array4.slice(0, chunkSize);
          const data2 = import_buffer.Buffer.alloc(chunkSize + 16);
          dataLayout.encode({
            instruction: 0,
            // Load instruction
            offset: offset3,
            bytes: bytes2,
            bytesLength: 0,
            bytesLengthPadding: 0
          }, data2);
          const transaction = new Transaction().add({
            keys: [{
              pubkey: program2.publicKey,
              isSigner: true,
              isWritable: true
            }],
            programId,
            data: data2
          });
          transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program2], {
            commitment: "confirmed"
          }));
          if (connection._rpcEndpoint.includes("solana.com")) {
            const REQUESTS_PER_SECOND = 4;
            await sleep(1e3 / REQUESTS_PER_SECOND);
          }
          offset3 += chunkSize;
          array4 = array4.slice(chunkSize);
        }
        await Promise.all(transactions);
        {
          const dataLayout2 = BufferLayout.struct([BufferLayout.u32("instruction")]);
          const data2 = import_buffer.Buffer.alloc(dataLayout2.span);
          dataLayout2.encode({
            instruction: 1
            // Finalize instruction
          }, data2);
          const transaction = new Transaction().add({
            keys: [{
              pubkey: program2.publicKey,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }],
            programId,
            data: data2
          });
          await sendAndConfirmTransaction(connection, transaction, [payer, program2], {
            commitment: "confirmed"
          });
        }
        return true;
      }
    };
    Loader.chunkSize = CHUNK_SIZE;
    BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
    BpfLoader = class {
      /**
       * Minimum number of signatures required to load a program not including
       * retries
       *
       * Can be used to calculate transaction fees
       */
      static getMinNumSignatures(dataLength) {
        return Loader.getMinNumSignatures(dataLength);
      }
      /**
       * Load a SBF program
       *
       * @param connection The connection to use
       * @param payer Account that will pay program loading fees
       * @param program Account to load the program into
       * @param elf The entire ELF containing the SBF program
       * @param loaderProgramId The program id of the BPF loader to use
       * @return true if program was loaded successfully, false if program was already loaded
       */
      static load(connection, payer, program2, elf, loaderProgramId) {
        return Loader.load(connection, payer, program2, loaderProgramId, elf);
      }
    };
    objToString = Object.prototype.toString;
    objKeys = Object.keys || function(obj) {
      var keys = [];
      for (var name in obj) {
        keys.push(name);
      }
      return keys;
    };
    fastStableStringify = function(val) {
      var returnVal = stringify2(val, false);
      if (returnVal !== void 0) {
        return "" + returnVal;
      }
    };
    fastStableStringify$1 = fastStableStringify;
    MINIMUM_SLOT_PER_EPOCH = 32;
    EpochSchedule = class {
      /** The maximum number of slots in each epoch */
      /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */
      /** Indicates whether epochs start short and grow */
      /** The first epoch with `slotsPerEpoch` slots */
      /** The first slot of `firstNormalEpoch` */
      constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
        this.slotsPerEpoch = void 0;
        this.leaderScheduleSlotOffset = void 0;
        this.warmup = void 0;
        this.firstNormalEpoch = void 0;
        this.firstNormalSlot = void 0;
        this.slotsPerEpoch = slotsPerEpoch;
        this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
        this.warmup = warmup;
        this.firstNormalEpoch = firstNormalEpoch;
        this.firstNormalSlot = firstNormalSlot;
      }
      getEpoch(slot) {
        return this.getEpochAndSlotIndex(slot)[0];
      }
      getEpochAndSlotIndex(slot) {
        if (slot < this.firstNormalSlot) {
          const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
          const epochLen = this.getSlotsInEpoch(epoch);
          const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
          return [epoch, slotIndex];
        } else {
          const normalSlotIndex = slot - this.firstNormalSlot;
          const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
          const epoch = this.firstNormalEpoch + normalEpochIndex;
          const slotIndex = normalSlotIndex % this.slotsPerEpoch;
          return [epoch, slotIndex];
        }
      }
      getFirstSlotInEpoch(epoch) {
        if (epoch <= this.firstNormalEpoch) {
          return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
        } else {
          return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
        }
      }
      getLastSlotInEpoch(epoch) {
        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
      }
      getSlotsInEpoch(epoch) {
        if (epoch < this.firstNormalEpoch) {
          return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
        } else {
          return this.slotsPerEpoch;
        }
      }
    };
    SendTransactionError = class extends Error {
      constructor(message, logs) {
        super(message);
        this.logs = void 0;
        this.logs = logs;
      }
    };
    SolanaJSONRPCErrorCode = {
      JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
      JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
      JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
      JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
      JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
      JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
      JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
      JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
      JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
      JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
      JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
      JSON_RPC_SCAN_ERROR: -32012,
      JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
      JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
      JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
      JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
    };
    SolanaJSONRPCError = class extends Error {
      constructor({
        code,
        message,
        data
      }, customMessage) {
        super(customMessage != null ? `${customMessage}: ${message}` : message);
        this.code = void 0;
        this.data = void 0;
        this.code = code;
        this.data = data;
        this.name = "SolanaJSONRPCError";
      }
    };
    fetchImpl = globalThis.fetch;
    RpcWebSocketClient = class extends import_client.default {
      constructor(address, options, generate_request_id) {
        const webSocketFactory = (url) => {
          const rpc2 = (0, import_websocket.default)(url, {
            autoconnect: true,
            max_reconnects: 5,
            reconnect: true,
            reconnect_interval: 1e3,
            ...options
          });
          if ("socket" in rpc2) {
            this.underlyingSocket = rpc2.socket;
          } else {
            this.underlyingSocket = rpc2;
          }
          return rpc2;
        };
        super(webSocketFactory, address, options, generate_request_id);
        this.underlyingSocket = void 0;
      }
      call(...args) {
        var _a;
        const readyState = (_a = this.underlyingSocket) == null ? void 0 : _a.readyState;
        if (readyState === 1) {
          return super.call(...args);
        }
        return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
      }
      notify(...args) {
        var _a;
        const readyState = (_a = this.underlyingSocket) == null ? void 0 : _a.readyState;
        if (readyState === 1) {
          return super.notify(...args);
        }
        return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
      }
    };
    NUM_TICKS_PER_SECOND = 160;
    DEFAULT_TICKS_PER_SLOT = 64;
    NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
    MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
    LOOKUP_TABLE_META_SIZE = 56;
    AddressLookupTableAccount = class {
      constructor(args) {
        this.key = void 0;
        this.state = void 0;
        this.key = args.key;
        this.state = args.state;
      }
      isActive() {
        const U64_MAX = BigInt("0xffffffffffffffff");
        return this.state.deactivationSlot === U64_MAX;
      }
      static deserialize(accountData) {
        const meta = decodeData(LookupTableMetaLayout, accountData);
        const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
        assert3(serializedAddressesLen >= 0, "lookup table is invalid");
        assert3(serializedAddressesLen % 32 === 0, "lookup table is invalid");
        const numSerializedAddresses = serializedAddressesLen / 32;
        const {
          addresses
        } = BufferLayout.struct([BufferLayout.seq(publicKey(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
        return {
          deactivationSlot: meta.deactivationSlot,
          lastExtendedSlot: meta.lastExtendedSlot,
          lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
          authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : void 0,
          addresses: addresses.map((address) => new PublicKey(address))
        };
      }
    };
    LookupTableMetaLayout = {
      index: 1,
      layout: BufferLayout.struct([
        BufferLayout.u32("typeIndex"),
        u642("deactivationSlot"),
        BufferLayout.nu64("lastExtendedSlot"),
        BufferLayout.u8("lastExtendedStartIndex"),
        BufferLayout.u8(),
        // option
        BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u8(), -1), "authority")
      ])
    };
    URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
    PublicKeyFromString = coerce(instance(PublicKey), string(), (value) => new PublicKey(value));
    RawAccountDataResult = tuple([string(), literal("base64")]);
    BufferFromRawAccountData = coerce(instance(import_buffer.Buffer), RawAccountDataResult, (value) => import_buffer.Buffer.from(value[0], "base64"));
    BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
    UnknownRpcResult = createRpcResult(unknown());
    GetInflationGovernorResult = type({
      foundation: number2(),
      foundationTerm: number2(),
      initial: number2(),
      taper: number2(),
      terminal: number2()
    });
    GetInflationRewardResult = jsonRpcResult(array(nullable(type({
      epoch: number2(),
      effectiveSlot: number2(),
      amount: number2(),
      postBalance: number2(),
      commission: optional(nullable(number2()))
    }))));
    GetRecentPrioritizationFeesResult = array(type({
      slot: number2(),
      prioritizationFee: number2()
    }));
    GetInflationRateResult = type({
      total: number2(),
      validator: number2(),
      foundation: number2(),
      epoch: number2()
    });
    GetEpochInfoResult = type({
      epoch: number2(),
      slotIndex: number2(),
      slotsInEpoch: number2(),
      absoluteSlot: number2(),
      blockHeight: optional(number2()),
      transactionCount: optional(number2())
    });
    GetEpochScheduleResult = type({
      slotsPerEpoch: number2(),
      leaderScheduleSlotOffset: number2(),
      warmup: boolean(),
      firstNormalEpoch: number2(),
      firstNormalSlot: number2()
    });
    GetLeaderScheduleResult = record(string(), array(number2()));
    TransactionErrorResult = nullable(union([type({}), string()]));
    SignatureStatusResult = type({
      err: TransactionErrorResult
    });
    SignatureReceivedResult = literal("receivedSignature");
    VersionResult = type({
      "solana-core": string(),
      "feature-set": optional(number2())
    });
    SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
      err: nullable(union([type({}), string()])),
      logs: nullable(array(string())),
      accounts: optional(nullable(array(nullable(type({
        executable: boolean(),
        owner: string(),
        lamports: number2(),
        data: array(string()),
        rentEpoch: optional(number2())
      }))))),
      unitsConsumed: optional(number2()),
      returnData: optional(nullable(type({
        programId: string(),
        data: tuple([string(), literal("base64")])
      })))
    }));
    BlockProductionResponseStruct = jsonRpcResultAndContext(type({
      byIdentity: record(string(), array(number2())),
      range: type({
        firstSlot: number2(),
        lastSlot: number2()
      })
    }));
    GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
    GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
    GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
    GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
    GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
    GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
    SlotRpcResult = jsonRpcResult(number2());
    GetSupplyRpcResult = jsonRpcResultAndContext(type({
      total: number2(),
      circulating: number2(),
      nonCirculating: number2(),
      nonCirculatingAccounts: array(PublicKeyFromString)
    }));
    TokenAmountResult = type({
      amount: string(),
      uiAmount: nullable(number2()),
      decimals: number2(),
      uiAmountString: optional(string())
    });
    GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
      address: PublicKeyFromString,
      amount: string(),
      uiAmount: nullable(number2()),
      decimals: number2(),
      uiAmountString: optional(string())
    })));
    GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
      pubkey: PublicKeyFromString,
      account: type({
        executable: boolean(),
        owner: PublicKeyFromString,
        lamports: number2(),
        data: BufferFromRawAccountData,
        rentEpoch: number2()
      })
    })));
    ParsedAccountDataResult = type({
      program: string(),
      parsed: unknown(),
      space: number2()
    });
    GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
      pubkey: PublicKeyFromString,
      account: type({
        executable: boolean(),
        owner: PublicKeyFromString,
        lamports: number2(),
        data: ParsedAccountDataResult,
        rentEpoch: number2()
      })
    })));
    GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
      lamports: number2(),
      address: PublicKeyFromString
    })));
    AccountInfoResult = type({
      executable: boolean(),
      owner: PublicKeyFromString,
      lamports: number2(),
      data: BufferFromRawAccountData,
      rentEpoch: number2()
    });
    KeyedAccountInfoResult = type({
      pubkey: PublicKeyFromString,
      account: AccountInfoResult
    });
    ParsedOrRawAccountData = coerce(union([instance(import_buffer.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
      if (Array.isArray(value)) {
        return create(value, BufferFromRawAccountData);
      } else {
        return value;
      }
    });
    ParsedAccountInfoResult = type({
      executable: boolean(),
      owner: PublicKeyFromString,
      lamports: number2(),
      data: ParsedOrRawAccountData,
      rentEpoch: number2()
    });
    KeyedParsedAccountInfoResult = type({
      pubkey: PublicKeyFromString,
      account: ParsedAccountInfoResult
    });
    StakeActivationResult = type({
      state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
      active: number2(),
      inactive: number2()
    });
    GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
      signature: string(),
      slot: number2(),
      err: TransactionErrorResult,
      memo: nullable(string()),
      blockTime: optional(nullable(number2()))
    })));
    GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
      signature: string(),
      slot: number2(),
      err: TransactionErrorResult,
      memo: nullable(string()),
      blockTime: optional(nullable(number2()))
    })));
    AccountNotificationResult = type({
      subscription: number2(),
      result: notificationResultAndContext(AccountInfoResult)
    });
    ProgramAccountInfoResult = type({
      pubkey: PublicKeyFromString,
      account: AccountInfoResult
    });
    ProgramAccountNotificationResult = type({
      subscription: number2(),
      result: notificationResultAndContext(ProgramAccountInfoResult)
    });
    SlotInfoResult = type({
      parent: number2(),
      slot: number2(),
      root: number2()
    });
    SlotNotificationResult = type({
      subscription: number2(),
      result: SlotInfoResult
    });
    SlotUpdateResult = union([type({
      type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
      slot: number2(),
      timestamp: number2()
    }), type({
      type: literal("createdBank"),
      parent: number2(),
      slot: number2(),
      timestamp: number2()
    }), type({
      type: literal("frozen"),
      slot: number2(),
      timestamp: number2(),
      stats: type({
        numTransactionEntries: number2(),
        numSuccessfulTransactions: number2(),
        numFailedTransactions: number2(),
        maxTransactionsPerEntry: number2()
      })
    }), type({
      type: literal("dead"),
      slot: number2(),
      timestamp: number2(),
      err: string()
    })]);
    SlotUpdateNotificationResult = type({
      subscription: number2(),
      result: SlotUpdateResult
    });
    SignatureNotificationResult = type({
      subscription: number2(),
      result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
    });
    RootNotificationResult = type({
      subscription: number2(),
      result: number2()
    });
    ContactInfoResult = type({
      pubkey: string(),
      gossip: nullable(string()),
      tpu: nullable(string()),
      rpc: nullable(string()),
      version: nullable(string())
    });
    VoteAccountInfoResult = type({
      votePubkey: string(),
      nodePubkey: string(),
      activatedStake: number2(),
      epochVoteAccount: boolean(),
      epochCredits: array(tuple([number2(), number2(), number2()])),
      commission: number2(),
      lastVote: number2(),
      rootSlot: nullable(number2())
    });
    GetVoteAccounts = jsonRpcResult(type({
      current: array(VoteAccountInfoResult),
      delinquent: array(VoteAccountInfoResult)
    }));
    ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]);
    SignatureStatusResponse = type({
      slot: number2(),
      confirmations: nullable(number2()),
      err: TransactionErrorResult,
      confirmationStatus: optional(ConfirmationStatus)
    });
    GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
    GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number2());
    AddressTableLookupStruct = type({
      accountKey: PublicKeyFromString,
      writableIndexes: array(number2()),
      readonlyIndexes: array(number2())
    });
    ConfirmedTransactionResult = type({
      signatures: array(string()),
      message: type({
        accountKeys: array(string()),
        header: type({
          numRequiredSignatures: number2(),
          numReadonlySignedAccounts: number2(),
          numReadonlyUnsignedAccounts: number2()
        }),
        instructions: array(type({
          accounts: array(number2()),
          data: string(),
          programIdIndex: number2()
        })),
        recentBlockhash: string(),
        addressTableLookups: optional(array(AddressTableLookupStruct))
      })
    });
    AnnotatedAccountKey = type({
      pubkey: PublicKeyFromString,
      signer: boolean(),
      writable: boolean(),
      source: optional(union([literal("transaction"), literal("lookupTable")]))
    });
    ConfirmedTransactionAccountsModeResult = type({
      accountKeys: array(AnnotatedAccountKey),
      signatures: array(string())
    });
    ParsedInstructionResult = type({
      parsed: unknown(),
      program: string(),
      programId: PublicKeyFromString
    });
    RawInstructionResult = type({
      accounts: array(PublicKeyFromString),
      data: string(),
      programId: PublicKeyFromString
    });
    InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
    UnknownInstructionResult = union([type({
      parsed: unknown(),
      program: string(),
      programId: string()
    }), type({
      accounts: array(string()),
      data: string(),
      programId: string()
    })]);
    ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value) => {
      if ("accounts" in value) {
        return create(value, RawInstructionResult);
      } else {
        return create(value, ParsedInstructionResult);
      }
    });
    ParsedConfirmedTransactionResult = type({
      signatures: array(string()),
      message: type({
        accountKeys: array(AnnotatedAccountKey),
        instructions: array(ParsedOrRawInstruction),
        recentBlockhash: string(),
        addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
      })
    });
    TokenBalanceResult = type({
      accountIndex: number2(),
      mint: string(),
      owner: optional(string()),
      uiTokenAmount: TokenAmountResult
    });
    LoadedAddressesResult = type({
      writable: array(PublicKeyFromString),
      readonly: array(PublicKeyFromString)
    });
    ConfirmedTransactionMetaResult = type({
      err: TransactionErrorResult,
      fee: number2(),
      innerInstructions: optional(nullable(array(type({
        index: number2(),
        instructions: array(type({
          accounts: array(number2()),
          data: string(),
          programIdIndex: number2()
        }))
      })))),
      preBalances: array(number2()),
      postBalances: array(number2()),
      logMessages: optional(nullable(array(string()))),
      preTokenBalances: optional(nullable(array(TokenBalanceResult))),
      postTokenBalances: optional(nullable(array(TokenBalanceResult))),
      loadedAddresses: optional(LoadedAddressesResult),
      computeUnitsConsumed: optional(number2())
    });
    ParsedConfirmedTransactionMetaResult = type({
      err: TransactionErrorResult,
      fee: number2(),
      innerInstructions: optional(nullable(array(type({
        index: number2(),
        instructions: array(ParsedOrRawInstruction)
      })))),
      preBalances: array(number2()),
      postBalances: array(number2()),
      logMessages: optional(nullable(array(string()))),
      preTokenBalances: optional(nullable(array(TokenBalanceResult))),
      postTokenBalances: optional(nullable(array(TokenBalanceResult))),
      loadedAddresses: optional(LoadedAddressesResult),
      computeUnitsConsumed: optional(number2())
    });
    TransactionVersionStruct = union([literal(0), literal("legacy")]);
    RewardsResult = type({
      pubkey: string(),
      lamports: number2(),
      postBalance: nullable(number2()),
      rewardType: nullable(string()),
      commission: optional(nullable(number2()))
    });
    GetBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number2(),
      transactions: array(type({
        transaction: ConfirmedTransactionResult,
        meta: nullable(ConfirmedTransactionMetaResult),
        version: optional(TransactionVersionStruct)
      })),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number2()),
      blockHeight: nullable(number2())
    })));
    GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number2(),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number2()),
      blockHeight: nullable(number2())
    })));
    GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number2(),
      transactions: array(type({
        transaction: ConfirmedTransactionAccountsModeResult,
        meta: nullable(ConfirmedTransactionMetaResult),
        version: optional(TransactionVersionStruct)
      })),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number2()),
      blockHeight: nullable(number2())
    })));
    GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number2(),
      transactions: array(type({
        transaction: ParsedConfirmedTransactionResult,
        meta: nullable(ParsedConfirmedTransactionMetaResult),
        version: optional(TransactionVersionStruct)
      })),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number2()),
      blockHeight: nullable(number2())
    })));
    GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number2(),
      transactions: array(type({
        transaction: ConfirmedTransactionAccountsModeResult,
        meta: nullable(ParsedConfirmedTransactionMetaResult),
        version: optional(TransactionVersionStruct)
      })),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number2()),
      blockHeight: nullable(number2())
    })));
    GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number2(),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number2()),
      blockHeight: nullable(number2())
    })));
    GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number2(),
      transactions: array(type({
        transaction: ConfirmedTransactionResult,
        meta: nullable(ConfirmedTransactionMetaResult)
      })),
      rewards: optional(array(RewardsResult)),
      blockTime: nullable(number2())
    })));
    GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
      blockhash: string(),
      previousBlockhash: string(),
      parentSlot: number2(),
      signatures: array(string()),
      blockTime: nullable(number2())
    })));
    GetTransactionRpcResult = jsonRpcResult(nullable(type({
      slot: number2(),
      meta: ConfirmedTransactionMetaResult,
      blockTime: optional(nullable(number2())),
      transaction: ConfirmedTransactionResult,
      version: optional(TransactionVersionStruct)
    })));
    GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
      slot: number2(),
      transaction: ParsedConfirmedTransactionResult,
      meta: nullable(ParsedConfirmedTransactionMetaResult),
      blockTime: optional(nullable(number2())),
      version: optional(TransactionVersionStruct)
    })));
    GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(type({
      blockhash: string(),
      feeCalculator: type({
        lamportsPerSignature: number2()
      })
    }));
    GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
      blockhash: string(),
      lastValidBlockHeight: number2()
    }));
    PerfSampleResult = type({
      slot: number2(),
      numTransactions: number2(),
      numSlots: number2(),
      samplePeriodSecs: number2()
    });
    GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));
    GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
      feeCalculator: type({
        lamportsPerSignature: number2()
      })
    })));
    RequestAirdropRpcResult = jsonRpcResult(string());
    SendTransactionRpcResult = jsonRpcResult(string());
    LogsResult = type({
      err: TransactionErrorResult,
      logs: array(string()),
      signature: string()
    });
    LogsNotificationResult = type({
      result: notificationResultAndContext(LogsResult),
      subscription: number2()
    });
    COMMON_HTTP_HEADERS = {
      "solana-client": `js/${"0.0.0-development"}`
    };
    Connection = class {
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal
       * A number that we increment every time an active connection closes.
       * Used to determine whether the same socket connection that was open
       * when an async operation started is the same one that's active when
       * its continuation fires.
       *
       */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /**
       * Special case.
       * After a signature is processed, RPCs automatically dispose of the
       * subscription on the server side. We need to track which of these
       * subscriptions have been disposed in such a way, so that we know
       * whether the client is dealing with a not-yet-processed signature
       * (in which case we must tear down the server subscription) or an
       * already-processed signature (in which case the client can simply
       * clear out the subscription locally without telling the server).
       *
       * NOTE: There is a proposal to eliminate this special case, here:
       * https://github.com/solana-labs/solana/issues/18892
       */
      /** @internal */
      /**
       * Establish a JSON RPC connection
       *
       * @param endpoint URL to the fullnode JSON RPC endpoint
       * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
       */
      constructor(endpoint2, _commitmentOrConfig) {
        this._commitment = void 0;
        this._confirmTransactionInitialTimeout = void 0;
        this._rpcEndpoint = void 0;
        this._rpcWsEndpoint = void 0;
        this._rpcClient = void 0;
        this._rpcRequest = void 0;
        this._rpcBatchRequest = void 0;
        this._rpcWebSocket = void 0;
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketHeartbeat = null;
        this._rpcWebSocketIdleTimeout = null;
        this._rpcWebSocketGeneration = 0;
        this._disableBlockhashCaching = false;
        this._pollingBlockhash = false;
        this._blockhashInfo = {
          latestBlockhash: null,
          lastFetch: 0,
          transactionSignatures: [],
          simulatedSignatures: []
        };
        this._nextClientSubscriptionId = 0;
        this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
        this._subscriptionHashByClientSubscriptionId = {};
        this._subscriptionStateChangeCallbacksByHash = {};
        this._subscriptionCallbacksByServerSubscriptionId = {};
        this._subscriptionsByHash = {};
        this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
        this.getBlockHeight = (() => {
          const requestPromises = {};
          return async (commitmentOrConfig) => {
            const {
              commitment,
              config
            } = extractCommitmentFromConfig(commitmentOrConfig);
            const args = this._buildArgs([], commitment, void 0, config);
            const requestHash = fastStableStringify$1(args);
            requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
              try {
                const unsafeRes = await this._rpcRequest("getBlockHeight", args);
                const res = create(unsafeRes, jsonRpcResult(number2()));
                if ("error" in res) {
                  throw new SolanaJSONRPCError(res.error, "failed to get block height information");
                }
                return res.result;
              } finally {
                delete requestPromises[requestHash];
              }
            })();
            return await requestPromises[requestHash];
          };
        })();
        let wsEndpoint;
        let httpHeaders;
        let fetch2;
        let fetchMiddleware;
        let disableRetryOnRateLimit;
        let httpAgent;
        if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") {
          this._commitment = _commitmentOrConfig;
        } else if (_commitmentOrConfig) {
          this._commitment = _commitmentOrConfig.commitment;
          this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
          wsEndpoint = _commitmentOrConfig.wsEndpoint;
          httpHeaders = _commitmentOrConfig.httpHeaders;
          fetch2 = _commitmentOrConfig.fetch;
          fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
          disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
          httpAgent = _commitmentOrConfig.httpAgent;
        }
        this._rpcEndpoint = assertEndpointUrl(endpoint2);
        this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint2);
        this._rpcClient = createRpcClient(endpoint2, httpHeaders, fetch2, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
        this._rpcRequest = createRpcRequest(this._rpcClient);
        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
        this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
          autoconnect: false,
          max_reconnects: Infinity
        });
        this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
        this._rpcWebSocket.on("error", this._wsOnError.bind(this));
        this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
        this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
        this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
        this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
        this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
        this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
        this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
        this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
      }
      /**
       * The default commitment used for requests
       */
      get commitment() {
        return this._commitment;
      }
      /**
       * The RPC endpoint
       */
      get rpcEndpoint() {
        return this._rpcEndpoint;
      }
      /**
       * Fetch the balance for the specified public key, return with context
       */
      async getBalanceAndContext(publicKey4, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([publicKey4.toBase58()], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getBalance", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(number2()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey4.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch the balance for the specified public key
       */
      async getBalance(publicKey4, commitmentOrConfig) {
        return await this.getBalanceAndContext(publicKey4, commitmentOrConfig).then((x) => x.value).catch((e) => {
          throw new Error("failed to get balance of account " + publicKey4.toBase58() + ": " + e);
        });
      }
      /**
       * Fetch the estimated production time of a block
       */
      async getBlockTime(slot) {
        const unsafeRes = await this._rpcRequest("getBlockTime", [slot]);
        const res = create(unsafeRes, jsonRpcResult(nullable(number2())));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
        }
        return res.result;
      }
      /**
       * Fetch the lowest slot that the node has information about in its ledger.
       * This value may increase over time if the node is configured to purge older ledger data
       */
      async getMinimumLedgerSlot() {
        const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
        const res = create(unsafeRes, jsonRpcResult(number2()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
        }
        return res.result;
      }
      /**
       * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
       */
      async getFirstAvailableBlock() {
        const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
        const res = create(unsafeRes, SlotRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get first available block");
        }
        return res.result;
      }
      /**
       * Fetch information about the current supply
       */
      async getSupply(config) {
        let configArg = {};
        if (typeof config === "string") {
          configArg = {
            commitment: config
          };
        } else if (config) {
          configArg = {
            ...config,
            commitment: config && config.commitment || this.commitment
          };
        } else {
          configArg = {
            commitment: this.commitment
          };
        }
        const unsafeRes = await this._rpcRequest("getSupply", [configArg]);
        const res = create(unsafeRes, GetSupplyRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get supply");
        }
        return res.result;
      }
      /**
       * Fetch the current supply of a token mint
       */
      async getTokenSupply(tokenMintAddress, commitment) {
        const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
        const unsafeRes = await this._rpcRequest("getTokenSupply", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get token supply");
        }
        return res.result;
      }
      /**
       * Fetch the current balance of a token account
       */
      async getTokenAccountBalance(tokenAddress, commitment) {
        const args = this._buildArgs([tokenAddress.toBase58()], commitment);
        const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
        }
        return res.result;
      }
      /**
       * Fetch all the token accounts owned by the specified account
       *
       * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>>}
       */
      async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        let _args = [ownerAddress.toBase58()];
        if ("mint" in filter) {
          _args.push({
            mint: filter.mint.toBase58()
          });
        } else {
          _args.push({
            programId: filter.programId.toBase58()
          });
        }
        const args = this._buildArgs(_args, commitment, "base64", config);
        const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
        const res = create(unsafeRes, GetTokenAccountsByOwner);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch parsed token accounts owned by the specified account
       *
       * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
       */
      async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
        let _args = [ownerAddress.toBase58()];
        if ("mint" in filter) {
          _args.push({
            mint: filter.mint.toBase58()
          });
        } else {
          _args.push({
            programId: filter.programId.toBase58()
          });
        }
        const args = this._buildArgs(_args, commitment, "jsonParsed");
        const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
        const res = create(unsafeRes, GetParsedTokenAccountsByOwner);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch the 20 largest accounts with their current balances
       */
      async getLargestAccounts(config) {
        const arg = {
          ...config,
          commitment: config && config.commitment || this.commitment
        };
        const args = arg.filter || arg.commitment ? [arg] : [];
        const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
        const res = create(unsafeRes, GetLargestAccountsRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
        }
        return res.result;
      }
      /**
       * Fetch the 20 largest token accounts with their current balances
       * for a given mint.
       */
      async getTokenLargestAccounts(mintAddress, commitment) {
        const args = this._buildArgs([mintAddress.toBase58()], commitment);
        const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
        const res = create(unsafeRes, GetTokenLargestAccountsResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
        }
        return res.result;
      }
      /**
       * Fetch all the account info for the specified public key, return with context
       */
      async getAccountInfoAndContext(publicKey4, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([publicKey4.toBase58()], commitment, "base64", config);
        const unsafeRes = await this._rpcRequest("getAccountInfo", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(nullable(AccountInfoResult)));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey4.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch parsed account info for the specified public key
       */
      async getParsedAccountInfo(publicKey4, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([publicKey4.toBase58()], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getAccountInfo", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey4.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch all the account info for the specified public key
       */
      async getAccountInfo(publicKey4, commitmentOrConfig) {
        try {
          const res = await this.getAccountInfoAndContext(publicKey4, commitmentOrConfig);
          return res.value;
        } catch (e) {
          throw new Error("failed to get info about account " + publicKey4.toBase58() + ": " + e);
        }
      }
      /**
       * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
       */
      async getMultipleParsedAccounts(publicKeys, rawConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(rawConfig);
        const keys = publicKeys.map((key) => key.toBase58());
        const args = this._buildArgs([keys], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
        }
        return res.result;
      }
      /**
       * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
       */
      async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const keys = publicKeys.map((key) => key.toBase58());
        const args = this._buildArgs([keys], commitment, "base64", config);
        const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
        }
        return res.result;
      }
      /**
       * Fetch all the account info for multiple accounts specified by an array of public keys
       */
      async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
        const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
        return res.value;
      }
      /**
       * Returns epoch activation information for a stake account that has been delegated
       */
      async getStakeActivation(publicKey4, commitmentOrConfig, epoch) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([publicKey4.toBase58()], commitment, void 0, {
          ...config,
          epoch: epoch != null ? epoch : config == null ? void 0 : config.epoch
        });
        const unsafeRes = await this._rpcRequest("getStakeActivation", args);
        const res = create(unsafeRes, jsonRpcResult(StakeActivationResult));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey4.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch all the accounts owned by the specified program id
       *
       * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
       */
      async getProgramAccounts(programId, configOrCommitment) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(configOrCommitment);
        const {
          encoding,
          ...configWithoutEncoding
        } = config || {};
        const args = this._buildArgs([programId.toBase58()], commitment, encoding || "base64", configWithoutEncoding);
        const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
        const res = create(unsafeRes, jsonRpcResult(array(KeyedAccountInfoResult)));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
        }
        return res.result;
      }
      /**
       * Fetch and parse all the accounts owned by the specified program id
       *
       * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
       */
      async getParsedProgramAccounts(programId, configOrCommitment) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(configOrCommitment);
        const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
        const res = create(unsafeRes, jsonRpcResult(array(KeyedParsedAccountInfoResult)));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
        }
        return res.result;
      }
      // eslint-disable-next-line no-dupe-class-members
      async confirmTransaction(strategy, commitment) {
        var _a;
        let rawSignature;
        if (typeof strategy == "string") {
          rawSignature = strategy;
        } else {
          const config = strategy;
          if ((_a = config.abortSignal) == null ? void 0 : _a.aborted) {
            return Promise.reject(config.abortSignal.reason);
          }
          rawSignature = config.signature;
        }
        let decodedSignature;
        try {
          decodedSignature = import_bs58.default.decode(rawSignature);
        } catch (err2) {
          throw new Error("signature must be base58 encoded: " + rawSignature);
        }
        assert3(decodedSignature.length === 64, "signature has invalid length");
        if (typeof strategy === "string") {
          return await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: commitment || this.commitment,
            signature: rawSignature
          });
        } else if ("lastValidBlockHeight" in strategy) {
          return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
            commitment: commitment || this.commitment,
            strategy
          });
        } else {
          return await this.confirmTransactionUsingDurableNonceStrategy({
            commitment: commitment || this.commitment,
            strategy
          });
        }
      }
      getCancellationPromise(signal) {
        return new Promise((_, reject) => {
          if (signal == null) {
            return;
          }
          if (signal.aborted) {
            reject(signal.reason);
          } else {
            signal.addEventListener("abort", () => {
              reject(signal.reason);
            });
          }
        });
      }
      getTransactionConfirmationPromise({
        commitment,
        signature: signature2
      }) {
        let signatureSubscriptionId;
        let disposeSignatureSubscriptionStateChangeObserver;
        let done = false;
        const confirmationPromise = new Promise((resolve, reject) => {
          try {
            signatureSubscriptionId = this.onSignature(signature2, (result, context) => {
              signatureSubscriptionId = void 0;
              const response = {
                context,
                value: result
              };
              resolve({
                __type: TransactionStatus.PROCESSED,
                response
              });
            }, commitment);
            const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
              if (signatureSubscriptionId == null) {
                resolveSubscriptionSetup();
              } else {
                disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
                  if (nextState === "subscribed") {
                    resolveSubscriptionSetup();
                  }
                });
              }
            });
            (async () => {
              await subscriptionSetupPromise;
              if (done)
                return;
              const response = await this.getSignatureStatus(signature2);
              if (done)
                return;
              if (response == null) {
                return;
              }
              const {
                context,
                value
              } = response;
              if (value == null) {
                return;
              }
              if (value == null ? void 0 : value.err) {
                reject(value.err);
              } else {
                switch (commitment) {
                  case "confirmed":
                  case "single":
                  case "singleGossip": {
                    if (value.confirmationStatus === "processed") {
                      return;
                    }
                    break;
                  }
                  case "finalized":
                  case "max":
                  case "root": {
                    if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") {
                      return;
                    }
                    break;
                  }
                  case "processed":
                  case "recent":
                }
                done = true;
                resolve({
                  __type: TransactionStatus.PROCESSED,
                  response: {
                    context,
                    value
                  }
                });
              }
            })();
          } catch (err2) {
            reject(err2);
          }
        });
        const abortConfirmation = () => {
          if (disposeSignatureSubscriptionStateChangeObserver) {
            disposeSignatureSubscriptionStateChangeObserver();
            disposeSignatureSubscriptionStateChangeObserver = void 0;
          }
          if (signatureSubscriptionId != null) {
            this.removeSignatureListener(signatureSubscriptionId);
            signatureSubscriptionId = void 0;
          }
        };
        return {
          abortConfirmation,
          confirmationPromise
        };
      }
      async confirmTransactionUsingBlockHeightExceedanceStrategy({
        commitment,
        strategy: {
          abortSignal,
          lastValidBlockHeight,
          signature: signature2
        }
      }) {
        let done = false;
        const expiryPromise = new Promise((resolve) => {
          const checkBlockHeight = async () => {
            try {
              const blockHeight = await this.getBlockHeight(commitment);
              return blockHeight;
            } catch (_e) {
              return -1;
            }
          };
          (async () => {
            let currentBlockHeight = await checkBlockHeight();
            if (done)
              return;
            while (currentBlockHeight <= lastValidBlockHeight) {
              await sleep(1e3);
              if (done)
                return;
              currentBlockHeight = await checkBlockHeight();
              if (done)
                return;
            }
            resolve({
              __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
            });
          })();
        });
        const {
          abortConfirmation,
          confirmationPromise
        } = this.getTransactionConfirmationPromise({
          commitment,
          signature: signature2
        });
        const cancellationPromise = this.getCancellationPromise(abortSignal);
        let result;
        try {
          const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
          if (outcome.__type === TransactionStatus.PROCESSED) {
            result = outcome.response;
          } else {
            throw new TransactionExpiredBlockheightExceededError(signature2);
          }
        } finally {
          done = true;
          abortConfirmation();
        }
        return result;
      }
      async confirmTransactionUsingDurableNonceStrategy({
        commitment,
        strategy: {
          abortSignal,
          minContextSlot,
          nonceAccountPubkey,
          nonceValue,
          signature: signature2
        }
      }) {
        let done = false;
        const expiryPromise = new Promise((resolve) => {
          let currentNonceValue = nonceValue;
          let lastCheckedSlot = null;
          const getCurrentNonceValue = async () => {
            try {
              const {
                context,
                value: nonceAccount
              } = await this.getNonceAndContext(nonceAccountPubkey, {
                commitment,
                minContextSlot
              });
              lastCheckedSlot = context.slot;
              return nonceAccount == null ? void 0 : nonceAccount.nonce;
            } catch (e) {
              return currentNonceValue;
            }
          };
          (async () => {
            currentNonceValue = await getCurrentNonceValue();
            if (done)
              return;
            while (true) {
              if (nonceValue !== currentNonceValue) {
                resolve({
                  __type: TransactionStatus.NONCE_INVALID,
                  slotInWhichNonceDidAdvance: lastCheckedSlot
                });
                return;
              }
              await sleep(2e3);
              if (done)
                return;
              currentNonceValue = await getCurrentNonceValue();
              if (done)
                return;
            }
          })();
        });
        const {
          abortConfirmation,
          confirmationPromise
        } = this.getTransactionConfirmationPromise({
          commitment,
          signature: signature2
        });
        const cancellationPromise = this.getCancellationPromise(abortSignal);
        let result;
        try {
          const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
          if (outcome.__type === TransactionStatus.PROCESSED) {
            result = outcome.response;
          } else {
            let signatureStatus;
            while (true) {
              const status = await this.getSignatureStatus(signature2);
              if (status == null) {
                break;
              }
              if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
                await sleep(400);
                continue;
              }
              signatureStatus = status;
              break;
            }
            if (signatureStatus == null ? void 0 : signatureStatus.value) {
              const commitmentForStatus = commitment || "finalized";
              const {
                confirmationStatus
              } = signatureStatus.value;
              switch (commitmentForStatus) {
                case "processed":
                case "recent":
                  if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                    throw new TransactionExpiredNonceInvalidError(signature2);
                  }
                  break;
                case "confirmed":
                case "single":
                case "singleGossip":
                  if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                    throw new TransactionExpiredNonceInvalidError(signature2);
                  }
                  break;
                case "finalized":
                case "max":
                case "root":
                  if (confirmationStatus !== "finalized") {
                    throw new TransactionExpiredNonceInvalidError(signature2);
                  }
                  break;
                default:
                  ((_) => {
                  })(commitmentForStatus);
              }
              result = {
                context: signatureStatus.context,
                value: {
                  err: signatureStatus.value.err
                }
              };
            } else {
              throw new TransactionExpiredNonceInvalidError(signature2);
            }
          }
        } finally {
          done = true;
          abortConfirmation();
        }
        return result;
      }
      async confirmTransactionUsingLegacyTimeoutStrategy({
        commitment,
        signature: signature2
      }) {
        let timeoutId;
        const expiryPromise = new Promise((resolve) => {
          let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1e3;
          switch (commitment) {
            case "processed":
            case "recent":
            case "single":
            case "confirmed":
            case "singleGossip": {
              timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1e3;
              break;
            }
          }
          timeoutId = setTimeout(() => resolve({
            __type: TransactionStatus.TIMED_OUT,
            timeoutMs
          }), timeoutMs);
        });
        const {
          abortConfirmation,
          confirmationPromise
        } = this.getTransactionConfirmationPromise({
          commitment,
          signature: signature2
        });
        let result;
        try {
          const outcome = await Promise.race([confirmationPromise, expiryPromise]);
          if (outcome.__type === TransactionStatus.PROCESSED) {
            result = outcome.response;
          } else {
            throw new TransactionExpiredTimeoutError(signature2, outcome.timeoutMs / 1e3);
          }
        } finally {
          clearTimeout(timeoutId);
          abortConfirmation();
        }
        return result;
      }
      /**
       * Return the list of nodes that are currently participating in the cluster
       */
      async getClusterNodes() {
        const unsafeRes = await this._rpcRequest("getClusterNodes", []);
        const res = create(unsafeRes, jsonRpcResult(array(ContactInfoResult)));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
        }
        return res.result;
      }
      /**
       * Return the list of nodes that are currently participating in the cluster
       */
      async getVoteAccounts(commitment) {
        const args = this._buildArgs([], commitment);
        const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
        const res = create(unsafeRes, GetVoteAccounts);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
        }
        return res.result;
      }
      /**
       * Fetch the current slot that the node is processing
       */
      async getSlot(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getSlot", args);
        const res = create(unsafeRes, jsonRpcResult(number2()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get slot");
        }
        return res.result;
      }
      /**
       * Fetch the current slot leader of the cluster
       */
      async getSlotLeader(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getSlotLeader", args);
        const res = create(unsafeRes, jsonRpcResult(string()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
        }
        return res.result;
      }
      /**
       * Fetch `limit` number of slot leaders starting from `startSlot`
       *
       * @param startSlot fetch slot leaders starting from this slot
       * @param limit number of slot leaders to return
       */
      async getSlotLeaders(startSlot, limit) {
        const args = [startSlot, limit];
        const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
        const res = create(unsafeRes, jsonRpcResult(array(PublicKeyFromString)));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
        }
        return res.result;
      }
      /**
       * Fetch the current status of a signature
       */
      async getSignatureStatus(signature2, config) {
        const {
          context,
          value: values
        } = await this.getSignatureStatuses([signature2], config);
        assert3(values.length === 1);
        const value = values[0];
        return {
          context,
          value
        };
      }
      /**
       * Fetch the current statuses of a batch of signatures
       */
      async getSignatureStatuses(signatures, config) {
        const params = [signatures];
        if (config) {
          params.push(config);
        }
        const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
        const res = create(unsafeRes, GetSignatureStatusesRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get signature status");
        }
        return res.result;
      }
      /**
       * Fetch the current transaction count of the cluster
       */
      async getTransactionCount(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getTransactionCount", args);
        const res = create(unsafeRes, jsonRpcResult(number2()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
        }
        return res.result;
      }
      /**
       * Fetch the current total currency supply of the cluster in lamports
       *
       * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.
       */
      async getTotalSupply(commitment) {
        const result = await this.getSupply({
          commitment,
          excludeNonCirculatingAccountsList: true
        });
        return result.value.total;
      }
      /**
       * Fetch the cluster InflationGovernor parameters
       */
      async getInflationGovernor(commitment) {
        const args = this._buildArgs([], commitment);
        const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
        const res = create(unsafeRes, GetInflationGovernorRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get inflation");
        }
        return res.result;
      }
      /**
       * Fetch the inflation reward for a list of addresses for an epoch
       */
      async getInflationReward(addresses, epoch, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([addresses.map((pubkey2) => pubkey2.toBase58())], commitment, void 0, {
          ...config,
          epoch: epoch != null ? epoch : config == null ? void 0 : config.epoch
        });
        const unsafeRes = await this._rpcRequest("getInflationReward", args);
        const res = create(unsafeRes, GetInflationRewardResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
        }
        return res.result;
      }
      /**
       * Fetch the specific inflation values for the current epoch
       */
      async getInflationRate() {
        const unsafeRes = await this._rpcRequest("getInflationRate", []);
        const res = create(unsafeRes, GetInflationRateRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
        }
        return res.result;
      }
      /**
       * Fetch the Epoch Info parameters
       */
      async getEpochInfo(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getEpochInfo", args);
        const res = create(unsafeRes, GetEpochInfoRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
        }
        return res.result;
      }
      /**
       * Fetch the Epoch Schedule parameters
       */
      async getEpochSchedule() {
        const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
        const res = create(unsafeRes, GetEpochScheduleRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
        }
        const epochSchedule = res.result;
        return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
      }
      /**
       * Fetch the leader schedule for the current epoch
       * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
       */
      async getLeaderSchedule() {
        const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
        const res = create(unsafeRes, GetLeaderScheduleRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
        }
        return res.result;
      }
      /**
       * Fetch the minimum balance needed to exempt an account of `dataLength`
       * size from rent
       */
      async getMinimumBalanceForRentExemption(dataLength, commitment) {
        const args = this._buildArgs([dataLength], commitment);
        const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
        const res = create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
        if ("error" in res) {
          console.warn("Unable to fetch minimum balance for rent exemption");
          return 0;
        }
        return res.result;
      }
      /**
       * Fetch a recent blockhash from the cluster, return with context
       * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
       */
      async getRecentBlockhashAndContext(commitment) {
        const args = this._buildArgs([], commitment);
        const unsafeRes = await this._rpcRequest("getRecentBlockhash", args);
        const res = create(unsafeRes, GetRecentBlockhashAndContextRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get recent blockhash");
        }
        return res.result;
      }
      /**
       * Fetch recent performance samples
       * @return {Promise<Array<PerfSample>>}
       */
      async getRecentPerformanceSamples(limit) {
        const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", limit ? [limit] : []);
        const res = create(unsafeRes, GetRecentPerformanceSamplesRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
        }
        return res.result;
      }
      /**
       * Fetch the fee calculator for a recent blockhash from the cluster, return with context
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.
       */
      async getFeeCalculatorForBlockhash(blockhash, commitment) {
        const args = this._buildArgs([blockhash], commitment);
        const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
        const res = create(unsafeRes, GetFeeCalculatorRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
        }
        const {
          context,
          value
        } = res.result;
        return {
          context,
          value: value !== null ? value.feeCalculator : null
        };
      }
      /**
       * Fetch the fee for a message from the cluster, return with context
       */
      async getFeeForMessage(message, commitment) {
        const wireMessage = toBuffer(message.serialize()).toString("base64");
        const args = this._buildArgs([wireMessage], commitment);
        const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(nullable(number2())));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
        }
        if (res.result === null) {
          throw new Error("invalid blockhash");
        }
        return res.result;
      }
      /**
       * Fetch a list of prioritization fees from recent blocks.
       */
      async getRecentPrioritizationFees(config) {
        var _a;
        const accounts = (_a = config == null ? void 0 : config.lockedWritableAccounts) == null ? void 0 : _a.map((key) => key.toBase58());
        const args = this._buildArgs((accounts == null ? void 0 : accounts.length) ? [accounts] : []);
        const unsafeRes = await this._rpcRequest("getRecentPrioritizationFees", args);
        const res = create(unsafeRes, GetRecentPrioritizationFeesRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
        }
        return res.result;
      }
      /**
       * Fetch a recent blockhash from the cluster
       * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
       */
      async getRecentBlockhash(commitment) {
        try {
          const res = await this.getRecentBlockhashAndContext(commitment);
          return res.value;
        } catch (e) {
          throw new Error("failed to get recent blockhash: " + e);
        }
      }
      /**
       * Fetch the latest blockhash from the cluster
       * @return {Promise<BlockhashWithExpiryBlockHeight>}
       */
      async getLatestBlockhash(commitmentOrConfig) {
        try {
          const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
          return res.value;
        } catch (e) {
          throw new Error("failed to get recent blockhash: " + e);
        }
      }
      /**
       * Fetch the latest blockhash from the cluster
       * @return {Promise<BlockhashWithExpiryBlockHeight>}
       */
      async getLatestBlockhashAndContext(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
        const res = create(unsafeRes, GetLatestBlockhashRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
        }
        return res.result;
      }
      /**
       * Fetch the node version
       */
      async getVersion() {
        const unsafeRes = await this._rpcRequest("getVersion", []);
        const res = create(unsafeRes, jsonRpcResult(VersionResult));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get version");
        }
        return res.result;
      }
      /**
       * Fetch the genesis hash
       */
      async getGenesisHash() {
        const unsafeRes = await this._rpcRequest("getGenesisHash", []);
        const res = create(unsafeRes, jsonRpcResult(string()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
        }
        return res.result;
      }
      /**
       * Fetch a processed block from the cluster.
       *
       * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
       * setting the `maxSupportedTransactionVersion` property.
       */
      /**
       * Fetch a processed block from the cluster.
       */
      // eslint-disable-next-line no-dupe-class-members
      async getBlock(slot, rawConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(rawConfig);
        const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getBlock", args);
        try {
          switch (config == null ? void 0 : config.transactionDetails) {
            case "accounts": {
              const res = create(unsafeRes, GetAccountsModeBlockRpcResult);
              if ("error" in res) {
                throw res.error;
              }
              return res.result;
            }
            case "none": {
              const res = create(unsafeRes, GetNoneModeBlockRpcResult);
              if ("error" in res) {
                throw res.error;
              }
              return res.result;
            }
            default: {
              const res = create(unsafeRes, GetBlockRpcResult);
              if ("error" in res) {
                throw res.error;
              }
              const {
                result
              } = res;
              return result ? {
                ...result,
                transactions: result.transactions.map(({
                  transaction,
                  meta,
                  version: version2
                }) => ({
                  meta,
                  transaction: {
                    ...transaction,
                    message: versionedMessageFromResponse(version2, transaction.message)
                  },
                  version: version2
                }))
              } : null;
            }
          }
        } catch (e) {
          throw new SolanaJSONRPCError(e, "failed to get confirmed block");
        }
      }
      /**
       * Fetch parsed transaction details for a confirmed or finalized block
       */
      // eslint-disable-next-line no-dupe-class-members
      async getParsedBlock(slot, rawConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(rawConfig);
        const args = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getBlock", args);
        try {
          switch (config == null ? void 0 : config.transactionDetails) {
            case "accounts": {
              const res = create(unsafeRes, GetParsedAccountsModeBlockRpcResult);
              if ("error" in res) {
                throw res.error;
              }
              return res.result;
            }
            case "none": {
              const res = create(unsafeRes, GetParsedNoneModeBlockRpcResult);
              if ("error" in res) {
                throw res.error;
              }
              return res.result;
            }
            default: {
              const res = create(unsafeRes, GetParsedBlockRpcResult);
              if ("error" in res) {
                throw res.error;
              }
              return res.result;
            }
          }
        } catch (e) {
          throw new SolanaJSONRPCError(e, "failed to get block");
        }
      }
      /*
       * Returns the current block height of the node
       */
      /*
       * Returns recent block production information from the current or previous epoch
       */
      async getBlockProduction(configOrCommitment) {
        let extra;
        let commitment;
        if (typeof configOrCommitment === "string") {
          commitment = configOrCommitment;
        } else if (configOrCommitment) {
          const {
            commitment: c,
            ...rest
          } = configOrCommitment;
          commitment = c;
          extra = rest;
        }
        const args = this._buildArgs([], commitment, "base64", extra);
        const unsafeRes = await this._rpcRequest("getBlockProduction", args);
        const res = create(unsafeRes, BlockProductionResponseStruct);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get block production information");
        }
        return res.result;
      }
      /**
       * Fetch a confirmed or finalized transaction from the cluster.
       *
       * @deprecated Instead, call `getTransaction` using a
       * `GetVersionedTransactionConfig` by setting the
       * `maxSupportedTransactionVersion` property.
       */
      /**
       * Fetch a confirmed or finalized transaction from the cluster.
       */
      // eslint-disable-next-line no-dupe-class-members
      async getTransaction(signature2, rawConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(rawConfig);
        const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config);
        const unsafeRes = await this._rpcRequest("getTransaction", args);
        const res = create(unsafeRes, GetTransactionRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get transaction");
        }
        const result = res.result;
        if (!result)
          return result;
        return {
          ...result,
          transaction: {
            ...result.transaction,
            message: versionedMessageFromResponse(result.version, result.transaction.message)
          }
        };
      }
      /**
       * Fetch parsed transaction details for a confirmed or finalized transaction
       */
      async getParsedTransaction(signature2, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config);
        const unsafeRes = await this._rpcRequest("getTransaction", args);
        const res = create(unsafeRes, GetParsedTransactionRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get transaction");
        }
        return res.result;
      }
      /**
       * Fetch parsed transaction details for a batch of confirmed transactions
       */
      async getParsedTransactions(signatures, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const batch = signatures.map((signature2) => {
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config);
          return {
            methodName: "getTransaction",
            args
          };
        });
        const unsafeRes = await this._rpcBatchRequest(batch);
        const res = unsafeRes.map((unsafeRes2) => {
          const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
          if ("error" in res2) {
            throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
          }
          return res2.result;
        });
        return res;
      }
      /**
       * Fetch transaction details for a batch of confirmed transactions.
       * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
       *
       * @deprecated Instead, call `getTransactions` using a
       * `GetVersionedTransactionConfig` by setting the
       * `maxSupportedTransactionVersion` property.
       */
      /**
       * Fetch transaction details for a batch of confirmed transactions.
       * Similar to {@link getParsedTransactions} but returns a {@link
       * VersionedTransactionResponse}.
       */
      // eslint-disable-next-line no-dupe-class-members
      async getTransactions(signatures, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const batch = signatures.map((signature2) => {
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config);
          return {
            methodName: "getTransaction",
            args
          };
        });
        const unsafeRes = await this._rpcBatchRequest(batch);
        const res = unsafeRes.map((unsafeRes2) => {
          const res2 = create(unsafeRes2, GetTransactionRpcResult);
          if ("error" in res2) {
            throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
          }
          const result = res2.result;
          if (!result)
            return result;
          return {
            ...result,
            transaction: {
              ...result.transaction,
              message: versionedMessageFromResponse(result.version, result.transaction.message)
            }
          };
        });
        return res;
      }
      /**
       * Fetch a list of Transactions and transaction statuses from the cluster
       * for a confirmed block.
       *
       * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.
       */
      async getConfirmedBlock(slot, commitment) {
        const args = this._buildArgsAtLeastConfirmed([slot], commitment);
        const unsafeRes = await this._rpcRequest("getConfirmedBlock", args);
        const res = create(unsafeRes, GetConfirmedBlockRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
        }
        const result = res.result;
        if (!result) {
          throw new Error("Confirmed block " + slot + " not found");
        }
        const block = {
          ...result,
          transactions: result.transactions.map(({
            transaction,
            meta
          }) => {
            const message = new Message(transaction.message);
            return {
              meta,
              transaction: {
                ...transaction,
                message
              }
            };
          })
        };
        return {
          ...block,
          transactions: block.transactions.map(({
            transaction,
            meta
          }) => {
            return {
              meta,
              transaction: Transaction.populate(transaction.message, transaction.signatures)
            };
          })
        };
      }
      /**
       * Fetch confirmed blocks between two slots
       */
      async getBlocks(startSlot, endSlot, commitment) {
        const args = this._buildArgsAtLeastConfirmed(endSlot !== void 0 ? [startSlot, endSlot] : [startSlot], commitment);
        const unsafeRes = await this._rpcRequest("getBlocks", args);
        const res = create(unsafeRes, jsonRpcResult(array(number2())));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get blocks");
        }
        return res.result;
      }
      /**
       * Fetch a list of Signatures from the cluster for a block, excluding rewards
       */
      async getBlockSignatures(slot, commitment) {
        const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
          transactionDetails: "signatures",
          rewards: false
        });
        const unsafeRes = await this._rpcRequest("getBlock", args);
        const res = create(unsafeRes, GetBlockSignaturesRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get block");
        }
        const result = res.result;
        if (!result) {
          throw new Error("Block " + slot + " not found");
        }
        return result;
      }
      /**
       * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.
       */
      async getConfirmedBlockSignatures(slot, commitment) {
        const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
          transactionDetails: "signatures",
          rewards: false
        });
        const unsafeRes = await this._rpcRequest("getConfirmedBlock", args);
        const res = create(unsafeRes, GetBlockSignaturesRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
        }
        const result = res.result;
        if (!result) {
          throw new Error("Confirmed block " + slot + " not found");
        }
        return result;
      }
      /**
       * Fetch a transaction details for a confirmed transaction
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.
       */
      async getConfirmedTransaction(signature2, commitment) {
        const args = this._buildArgsAtLeastConfirmed([signature2], commitment);
        const unsafeRes = await this._rpcRequest("getConfirmedTransaction", args);
        const res = create(unsafeRes, GetTransactionRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get transaction");
        }
        const result = res.result;
        if (!result)
          return result;
        const message = new Message(result.transaction.message);
        const signatures = result.transaction.signatures;
        return {
          ...result,
          transaction: Transaction.populate(message, signatures)
        };
      }
      /**
       * Fetch parsed transaction details for a confirmed transaction
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.
       */
      async getParsedConfirmedTransaction(signature2, commitment) {
        const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
        const unsafeRes = await this._rpcRequest("getConfirmedTransaction", args);
        const res = create(unsafeRes, GetParsedTransactionRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
        }
        return res.result;
      }
      /**
       * Fetch parsed transaction details for a batch of confirmed transactions
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.
       */
      async getParsedConfirmedTransactions(signatures, commitment) {
        const batch = signatures.map((signature2) => {
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
          return {
            methodName: "getConfirmedTransaction",
            args
          };
        });
        const unsafeRes = await this._rpcBatchRequest(batch);
        const res = unsafeRes.map((unsafeRes2) => {
          const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
          if ("error" in res2) {
            throw new SolanaJSONRPCError(res2.error, "failed to get confirmed transactions");
          }
          return res2.result;
        });
        return res;
      }
      /**
       * Fetch a list of all the confirmed signatures for transactions involving an address
       * within a specified slot range. Max range allowed is 10,000 slots.
       *
       * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
       *
       * @param address queried address
       * @param startSlot start slot, inclusive
       * @param endSlot end slot, inclusive
       */
      async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
        let options = {};
        let firstAvailableBlock = await this.getFirstAvailableBlock();
        while (!("until" in options)) {
          startSlot--;
          if (startSlot <= 0 || startSlot < firstAvailableBlock) {
            break;
          }
          try {
            const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
            if (block.signatures.length > 0) {
              options.until = block.signatures[block.signatures.length - 1].toString();
            }
          } catch (err2) {
            if (err2 instanceof Error && err2.message.includes("skipped")) {
              continue;
            } else {
              throw err2;
            }
          }
        }
        let highestConfirmedRoot = await this.getSlot("finalized");
        while (!("before" in options)) {
          endSlot++;
          if (endSlot > highestConfirmedRoot) {
            break;
          }
          try {
            const block = await this.getConfirmedBlockSignatures(endSlot);
            if (block.signatures.length > 0) {
              options.before = block.signatures[block.signatures.length - 1].toString();
            }
          } catch (err2) {
            if (err2 instanceof Error && err2.message.includes("skipped")) {
              continue;
            } else {
              throw err2;
            }
          }
        }
        const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
        return confirmedSignatureInfo.map((info) => info.signature);
      }
      /**
       * Returns confirmed signatures for transactions involving an
       * address backwards in time from the provided signature or most recent confirmed block
       *
       *
       * @param address queried address
       * @param options
       */
      async getConfirmedSignaturesForAddress2(address, options, commitment) {
        const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
        const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
        const res = create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
        }
        return res.result;
      }
      /**
       * Returns confirmed signatures for transactions involving an
       * address backwards in time from the provided signature or most recent confirmed block
       *
       *
       * @param address queried address
       * @param options
       */
      async getSignaturesForAddress(address, options, commitment) {
        const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
        const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
        const res = create(unsafeRes, GetSignaturesForAddressRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
        }
        return res.result;
      }
      async getAddressLookupTable(accountKey, config) {
        const {
          context,
          value: accountInfo
        } = await this.getAccountInfoAndContext(accountKey, config);
        let value = null;
        if (accountInfo !== null) {
          value = new AddressLookupTableAccount({
            key: accountKey,
            state: AddressLookupTableAccount.deserialize(accountInfo.data)
          });
        }
        return {
          context,
          value
        };
      }
      /**
       * Fetch the contents of a Nonce account from the cluster, return with context
       */
      async getNonceAndContext(nonceAccount, commitmentOrConfig) {
        const {
          context,
          value: accountInfo
        } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
        let value = null;
        if (accountInfo !== null) {
          value = NonceAccount.fromAccountData(accountInfo.data);
        }
        return {
          context,
          value
        };
      }
      /**
       * Fetch the contents of a Nonce account from the cluster
       */
      async getNonce(nonceAccount, commitmentOrConfig) {
        return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x) => x.value).catch((e) => {
          throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e);
        });
      }
      /**
       * Request an allocation of lamports to the specified address
       *
       * ```typescript
       * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
       *
       * (async () => {
       *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
       *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
       *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
       *   await connection.confirmTransaction(signature);
       * })();
       * ```
       */
      async requestAirdrop(to, lamports) {
        const unsafeRes = await this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]);
        const res = create(unsafeRes, RequestAirdropRpcResult);
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
        }
        return res.result;
      }
      /**
       * @internal
       */
      async _blockhashWithExpiryBlockHeight(disableCache) {
        if (!disableCache) {
          while (this._pollingBlockhash) {
            await sleep(100);
          }
          const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
          const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
          if (this._blockhashInfo.latestBlockhash !== null && !expired) {
            return this._blockhashInfo.latestBlockhash;
          }
        }
        return await this._pollNewBlockhash();
      }
      /**
       * @internal
       */
      async _pollNewBlockhash() {
        this._pollingBlockhash = true;
        try {
          const startTime = Date.now();
          const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
          const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
          for (let i = 0; i < 50; i++) {
            const latestBlockhash = await this.getLatestBlockhash("finalized");
            if (cachedBlockhash !== latestBlockhash.blockhash) {
              this._blockhashInfo = {
                latestBlockhash,
                lastFetch: Date.now(),
                transactionSignatures: [],
                simulatedSignatures: []
              };
              return latestBlockhash;
            }
            await sleep(MS_PER_SLOT / 2);
          }
          throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
        } finally {
          this._pollingBlockhash = false;
        }
      }
      /**
       * get the stake minimum delegation
       */
      async getStakeMinimumDelegation(config) {
        const {
          commitment,
          config: configArg
        } = extractCommitmentFromConfig(config);
        const args = this._buildArgs([], commitment, "base64", configArg);
        const unsafeRes = await this._rpcRequest("getStakeMinimumDelegation", args);
        const res = create(unsafeRes, jsonRpcResultAndContext(number2()));
        if ("error" in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
        }
        return res.result;
      }
      /**
       * Simulate a transaction
       *
       * @deprecated Instead, call {@link simulateTransaction} with {@link
       * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
       */
      /**
       * Simulate a transaction
       */
      // eslint-disable-next-line no-dupe-class-members
      async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
        if ("message" in transactionOrMessage) {
          const versionedTx = transactionOrMessage;
          const wireTransaction2 = versionedTx.serialize();
          const encodedTransaction2 = import_buffer.Buffer.from(wireTransaction2).toString("base64");
          if (Array.isArray(configOrSigners) || includeAccounts !== void 0) {
            throw new Error("Invalid arguments");
          }
          const config2 = configOrSigners || {};
          config2.encoding = "base64";
          if (!("commitment" in config2)) {
            config2.commitment = this.commitment;
          }
          const args2 = [encodedTransaction2, config2];
          const unsafeRes2 = await this._rpcRequest("simulateTransaction", args2);
          const res2 = create(unsafeRes2, SimulatedTransactionResponseStruct);
          if ("error" in res2) {
            throw new Error("failed to simulate transaction: " + res2.error.message);
          }
          return res2.result;
        }
        let transaction;
        if (transactionOrMessage instanceof Transaction) {
          let originalTx = transactionOrMessage;
          transaction = new Transaction();
          transaction.feePayer = originalTx.feePayer;
          transaction.instructions = transactionOrMessage.instructions;
          transaction.nonceInfo = originalTx.nonceInfo;
          transaction.signatures = originalTx.signatures;
        } else {
          transaction = Transaction.populate(transactionOrMessage);
          transaction._message = transaction._json = void 0;
        }
        if (configOrSigners !== void 0 && !Array.isArray(configOrSigners)) {
          throw new Error("Invalid arguments");
        }
        const signers = configOrSigners;
        if (transaction.nonceInfo && signers) {
          transaction.sign(...signers);
        } else {
          let disableCache = this._disableBlockhashCaching;
          for (; ; ) {
            const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
            transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
            transaction.recentBlockhash = latestBlockhash.blockhash;
            if (!signers)
              break;
            transaction.sign(...signers);
            if (!transaction.signature) {
              throw new Error("!signature");
            }
            const signature2 = transaction.signature.toString("base64");
            if (!this._blockhashInfo.simulatedSignatures.includes(signature2) && !this._blockhashInfo.transactionSignatures.includes(signature2)) {
              this._blockhashInfo.simulatedSignatures.push(signature2);
              break;
            } else {
              disableCache = true;
            }
          }
        }
        const message = transaction._compile();
        const signData = message.serialize();
        const wireTransaction = transaction._serialize(signData);
        const encodedTransaction = wireTransaction.toString("base64");
        const config = {
          encoding: "base64",
          commitment: this.commitment
        };
        if (includeAccounts) {
          const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
          config["accounts"] = {
            encoding: "base64",
            addresses
          };
        }
        if (signers) {
          config.sigVerify = true;
        }
        const args = [encodedTransaction, config];
        const unsafeRes = await this._rpcRequest("simulateTransaction", args);
        const res = create(unsafeRes, SimulatedTransactionResponseStruct);
        if ("error" in res) {
          let logs;
          if ("data" in res.error) {
            logs = res.error.data.logs;
            if (logs && Array.isArray(logs)) {
              const traceIndent = "\n    ";
              const logTrace = traceIndent + logs.join(traceIndent);
              console.error(res.error.message, logTrace);
            }
          }
          throw new SendTransactionError("failed to simulate transaction: " + res.error.message, logs);
        }
        return res.result;
      }
      /**
       * Sign and send a transaction
       *
       * @deprecated Instead, call {@link sendTransaction} with a {@link
       * VersionedTransaction}
       */
      /**
       * Sign and send a transaction
       */
      // eslint-disable-next-line no-dupe-class-members
      async sendTransaction(transaction, signersOrOptions, options) {
        if ("version" in transaction) {
          if (signersOrOptions && Array.isArray(signersOrOptions)) {
            throw new Error("Invalid arguments");
          }
          const wireTransaction2 = transaction.serialize();
          return await this.sendRawTransaction(wireTransaction2, signersOrOptions);
        }
        if (signersOrOptions === void 0 || !Array.isArray(signersOrOptions)) {
          throw new Error("Invalid arguments");
        }
        const signers = signersOrOptions;
        if (transaction.nonceInfo) {
          transaction.sign(...signers);
        } else {
          let disableCache = this._disableBlockhashCaching;
          for (; ; ) {
            const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
            transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
            transaction.recentBlockhash = latestBlockhash.blockhash;
            transaction.sign(...signers);
            if (!transaction.signature) {
              throw new Error("!signature");
            }
            const signature2 = transaction.signature.toString("base64");
            if (!this._blockhashInfo.transactionSignatures.includes(signature2)) {
              this._blockhashInfo.transactionSignatures.push(signature2);
              break;
            } else {
              disableCache = true;
            }
          }
        }
        const wireTransaction = transaction.serialize();
        return await this.sendRawTransaction(wireTransaction, options);
      }
      /**
       * Send a transaction that has already been signed and serialized into the
       * wire format
       */
      async sendRawTransaction(rawTransaction, options) {
        const encodedTransaction = toBuffer(rawTransaction).toString("base64");
        const result = await this.sendEncodedTransaction(encodedTransaction, options);
        return result;
      }
      /**
       * Send a transaction that has already been signed, serialized into the
       * wire format, and encoded as a base64 string
       */
      async sendEncodedTransaction(encodedTransaction, options) {
        const config = {
          encoding: "base64"
        };
        const skipPreflight = options && options.skipPreflight;
        const preflightCommitment = options && options.preflightCommitment || this.commitment;
        if (options && options.maxRetries != null) {
          config.maxRetries = options.maxRetries;
        }
        if (options && options.minContextSlot != null) {
          config.minContextSlot = options.minContextSlot;
        }
        if (skipPreflight) {
          config.skipPreflight = skipPreflight;
        }
        if (preflightCommitment) {
          config.preflightCommitment = preflightCommitment;
        }
        const args = [encodedTransaction, config];
        const unsafeRes = await this._rpcRequest("sendTransaction", args);
        const res = create(unsafeRes, SendTransactionRpcResult);
        if ("error" in res) {
          let logs;
          if ("data" in res.error) {
            logs = res.error.data.logs;
          }
          throw new SendTransactionError("failed to send transaction: " + res.error.message, logs);
        }
        return res.result;
      }
      /**
       * @internal
       */
      _wsOnOpen() {
        this._rpcWebSocketConnected = true;
        this._rpcWebSocketHeartbeat = setInterval(() => {
          (async () => {
            try {
              await this._rpcWebSocket.notify("ping");
            } catch {
            }
          })();
        }, 5e3);
        this._updateSubscriptions();
      }
      /**
       * @internal
       */
      _wsOnError(err2) {
        this._rpcWebSocketConnected = false;
        console.error("ws error:", err2.message);
      }
      /**
       * @internal
       */
      _wsOnClose(code) {
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
        if (this._rpcWebSocketIdleTimeout) {
          clearTimeout(this._rpcWebSocketIdleTimeout);
          this._rpcWebSocketIdleTimeout = null;
        }
        if (this._rpcWebSocketHeartbeat) {
          clearInterval(this._rpcWebSocketHeartbeat);
          this._rpcWebSocketHeartbeat = null;
        }
        if (code === 1e3) {
          this._updateSubscriptions();
          return;
        }
        this._subscriptionCallbacksByServerSubscriptionId = {};
        Object.entries(this._subscriptionsByHash).forEach(([hash3, subscription]) => {
          this._setSubscription(hash3, {
            ...subscription,
            state: "pending"
          });
        });
      }
      /**
       * @internal
       */
      _setSubscription(hash3, nextSubscription) {
        var _a;
        const prevState = (_a = this._subscriptionsByHash[hash3]) == null ? void 0 : _a.state;
        this._subscriptionsByHash[hash3] = nextSubscription;
        if (prevState !== nextSubscription.state) {
          const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash3];
          if (stateChangeCallbacks) {
            stateChangeCallbacks.forEach((cb) => {
              try {
                cb(nextSubscription.state);
              } catch {
              }
            });
          }
        }
      }
      /**
       * @internal
       */
      _onSubscriptionStateChange(clientSubscriptionId, callback) {
        var _this$_subscriptionSt;
        const hash3 = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
        if (hash3 == null) {
          return () => {
          };
        }
        const stateChangeCallbacks = (_this$_subscriptionSt = this._subscriptionStateChangeCallbacksByHash)[hash3] || (_this$_subscriptionSt[hash3] = /* @__PURE__ */ new Set());
        stateChangeCallbacks.add(callback);
        return () => {
          stateChangeCallbacks.delete(callback);
          if (stateChangeCallbacks.size === 0) {
            delete this._subscriptionStateChangeCallbacksByHash[hash3];
          }
        };
      }
      /**
       * @internal
       */
      async _updateSubscriptions() {
        if (Object.keys(this._subscriptionsByHash).length === 0) {
          if (this._rpcWebSocketConnected) {
            this._rpcWebSocketConnected = false;
            this._rpcWebSocketIdleTimeout = setTimeout(() => {
              this._rpcWebSocketIdleTimeout = null;
              try {
                this._rpcWebSocket.close();
              } catch (err2) {
                if (err2 instanceof Error) {
                  console.log(`Error when closing socket connection: ${err2.message}`);
                }
              }
            }, 500);
          }
          return;
        }
        if (this._rpcWebSocketIdleTimeout !== null) {
          clearTimeout(this._rpcWebSocketIdleTimeout);
          this._rpcWebSocketIdleTimeout = null;
          this._rpcWebSocketConnected = true;
        }
        if (!this._rpcWebSocketConnected) {
          this._rpcWebSocket.connect();
          return;
        }
        const activeWebSocketGeneration = this._rpcWebSocketGeneration;
        const isCurrentConnectionStillActive = () => {
          return activeWebSocketGeneration === this._rpcWebSocketGeneration;
        };
        await Promise.all(
          // Don't be tempted to change this to `Object.entries`. We call
          // `_updateSubscriptions` recursively when processing the state,
          // so it's important that we look up the *current* version of
          // each subscription, every time we process a hash.
          Object.keys(this._subscriptionsByHash).map(async (hash3) => {
            const subscription = this._subscriptionsByHash[hash3];
            if (subscription === void 0) {
              return;
            }
            switch (subscription.state) {
              case "pending":
              case "unsubscribed":
                if (subscription.callbacks.size === 0) {
                  delete this._subscriptionsByHash[hash3];
                  if (subscription.state === "unsubscribed") {
                    delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
                  }
                  await this._updateSubscriptions();
                  return;
                }
                await (async () => {
                  const {
                    args,
                    method: method2
                  } = subscription;
                  try {
                    this._setSubscription(hash3, {
                      ...subscription,
                      state: "subscribing"
                    });
                    const serverSubscriptionId = await this._rpcWebSocket.call(method2, args);
                    this._setSubscription(hash3, {
                      ...subscription,
                      serverSubscriptionId,
                      state: "subscribed"
                    });
                    this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                    await this._updateSubscriptions();
                  } catch (e) {
                    if (e instanceof Error) {
                      console.error(`${method2} error for argument`, args, e.message);
                    }
                    if (!isCurrentConnectionStillActive()) {
                      return;
                    }
                    this._setSubscription(hash3, {
                      ...subscription,
                      state: "pending"
                    });
                    await this._updateSubscriptions();
                  }
                })();
                break;
              case "subscribed":
                if (subscription.callbacks.size === 0) {
                  await (async () => {
                    const {
                      serverSubscriptionId,
                      unsubscribeMethod
                    } = subscription;
                    if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                      this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                    } else {
                      this._setSubscription(hash3, {
                        ...subscription,
                        state: "unsubscribing"
                      });
                      this._setSubscription(hash3, {
                        ...subscription,
                        state: "unsubscribing"
                      });
                      try {
                        await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                      } catch (e) {
                        if (e instanceof Error) {
                          console.error(`${unsubscribeMethod} error:`, e.message);
                        }
                        if (!isCurrentConnectionStillActive()) {
                          return;
                        }
                        this._setSubscription(hash3, {
                          ...subscription,
                          state: "subscribed"
                        });
                        await this._updateSubscriptions();
                        return;
                      }
                    }
                    this._setSubscription(hash3, {
                      ...subscription,
                      state: "unsubscribed"
                    });
                    await this._updateSubscriptions();
                  })();
                }
                break;
            }
          })
        );
      }
      /**
       * @internal
       */
      _handleServerNotification(serverSubscriptionId, callbackArgs) {
        const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
        if (callbacks === void 0) {
          return;
        }
        callbacks.forEach((cb) => {
          try {
            cb(
              ...callbackArgs
            );
          } catch (e) {
            console.error(e);
          }
        });
      }
      /**
       * @internal
       */
      _wsOnAccountNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, AccountNotificationResult);
        this._handleServerNotification(subscription, [result.value, result.context]);
      }
      /**
       * @internal
       */
      _makeSubscription(subscriptionConfig, args) {
        const clientSubscriptionId = this._nextClientSubscriptionId++;
        const hash3 = fastStableStringify$1([subscriptionConfig.method, args]);
        const existingSubscription = this._subscriptionsByHash[hash3];
        if (existingSubscription === void 0) {
          this._subscriptionsByHash[hash3] = {
            ...subscriptionConfig,
            args,
            callbacks: /* @__PURE__ */ new Set([subscriptionConfig.callback]),
            state: "pending"
          };
        } else {
          existingSubscription.callbacks.add(subscriptionConfig.callback);
        }
        this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash3;
        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
          delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
          delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
          const subscription = this._subscriptionsByHash[hash3];
          assert3(subscription !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
          subscription.callbacks.delete(subscriptionConfig.callback);
          await this._updateSubscriptions();
        };
        this._updateSubscriptions();
        return clientSubscriptionId;
      }
      /**
       * Register a callback to be invoked whenever the specified account changes
       *
       * @param publicKey Public key of the account to monitor
       * @param callback Function to invoke whenever the account is changed
       * @param commitment Specify the commitment level account changes must reach before notification
       * @return subscription id
       */
      onAccountChange(publicKey4, callback, commitment) {
        const args = this._buildArgs(
          [publicKey4.toBase58()],
          commitment || this._commitment || "finalized",
          // Apply connection/server default.
          "base64"
        );
        return this._makeSubscription({
          callback,
          method: "accountSubscribe",
          unsubscribeMethod: "accountUnsubscribe"
        }, args);
      }
      /**
       * Deregister an account notification callback
       *
       * @param id client subscription id to deregister
       */
      async removeAccountChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
      }
      /**
       * @internal
       */
      _wsOnProgramAccountNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, ProgramAccountNotificationResult);
        this._handleServerNotification(subscription, [{
          accountId: result.value.pubkey,
          accountInfo: result.value.account
        }, result.context]);
      }
      /**
       * Register a callback to be invoked whenever accounts owned by the
       * specified program change
       *
       * @param programId Public key of the program to monitor
       * @param callback Function to invoke whenever the account is changed
       * @param commitment Specify the commitment level account changes must reach before notification
       * @param filters The program account filters to pass into the RPC method
       * @return subscription id
       */
      onProgramAccountChange(programId, callback, commitment, filters) {
        const args = this._buildArgs(
          [programId.toBase58()],
          commitment || this._commitment || "finalized",
          // Apply connection/server default.
          "base64",
          filters ? {
            filters
          } : void 0
          /* extra */
        );
        return this._makeSubscription({
          callback,
          method: "programSubscribe",
          unsubscribeMethod: "programUnsubscribe"
        }, args);
      }
      /**
       * Deregister an account notification callback
       *
       * @param id client subscription id to deregister
       */
      async removeProgramAccountChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
      }
      /**
       * Registers a callback to be invoked whenever logs are emitted.
       */
      onLogs(filter, callback, commitment) {
        const args = this._buildArgs(
          [typeof filter === "object" ? {
            mentions: [filter.toString()]
          } : filter],
          commitment || this._commitment || "finalized"
          // Apply connection/server default.
        );
        return this._makeSubscription({
          callback,
          method: "logsSubscribe",
          unsubscribeMethod: "logsUnsubscribe"
        }, args);
      }
      /**
       * Deregister a logs callback.
       *
       * @param id client subscription id to deregister.
       */
      async removeOnLogsListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
      }
      /**
       * @internal
       */
      _wsOnLogsNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, LogsNotificationResult);
        this._handleServerNotification(subscription, [result.value, result.context]);
      }
      /**
       * @internal
       */
      _wsOnSlotNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, SlotNotificationResult);
        this._handleServerNotification(subscription, [result]);
      }
      /**
       * Register a callback to be invoked upon slot changes
       *
       * @param callback Function to invoke whenever the slot changes
       * @return subscription id
       */
      onSlotChange(callback) {
        return this._makeSubscription(
          {
            callback,
            method: "slotSubscribe",
            unsubscribeMethod: "slotUnsubscribe"
          },
          []
          /* args */
        );
      }
      /**
       * Deregister a slot notification callback
       *
       * @param id client subscription id to deregister
       */
      async removeSlotChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
      }
      /**
       * @internal
       */
      _wsOnSlotUpdatesNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, SlotUpdateNotificationResult);
        this._handleServerNotification(subscription, [result]);
      }
      /**
       * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
       * may be useful to track live progress of a cluster.
       *
       * @param callback Function to invoke whenever the slot updates
       * @return subscription id
       */
      onSlotUpdate(callback) {
        return this._makeSubscription(
          {
            callback,
            method: "slotsUpdatesSubscribe",
            unsubscribeMethod: "slotsUpdatesUnsubscribe"
          },
          []
          /* args */
        );
      }
      /**
       * Deregister a slot update notification callback
       *
       * @param id client subscription id to deregister
       */
      async removeSlotUpdateListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
      }
      /**
       * @internal
       */
      async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
        const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
        if (dispose) {
          await dispose();
        } else {
          console.warn(`Ignored unsubscribe request because an active subscription with id \`${clientSubscriptionId}\` for '${subscriptionName}' events could not be found.`);
        }
      }
      _buildArgs(args, override, encoding, extra) {
        const commitment = override || this._commitment;
        if (commitment || encoding || extra) {
          let options = {};
          if (encoding) {
            options.encoding = encoding;
          }
          if (commitment) {
            options.commitment = commitment;
          }
          if (extra) {
            options = Object.assign(options, extra);
          }
          args.push(options);
        }
        return args;
      }
      /**
       * @internal
       */
      _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
        const commitment = override || this._commitment;
        if (commitment && !["confirmed", "finalized"].includes(commitment)) {
          throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
        }
        return this._buildArgs(args, override, encoding, extra);
      }
      /**
       * @internal
       */
      _wsOnSignatureNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, SignatureNotificationResult);
        if (result.value !== "receivedSignature") {
          this._subscriptionsAutoDisposedByRpc.add(subscription);
        }
        this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{
          type: "received"
        }, result.context] : [{
          type: "status",
          result: result.value
        }, result.context]);
      }
      /**
       * Register a callback to be invoked upon signature updates
       *
       * @param signature Transaction signature string in base 58
       * @param callback Function to invoke on signature notifications
       * @param commitment Specify the commitment level signature must reach before notification
       * @return subscription id
       */
      onSignature(signature2, callback, commitment) {
        const args = this._buildArgs(
          [signature2],
          commitment || this._commitment || "finalized"
          // Apply connection/server default.
        );
        const clientSubscriptionId = this._makeSubscription({
          callback: (notification, context) => {
            if (notification.type === "status") {
              callback(notification.result, context);
              try {
                this.removeSignatureListener(clientSubscriptionId);
              } catch (_err) {
              }
            }
          },
          method: "signatureSubscribe",
          unsubscribeMethod: "signatureUnsubscribe"
        }, args);
        return clientSubscriptionId;
      }
      /**
       * Register a callback to be invoked when a transaction is
       * received and/or processed.
       *
       * @param signature Transaction signature string in base 58
       * @param callback Function to invoke on signature notifications
       * @param options Enable received notifications and set the commitment
       *   level that signature must reach before notification
       * @return subscription id
       */
      onSignatureWithOptions(signature2, callback, options) {
        const {
          commitment,
          ...extra
        } = {
          ...options,
          commitment: options && options.commitment || this._commitment || "finalized"
          // Apply connection/server default.
        };
        const args = this._buildArgs([signature2], commitment, void 0, extra);
        const clientSubscriptionId = this._makeSubscription({
          callback: (notification, context) => {
            callback(notification, context);
            try {
              this.removeSignatureListener(clientSubscriptionId);
            } catch (_err) {
            }
          },
          method: "signatureSubscribe",
          unsubscribeMethod: "signatureUnsubscribe"
        }, args);
        return clientSubscriptionId;
      }
      /**
       * Deregister a signature notification callback
       *
       * @param id client subscription id to deregister
       */
      async removeSignatureListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
      }
      /**
       * @internal
       */
      _wsOnRootNotification(notification) {
        const {
          result,
          subscription
        } = create(notification, RootNotificationResult);
        this._handleServerNotification(subscription, [result]);
      }
      /**
       * Register a callback to be invoked upon root changes
       *
       * @param callback Function to invoke whenever the root changes
       * @return subscription id
       */
      onRootChange(callback) {
        return this._makeSubscription(
          {
            callback,
            method: "rootSubscribe",
            unsubscribeMethod: "rootUnsubscribe"
          },
          []
          /* args */
        );
      }
      /**
       * Deregister a root notification callback
       *
       * @param id client subscription id to deregister
       */
      async removeRootChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
      }
    };
    Keypair = class {
      /**
       * Create a new keypair instance.
       * Generate random keypair if no {@link Ed25519Keypair} is provided.
       *
       * @param keypair ed25519 keypair
       */
      constructor(keypair) {
        this._keypair = void 0;
        this._keypair = keypair ?? generateKeypair();
      }
      /**
       * Generate a new random keypair
       */
      static generate() {
        return new Keypair(generateKeypair());
      }
      /**
       * Create a keypair from a raw secret key byte array.
       *
       * This method should only be used to recreate a keypair from a previously
       * generated secret key. Generating keypairs from a random seed should be done
       * with the {@link Keypair.fromSeed} method.
       *
       * @throws error if the provided secret key is invalid and validation is not skipped.
       *
       * @param secretKey secret key byte array
       * @param options: skip secret key validation
       */
      static fromSecretKey(secretKey, options) {
        if (secretKey.byteLength !== 64) {
          throw new Error("bad secret key size");
        }
        const publicKey4 = secretKey.slice(32, 64);
        if (!options || !options.skipValidation) {
          const privateScalar = secretKey.slice(0, 32);
          const computedPublicKey = getPublicKey2(privateScalar);
          for (let ii = 0; ii < 32; ii++) {
            if (publicKey4[ii] !== computedPublicKey[ii]) {
              throw new Error("provided secretKey is invalid");
            }
          }
        }
        return new Keypair({
          publicKey: publicKey4,
          secretKey
        });
      }
      /**
       * Generate a keypair from a 32 byte seed.
       *
       * @param seed seed byte array
       */
      static fromSeed(seed2) {
        const publicKey4 = getPublicKey2(seed2);
        const secretKey = new Uint8Array(64);
        secretKey.set(seed2);
        secretKey.set(publicKey4, 32);
        return new Keypair({
          publicKey: publicKey4,
          secretKey
        });
      }
      /**
       * The public key for this keypair
       */
      get publicKey() {
        return new PublicKey(this._keypair.publicKey);
      }
      /**
       * The raw secret key for this keypair
       */
      get secretKey() {
        return new Uint8Array(this._keypair.secretKey);
      }
    };
    LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
      CreateLookupTable: {
        index: 0,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("recentSlot"), BufferLayout.u8("bumpSeed")])
      },
      FreezeLookupTable: {
        index: 1,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      },
      ExtendLookupTable: {
        index: 2,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642(), BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u32(), -8), "addresses")])
      },
      DeactivateLookupTable: {
        index: 3,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      },
      CloseLookupTable: {
        index: 4,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      }
    });
    AddressLookupTableInstruction = class {
      /**
       * @internal
       */
      constructor() {
      }
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout.u32("instruction");
        const index2 = instructionTypeLayout.decode(instruction.data);
        let type3;
        for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) {
          if (layout.index == index2) {
            type3 = layoutType;
            break;
          }
        }
        if (!type3) {
          throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
        }
        return type3;
      }
      static decodeCreateLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 4);
        const {
          recentSlot
        } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);
        return {
          authority: instruction.keys[1].pubkey,
          payer: instruction.keys[2].pubkey,
          recentSlot: Number(recentSlot)
        };
      }
      static decodeExtendLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        if (instruction.keys.length < 2) {
          throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);
        }
        const {
          addresses
        } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey,
          payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : void 0,
          addresses: addresses.map((buffer) => new PublicKey(buffer))
        };
      }
      static decodeCloseLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 3);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey,
          recipient: instruction.keys[2].pubkey
        };
      }
      static decodeFreezeLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 2);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey
        };
      }
      static decodeDeactivateLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 2);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey
        };
      }
      /**
       * @internal
       */
      static checkProgramId(programId) {
        if (!programId.equals(AddressLookupTableProgram.programId)) {
          throw new Error("invalid instruction; programId is not AddressLookupTable Program");
        }
      }
      /**
       * @internal
       */
      static checkKeysLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
        }
      }
    };
    AddressLookupTableProgram = class {
      /**
       * @internal
       */
      constructor() {
      }
      static createLookupTable(params) {
        const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), (0, import_bigint_buffer.toBufferLE)(BigInt(params.recentSlot), 8)], this.programId);
        const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
        const data = encodeData(type3, {
          recentSlot: BigInt(params.recentSlot),
          bumpSeed
        });
        const keys = [{
          pubkey: lookupTableAddress,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: params.payer,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SystemProgram.programId,
          isSigner: false,
          isWritable: false
        }];
        return [new TransactionInstruction({
          programId: this.programId,
          keys,
          data
        }), lookupTableAddress];
      }
      static freezeLookupTable(params) {
        const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
        const data = encodeData(type3);
        const keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }];
        return new TransactionInstruction({
          programId: this.programId,
          keys,
          data
        });
      }
      static extendLookupTable(params) {
        const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
        const data = encodeData(type3, {
          addresses: params.addresses.map((addr) => addr.toBytes())
        });
        const keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }];
        if (params.payer) {
          keys.push({
            pubkey: params.payer,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false
          });
        }
        return new TransactionInstruction({
          programId: this.programId,
          keys,
          data
        });
      }
      static deactivateLookupTable(params) {
        const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
        const data = encodeData(type3);
        const keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }];
        return new TransactionInstruction({
          programId: this.programId,
          keys,
          data
        });
      }
      static closeLookupTable(params) {
        const type3 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
        const data = encodeData(type3);
        const keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: params.recipient,
          isSigner: false,
          isWritable: true
        }];
        return new TransactionInstruction({
          programId: this.programId,
          keys,
          data
        });
      }
    };
    AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
    ComputeBudgetInstruction = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Decode a compute budget instruction and retrieve the instruction type.
       */
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout.u8("instruction");
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type3;
        for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)) {
          if (layout.index == typeIndex) {
            type3 = ixType;
            break;
          }
        }
        if (!type3) {
          throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
        }
        return type3;
      }
      /**
       * Decode request units compute budget instruction and retrieve the instruction params.
       */
      static decodeRequestUnits(instruction) {
        this.checkProgramId(instruction.programId);
        const {
          units,
          additionalFee
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);
        return {
          units,
          additionalFee
        };
      }
      /**
       * Decode request heap frame compute budget instruction and retrieve the instruction params.
       */
      static decodeRequestHeapFrame(instruction) {
        this.checkProgramId(instruction.programId);
        const {
          bytes: bytes2
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);
        return {
          bytes: bytes2
        };
      }
      /**
       * Decode set compute unit limit compute budget instruction and retrieve the instruction params.
       */
      static decodeSetComputeUnitLimit(instruction) {
        this.checkProgramId(instruction.programId);
        const {
          units
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);
        return {
          units
        };
      }
      /**
       * Decode set compute unit price compute budget instruction and retrieve the instruction params.
       */
      static decodeSetComputeUnitPrice(instruction) {
        this.checkProgramId(instruction.programId);
        const {
          microLamports
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);
        return {
          microLamports
        };
      }
      /**
       * @internal
       */
      static checkProgramId(programId) {
        if (!programId.equals(ComputeBudgetProgram.programId)) {
          throw new Error("invalid instruction; programId is not ComputeBudgetProgram");
        }
      }
    };
    COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
      RequestUnits: {
        index: 0,
        layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units"), BufferLayout.u32("additionalFee")])
      },
      RequestHeapFrame: {
        index: 1,
        layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("bytes")])
      },
      SetComputeUnitLimit: {
        index: 2,
        layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units")])
      },
      SetComputeUnitPrice: {
        index: 3,
        layout: BufferLayout.struct([BufferLayout.u8("instruction"), u642("microLamports")])
      }
    });
    ComputeBudgetProgram = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Public key that identifies the Compute Budget program
       */
      /**
       * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
       */
      static requestUnits(params) {
        const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
        const data = encodeData(type3, params);
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data
        });
      }
      static requestHeapFrame(params) {
        const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
        const data = encodeData(type3, params);
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data
        });
      }
      static setComputeUnitLimit(params) {
        const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
        const data = encodeData(type3, params);
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data
        });
      }
      static setComputeUnitPrice(params) {
        const type3 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
        const data = encodeData(type3, {
          microLamports: BigInt(params.microLamports)
        });
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data
        });
      }
    };
    ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
    PRIVATE_KEY_BYTES$1 = 64;
    PUBLIC_KEY_BYTES$1 = 32;
    SIGNATURE_BYTES = 64;
    ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u8("padding"), BufferLayout.u16("signatureOffset"), BufferLayout.u16("signatureInstructionIndex"), BufferLayout.u16("publicKeyOffset"), BufferLayout.u16("publicKeyInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u16("messageInstructionIndex")]);
    Ed25519Program = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Public key that identifies the ed25519 program
       */
      /**
       * Create an ed25519 instruction with a public key and signature. The
       * public key must be a buffer that is 32 bytes long, and the signature
       * must be a buffer of 64 bytes.
       */
      static createInstructionWithPublicKey(params) {
        const {
          publicKey: publicKey4,
          message,
          signature: signature2,
          instructionIndex
        } = params;
        assert3(publicKey4.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey4.length} bytes`);
        assert3(signature2.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature2.length} bytes`);
        const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
        const signatureOffset = publicKeyOffset + publicKey4.length;
        const messageDataOffset = signatureOffset + signature2.length;
        const numSignatures = 1;
        const instructionData = import_buffer.Buffer.alloc(messageDataOffset + message.length);
        const index2 = instructionIndex == null ? 65535 : instructionIndex;
        ED25519_INSTRUCTION_LAYOUT.encode({
          numSignatures,
          padding: 0,
          signatureOffset,
          signatureInstructionIndex: index2,
          publicKeyOffset,
          publicKeyInstructionIndex: index2,
          messageDataOffset,
          messageDataSize: message.length,
          messageInstructionIndex: index2
        }, instructionData);
        instructionData.fill(publicKey4, publicKeyOffset);
        instructionData.fill(signature2, signatureOffset);
        instructionData.fill(message, messageDataOffset);
        return new TransactionInstruction({
          keys: [],
          programId: Ed25519Program.programId,
          data: instructionData
        });
      }
      /**
       * Create an ed25519 instruction with a private key. The private key
       * must be a buffer that is 64 bytes long.
       */
      static createInstructionWithPrivateKey(params) {
        const {
          privateKey,
          message,
          instructionIndex
        } = params;
        assert3(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
        try {
          const keypair = Keypair.fromSecretKey(privateKey);
          const publicKey4 = keypair.publicKey.toBytes();
          const signature2 = sign(message, keypair.secretKey);
          return this.createInstructionWithPublicKey({
            publicKey: publicKey4,
            message,
            signature: signature2,
            instructionIndex
          });
        } catch (error) {
          throw new Error(`Error creating instruction; ${error}`);
        }
      }
    };
    Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
    utils2.hmacSha256Sync = (key, ...msgs) => {
      const h = hmac.create(sha256, key);
      msgs.forEach((msg) => h.update(msg));
      return h.digest();
    };
    ecdsaSign = (msgHash, privKey) => signSync2(msgHash, privKey, {
      der: false,
      recovered: true
    });
    utils2.isValidPrivateKey;
    publicKeyCreate = getPublicKey;
    PRIVATE_KEY_BYTES = 32;
    ETHEREUM_ADDRESS_BYTES = 20;
    PUBLIC_KEY_BYTES = 64;
    SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
    SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u16("signatureOffset"), BufferLayout.u8("signatureInstructionIndex"), BufferLayout.u16("ethAddressOffset"), BufferLayout.u8("ethAddressInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u8("messageInstructionIndex"), BufferLayout.blob(20, "ethAddress"), BufferLayout.blob(64, "signature"), BufferLayout.u8("recoveryId")]);
    Secp256k1Program = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Public key that identifies the secp256k1 program
       */
      /**
       * Construct an Ethereum address from a secp256k1 public key buffer.
       * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
       */
      static publicKeyToEthAddress(publicKey4) {
        assert3(publicKey4.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey4.length} bytes`);
        try {
          return import_buffer.Buffer.from(keccak_256(toBuffer(publicKey4))).slice(-ETHEREUM_ADDRESS_BYTES);
        } catch (error) {
          throw new Error(`Error constructing Ethereum address: ${error}`);
        }
      }
      /**
       * Create an secp256k1 instruction with a public key. The public key
       * must be a buffer that is 64 bytes long.
       */
      static createInstructionWithPublicKey(params) {
        const {
          publicKey: publicKey4,
          message,
          signature: signature2,
          recoveryId,
          instructionIndex
        } = params;
        return Secp256k1Program.createInstructionWithEthAddress({
          ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey4),
          message,
          signature: signature2,
          recoveryId,
          instructionIndex
        });
      }
      /**
       * Create an secp256k1 instruction with an Ethereum address. The address
       * must be a hex string or a buffer that is 20 bytes long.
       */
      static createInstructionWithEthAddress(params) {
        const {
          ethAddress: rawAddress,
          message,
          signature: signature2,
          recoveryId,
          instructionIndex = 0
        } = params;
        let ethAddress;
        if (typeof rawAddress === "string") {
          if (rawAddress.startsWith("0x")) {
            ethAddress = import_buffer.Buffer.from(rawAddress.substr(2), "hex");
          } else {
            ethAddress = import_buffer.Buffer.from(rawAddress, "hex");
          }
        } else {
          ethAddress = rawAddress;
        }
        assert3(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
        const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
        const ethAddressOffset = dataStart;
        const signatureOffset = dataStart + ethAddress.length;
        const messageDataOffset = signatureOffset + signature2.length + 1;
        const numSignatures = 1;
        const instructionData = import_buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
        SECP256K1_INSTRUCTION_LAYOUT.encode({
          numSignatures,
          signatureOffset,
          signatureInstructionIndex: instructionIndex,
          ethAddressOffset,
          ethAddressInstructionIndex: instructionIndex,
          messageDataOffset,
          messageDataSize: message.length,
          messageInstructionIndex: instructionIndex,
          signature: toBuffer(signature2),
          ethAddress: toBuffer(ethAddress),
          recoveryId
        }, instructionData);
        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
        return new TransactionInstruction({
          keys: [],
          programId: Secp256k1Program.programId,
          data: instructionData
        });
      }
      /**
       * Create an secp256k1 instruction with a private key. The private key
       * must be a buffer that is 32 bytes long.
       */
      static createInstructionWithPrivateKey(params) {
        const {
          privateKey: pkey,
          message,
          instructionIndex
        } = params;
        assert3(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
        try {
          const privateKey = toBuffer(pkey);
          const publicKey4 = publicKeyCreate(
            privateKey,
            false
            /* isCompressed */
          ).slice(1);
          const messageHash = import_buffer.Buffer.from(keccak_256(toBuffer(message)));
          const [signature2, recoveryId] = ecdsaSign(messageHash, privateKey);
          return this.createInstructionWithPublicKey({
            publicKey: publicKey4,
            message,
            signature: signature2,
            recoveryId,
            instructionIndex
          });
        } catch (error) {
          throw new Error(`Error creating instruction; ${error}`);
        }
      }
    };
    Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
    STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
    Authorized = class {
      /** stake authority */
      /** withdraw authority */
      /**
       * Create a new Authorized object
       * @param staker the stake authority
       * @param withdrawer the withdraw authority
       */
      constructor(staker, withdrawer) {
        this.staker = void 0;
        this.withdrawer = void 0;
        this.staker = staker;
        this.withdrawer = withdrawer;
      }
    };
    Lockup = class {
      /** Unix timestamp of lockup expiration */
      /** Epoch of lockup expiration */
      /** Lockup custodian authority */
      /**
       * Create a new Lockup object
       */
      constructor(unixTimestamp, epoch, custodian) {
        this.unixTimestamp = void 0;
        this.epoch = void 0;
        this.custodian = void 0;
        this.unixTimestamp = unixTimestamp;
        this.epoch = epoch;
        this.custodian = custodian;
      }
      /**
       * Default, inactive Lockup value
       */
    };
    Lockup.default = new Lockup(0, 0, PublicKey.default);
    StakeInstruction = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Decode a stake instruction and retrieve the instruction type.
       */
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout.u32("instruction");
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type3;
        for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) {
          if (layout.index == typeIndex) {
            type3 = ixType;
            break;
          }
        }
        if (!type3) {
          throw new Error("Instruction type incorrect; not a StakeInstruction");
        }
        return type3;
      }
      /**
       * Decode a initialize stake instruction and retrieve the instruction params.
       */
      static decodeInitialize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          authorized: authorized2,
          lockup: lockup2
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          authorized: new Authorized(new PublicKey(authorized2.staker), new PublicKey(authorized2.withdrawer)),
          lockup: new Lockup(lockup2.unixTimestamp, lockup2.epoch, new PublicKey(lockup2.custodian))
        };
      }
      /**
       * Decode a delegate stake instruction and retrieve the instruction params.
       */
      static decodeDelegate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 6);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          votePubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[5].pubkey
        };
      }
      /**
       * Decode an authorize stake instruction and retrieve the instruction params.
       */
      static decodeAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          newAuthorized,
          stakeAuthorizationType
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
        const o = {
          stakePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey,
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          stakeAuthorizationType: {
            index: stakeAuthorizationType
          }
        };
        if (instruction.keys.length > 3) {
          o.custodianPubkey = instruction.keys[3].pubkey;
        }
        return o;
      }
      /**
       * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
       */
      static decodeAuthorizeWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          newAuthorized,
          stakeAuthorizationType,
          authoritySeed,
          authorityOwner
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
        const o = {
          stakePubkey: instruction.keys[0].pubkey,
          authorityBase: instruction.keys[1].pubkey,
          authoritySeed,
          authorityOwner: new PublicKey(authorityOwner),
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          stakeAuthorizationType: {
            index: stakeAuthorizationType
          }
        };
        if (instruction.keys.length > 3) {
          o.custodianPubkey = instruction.keys[3].pubkey;
        }
        return o;
      }
      /**
       * Decode a split stake instruction and retrieve the instruction params.
       */
      static decodeSplit(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          lamports
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          splitStakePubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey,
          lamports
        };
      }
      /**
       * Decode a merge stake instruction and retrieve the instruction params.
       */
      static decodeMerge(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          sourceStakePubKey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[4].pubkey
        };
      }
      /**
       * Decode a withdraw stake instruction and retrieve the instruction params.
       */
      static decodeWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 5);
        const {
          lamports
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
        const o = {
          stakePubkey: instruction.keys[0].pubkey,
          toPubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[4].pubkey,
          lamports
        };
        if (instruction.keys.length > 5) {
          o.custodianPubkey = instruction.keys[5].pubkey;
        }
        return o;
      }
      /**
       * Decode a deactivate stake instruction and retrieve the instruction params.
       */
      static decodeDeactivate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey
        };
      }
      /**
       * @internal
       */
      static checkProgramId(programId) {
        if (!programId.equals(StakeProgram.programId)) {
          throw new Error("invalid instruction; programId is not StakeProgram");
        }
      }
      /**
       * @internal
       */
      static checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
        }
      }
    };
    STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
      Initialize: {
        index: 0,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), authorized(), lockup()])
      },
      Authorize: {
        index: 1,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType")])
      },
      Delegate: {
        index: 2,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      },
      Split: {
        index: 3,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
      },
      Withdraw: {
        index: 4,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
      },
      Deactivate: {
        index: 5,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      },
      Merge: {
        index: 7,
        layout: BufferLayout.struct([BufferLayout.u32("instruction")])
      },
      AuthorizeWithSeed: {
        index: 8,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
      }
    });
    StakeAuthorizationLayout = Object.freeze({
      Staker: {
        index: 0
      },
      Withdrawer: {
        index: 1
      }
    });
    StakeProgram = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Public key that identifies the Stake program
       */
      /**
       * Generate an Initialize instruction to add to a Stake Create transaction
       */
      static initialize(params) {
        const {
          stakePubkey,
          authorized: authorized2,
          lockup: maybeLockup
        } = params;
        const lockup2 = maybeLockup || Lockup.default;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Initialize;
        const data = encodeData(type3, {
          authorized: {
            staker: toBuffer(authorized2.staker.toBuffer()),
            withdrawer: toBuffer(authorized2.withdrawer.toBuffer())
          },
          lockup: {
            unixTimestamp: lockup2.unixTimestamp,
            epoch: lockup2.epoch,
            custodian: toBuffer(lockup2.custodian.toBuffer())
          }
        });
        const instructionData = {
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }],
          programId: this.programId,
          data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate a Transaction that creates a new Stake account at
       *   an address generated with `from`, a seed, and the Stake programId
       */
      static createAccountWithSeed(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccountWithSeed({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.stakePubkey,
          basePubkey: params.basePubkey,
          seed: params.seed,
          lamports: params.lamports,
          space: this.space,
          programId: this.programId
        }));
        const {
          stakePubkey,
          authorized: authorized2,
          lockup: lockup2
        } = params;
        return transaction.add(this.initialize({
          stakePubkey,
          authorized: authorized2,
          lockup: lockup2
        }));
      }
      /**
       * Generate a Transaction that creates a new Stake account
       */
      static createAccount(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.stakePubkey,
          lamports: params.lamports,
          space: this.space,
          programId: this.programId
        }));
        const {
          stakePubkey,
          authorized: authorized2,
          lockup: lockup2
        } = params;
        return transaction.add(this.initialize({
          stakePubkey,
          authorized: authorized2,
          lockup: lockup2
        }));
      }
      /**
       * Generate a Transaction that delegates Stake tokens to a validator
       * Vote PublicKey. This transaction can also be used to redelegate Stake
       * to a new validator Vote PublicKey.
       */
      static delegate(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          votePubkey
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Delegate;
        const data = encodeData(type3);
        return new Transaction().add({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: votePubkey,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: STAKE_CONFIG_ID,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that authorizes a new PublicKey as Staker
       * or Withdrawer on the Stake account.
       */
      static authorize(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          newAuthorizedPubkey,
          stakeAuthorizationType,
          custodianPubkey
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Authorize;
        const data = encodeData(type3, {
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          stakeAuthorizationType: stakeAuthorizationType.index
        });
        const keys = [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }];
        if (custodianPubkey) {
          keys.push({
            pubkey: custodianPubkey,
            isSigner: false,
            isWritable: false
          });
        }
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that authorizes a new PublicKey as Staker
       * or Withdrawer on the Stake account.
       */
      static authorizeWithSeed(params) {
        const {
          stakePubkey,
          authorityBase,
          authoritySeed,
          authorityOwner,
          newAuthorizedPubkey,
          stakeAuthorizationType,
          custodianPubkey
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
        const data = encodeData(type3, {
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          stakeAuthorizationType: stakeAuthorizationType.index,
          authoritySeed,
          authorityOwner: toBuffer(authorityOwner.toBuffer())
        });
        const keys = [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorityBase,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }];
        if (custodianPubkey) {
          keys.push({
            pubkey: custodianPubkey,
            isSigner: false,
            isWritable: false
          });
        }
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * @internal
       */
      static splitInstruction(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          splitStakePubkey,
          lamports
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Split;
        const data = encodeData(type3, {
          lamports
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: splitStakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that splits Stake tokens into another stake account
       */
      static split(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.authorizedPubkey,
          newAccountPubkey: params.splitStakePubkey,
          lamports: 0,
          space: this.space,
          programId: this.programId
        }));
        return transaction.add(this.splitInstruction(params));
      }
      /**
       * Generate a Transaction that splits Stake tokens into another account
       * derived from a base public key and seed
       */
      static splitWithSeed(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          splitStakePubkey,
          basePubkey,
          seed: seed2,
          lamports
        } = params;
        const transaction = new Transaction();
        transaction.add(SystemProgram.allocate({
          accountPubkey: splitStakePubkey,
          basePubkey,
          seed: seed2,
          space: this.space,
          programId: this.programId
        }));
        return transaction.add(this.splitInstruction({
          stakePubkey,
          authorizedPubkey,
          splitStakePubkey,
          lamports
        }));
      }
      /**
       * Generate a Transaction that merges Stake accounts.
       */
      static merge(params) {
        const {
          stakePubkey,
          sourceStakePubKey,
          authorizedPubkey
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Merge;
        const data = encodeData(type3);
        return new Transaction().add({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: sourceStakePubKey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that withdraws deactivated Stake tokens.
       */
      static withdraw(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          toPubkey,
          lamports,
          custodianPubkey
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
        const data = encodeData(type3, {
          lamports
        });
        const keys = [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }];
        if (custodianPubkey) {
          keys.push({
            pubkey: custodianPubkey,
            isSigner: false,
            isWritable: false
          });
        }
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that deactivates Stake tokens.
       */
      static deactivate(params) {
        const {
          stakePubkey,
          authorizedPubkey
        } = params;
        const type3 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
        const data = encodeData(type3);
        return new Transaction().add({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
    };
    StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
    StakeProgram.space = 200;
    VoteInit = class {
      /** [0, 100] */
      constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
        this.nodePubkey = void 0;
        this.authorizedVoter = void 0;
        this.authorizedWithdrawer = void 0;
        this.commission = void 0;
        this.nodePubkey = nodePubkey;
        this.authorizedVoter = authorizedVoter;
        this.authorizedWithdrawer = authorizedWithdrawer;
        this.commission = commission;
      }
    };
    VoteInstruction = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Decode a vote instruction and retrieve the instruction type.
       */
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout.u32("instruction");
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type3;
        for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) {
          if (layout.index == typeIndex) {
            type3 = ixType;
            break;
          }
        }
        if (!type3) {
          throw new Error("Instruction type incorrect; not a VoteInstruction");
        }
        return type3;
      }
      /**
       * Decode an initialize vote instruction and retrieve the instruction params.
       */
      static decodeInitializeAccount(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 4);
        const {
          voteInit: voteInit2
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);
        return {
          votePubkey: instruction.keys[0].pubkey,
          nodePubkey: instruction.keys[3].pubkey,
          voteInit: new VoteInit(new PublicKey(voteInit2.nodePubkey), new PublicKey(voteInit2.authorizedVoter), new PublicKey(voteInit2.authorizedWithdrawer), voteInit2.commission)
        };
      }
      /**
       * Decode an authorize instruction and retrieve the instruction params.
       */
      static decodeAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          newAuthorized,
          voteAuthorizationType
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
        return {
          votePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey,
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          voteAuthorizationType: {
            index: voteAuthorizationType
          }
        };
      }
      /**
       * Decode an authorize instruction and retrieve the instruction params.
       */
      static decodeAuthorizeWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          voteAuthorizeWithSeedArgs: {
            currentAuthorityDerivedKeyOwnerPubkey,
            currentAuthorityDerivedKeySeed,
            newAuthorized,
            voteAuthorizationType
          }
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
        return {
          currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
          currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),
          currentAuthorityDerivedKeySeed,
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          voteAuthorizationType: {
            index: voteAuthorizationType
          },
          votePubkey: instruction.keys[0].pubkey
        };
      }
      /**
       * Decode a withdraw instruction and retrieve the instruction params.
       */
      static decodeWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          lamports
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
        return {
          votePubkey: instruction.keys[0].pubkey,
          authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
          lamports,
          toPubkey: instruction.keys[1].pubkey
        };
      }
      /**
       * @internal
       */
      static checkProgramId(programId) {
        if (!programId.equals(VoteProgram.programId)) {
          throw new Error("invalid instruction; programId is not VoteProgram");
        }
      }
      /**
       * @internal
       */
      static checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
        }
      }
    };
    VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
      InitializeAccount: {
        index: 0,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteInit()])
      },
      Authorize: {
        index: 1,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("voteAuthorizationType")])
      },
      Withdraw: {
        index: 3,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
      },
      AuthorizeWithSeed: {
        index: 10,
        layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteAuthorizeWithSeedArgs()])
      }
    });
    VoteAuthorizationLayout = Object.freeze({
      Voter: {
        index: 0
      },
      Withdrawer: {
        index: 1
      }
    });
    VoteProgram = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * Public key that identifies the Vote program
       */
      /**
       * Generate an Initialize instruction.
       */
      static initializeAccount(params) {
        const {
          votePubkey,
          nodePubkey,
          voteInit: voteInit2
        } = params;
        const type3 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
        const data = encodeData(type3, {
          voteInit: {
            nodePubkey: toBuffer(voteInit2.nodePubkey.toBuffer()),
            authorizedVoter: toBuffer(voteInit2.authorizedVoter.toBuffer()),
            authorizedWithdrawer: toBuffer(voteInit2.authorizedWithdrawer.toBuffer()),
            commission: voteInit2.commission
          }
        });
        const instructionData = {
          keys: [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: nodePubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate a transaction that creates a new Vote account.
       */
      static createAccount(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.votePubkey,
          lamports: params.lamports,
          space: this.space,
          programId: this.programId
        }));
        return transaction.add(this.initializeAccount({
          votePubkey: params.votePubkey,
          nodePubkey: params.voteInit.nodePubkey,
          voteInit: params.voteInit
        }));
      }
      /**
       * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
       */
      static authorize(params) {
        const {
          votePubkey,
          authorizedPubkey,
          newAuthorizedPubkey,
          voteAuthorizationType
        } = params;
        const type3 = VOTE_INSTRUCTION_LAYOUTS.Authorize;
        const data = encodeData(type3, {
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          voteAuthorizationType: voteAuthorizationType.index
        });
        const keys = [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }];
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
       * where the current Voter or Withdrawer authority is a derived key.
       */
      static authorizeWithSeed(params) {
        const {
          currentAuthorityDerivedKeyBasePubkey,
          currentAuthorityDerivedKeyOwnerPubkey,
          currentAuthorityDerivedKeySeed,
          newAuthorizedPubkey,
          voteAuthorizationType,
          votePubkey
        } = params;
        const type3 = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
        const data = encodeData(type3, {
          voteAuthorizeWithSeedArgs: {
            currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
            currentAuthorityDerivedKeySeed,
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            voteAuthorizationType: voteAuthorizationType.index
          }
        });
        const keys = [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: currentAuthorityDerivedKeyBasePubkey,
          isSigner: true,
          isWritable: false
        }];
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction to withdraw from a Vote account.
       */
      static withdraw(params) {
        const {
          votePubkey,
          authorizedWithdrawerPubkey,
          lamports,
          toPubkey
        } = params;
        const type3 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
        const data = encodeData(type3, {
          lamports
        });
        const keys = [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedWithdrawerPubkey,
          isSigner: true,
          isWritable: false
        }];
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction to withdraw safely from a Vote account.
       *
       * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
       * checks that the withdraw amount will not exceed the specified balance while leaving enough left
       * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
       * `withdraw` method directly.
       */
      static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
          throw new Error("Withdraw will leave vote account with insuffcient funds.");
        }
        return VoteProgram.withdraw(params);
      }
    };
    VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
    VoteProgram.space = 3731;
    VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111");
    InfoString = type({
      name: string(),
      website: optional(string()),
      details: optional(string()),
      keybaseUsername: optional(string())
    });
    ValidatorInfo = class {
      /**
       * validator public key
       */
      /**
       * validator information
       */
      /**
       * Construct a valid ValidatorInfo
       *
       * @param key validator public key
       * @param info validator information
       */
      constructor(key, info) {
        this.key = void 0;
        this.info = void 0;
        this.key = key;
        this.info = info;
      }
      /**
       * Deserialize ValidatorInfo from the config account data. Exactly two config
       * keys are required in the data.
       *
       * @param buffer config account data
       * @return null if info was not found
       */
      static fromConfigData(buffer) {
        let byteArray = [...buffer];
        const configKeyCount = decodeLength(byteArray);
        if (configKeyCount !== 2)
          return null;
        const configKeys = [];
        for (let i = 0; i < 2; i++) {
          const publicKey4 = new PublicKey(byteArray.slice(0, PUBLIC_KEY_LENGTH));
          byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
          const isSigner = byteArray.slice(0, 1)[0] === 1;
          byteArray = byteArray.slice(1);
          configKeys.push({
            publicKey: publicKey4,
            isSigner
          });
        }
        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
          if (configKeys[1].isSigner) {
            const rawInfo = rustString().decode(import_buffer.Buffer.from(byteArray));
            const info = JSON.parse(rawInfo);
            assert2(info, InfoString);
            return new ValidatorInfo(configKeys[1].publicKey, info);
          }
        }
        return null;
      }
    };
    VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111");
    VoteAccountLayout = BufferLayout.struct([
      publicKey("nodePubkey"),
      publicKey("authorizedWithdrawer"),
      BufferLayout.u8("commission"),
      BufferLayout.nu64(),
      // votes.length
      BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.u32("confirmationCount")]), BufferLayout.offset(BufferLayout.u32(), -8), "votes"),
      BufferLayout.u8("rootSlotValid"),
      BufferLayout.nu64("rootSlot"),
      BufferLayout.nu64(),
      // authorizedVoters.length
      BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), publicKey("authorizedVoter")]), BufferLayout.offset(BufferLayout.u32(), -8), "authorizedVoters"),
      BufferLayout.struct([BufferLayout.seq(BufferLayout.struct([publicKey("authorizedPubkey"), BufferLayout.nu64("epochOfLastAuthorizedSwitch"), BufferLayout.nu64("targetEpoch")]), 32, "buf"), BufferLayout.nu64("idx"), BufferLayout.u8("isEmpty")], "priorVoters"),
      BufferLayout.nu64(),
      // epochCredits.length
      BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), BufferLayout.nu64("credits"), BufferLayout.nu64("prevCredits")]), BufferLayout.offset(BufferLayout.u32(), -8), "epochCredits"),
      BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.nu64("timestamp")], "lastTimestamp")
    ]);
    VoteAccount = class {
      /**
       * @internal
       */
      constructor(args) {
        this.nodePubkey = void 0;
        this.authorizedWithdrawer = void 0;
        this.commission = void 0;
        this.rootSlot = void 0;
        this.votes = void 0;
        this.authorizedVoters = void 0;
        this.priorVoters = void 0;
        this.epochCredits = void 0;
        this.lastTimestamp = void 0;
        this.nodePubkey = args.nodePubkey;
        this.authorizedWithdrawer = args.authorizedWithdrawer;
        this.commission = args.commission;
        this.rootSlot = args.rootSlot;
        this.votes = args.votes;
        this.authorizedVoters = args.authorizedVoters;
        this.priorVoters = args.priorVoters;
        this.epochCredits = args.epochCredits;
        this.lastTimestamp = args.lastTimestamp;
      }
      /**
       * Deserialize VoteAccount from the account data.
       *
       * @param buffer account data
       * @return VoteAccount
       */
      static fromAccountData(buffer) {
        const versionOffset = 4;
        const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);
        let rootSlot = va.rootSlot;
        if (!va.rootSlotValid) {
          rootSlot = null;
        }
        return new VoteAccount({
          nodePubkey: new PublicKey(va.nodePubkey),
          authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),
          commission: va.commission,
          votes: va.votes,
          rootSlot,
          authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
          priorVoters: getPriorVoters(va.priorVoters),
          epochCredits: va.epochCredits,
          lastTimestamp: va.lastTimestamp
        });
      }
    };
    endpoint = {
      http: {
        devnet: "http://api.devnet.solana.com",
        testnet: "http://api.testnet.solana.com",
        "mainnet-beta": "http://api.mainnet-beta.solana.com/"
      },
      https: {
        devnet: "https://api.devnet.solana.com",
        testnet: "https://api.testnet.solana.com",
        "mainnet-beta": "https://api.mainnet-beta.solana.com/"
      }
    };
    LAMPORTS_PER_SOL = 1e9;
  }
});

// node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/camelcase/index.js"(exports2, module2) {
    "use strict";
    var UPPERCASE = /[\p{Lu}]/u;
    var LOWERCASE = /[\p{Ll}]/u;
    var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    var SEPARATORS = /[_.\- ]+/;
    var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
    var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
    var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
    var preserveCamelCase = (string3, toLowerCase, toUpperCase) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string3.length; i++) {
        const character = string3[i];
        if (isLastCharLower && UPPERCASE.test(character)) {
          string3 = string3.slice(0, i) + "-" + string3.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
          string3 = string3.slice(0, i - 1) + "-" + string3.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
      }
      return string3;
    };
    var preserveConsecutiveUppercase = (input, toLowerCase) => {
      LEADING_CAPITAL.lastIndex = 0;
      return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
    };
    var postProcess = (input, toUpperCase) => {
      SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
      NUMBERS_AND_IDENTIFIER.lastIndex = 0;
      return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
    };
    var camelCase2 = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options
      };
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      const toLowerCase = options.locale === false ? (string3) => string3.toLowerCase() : (string3) => string3.toLocaleLowerCase(options.locale);
      const toUpperCase = options.locale === false ? (string3) => string3.toUpperCase() : (string3) => string3.toLocaleUpperCase(options.locale);
      if (input.length === 1) {
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
      }
      const hasUpperCase = input !== toLowerCase(input);
      if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
      }
      input = input.replace(LEADING_SEPARATORS, "");
      if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
      } else {
        input = toLowerCase(input);
      }
      if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
      }
      return postProcess(input, toUpperCase);
    };
    module2.exports = camelCase2;
    module2.exports.default = camelCase2;
  }
});

// node_modules/js-sha256/src/sha256.js
var require_sha256 = __commonJS({
  "node_modules/js-sha256/src/sha256.js"(exports, module) {
    (function() {
      "use strict";
      var ERROR = "input is invalid type";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, is2242) {
        return function(message) {
          return new Sha256(is2242, true).update(message)[outputType]();
        };
      };
      var createMethod = function(is2242) {
        var method2 = createOutputMethod("hex", is2242);
        if (NODE_JS) {
          method2 = nodeWrap(method2, is2242);
        }
        method2.create = function() {
          return new Sha256(is2242);
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type3 = OUTPUT_TYPES[i];
          method2[type3] = createOutputMethod(type3, is2242);
        }
        return method2;
      };
      var nodeWrap = function(method, is224) {
        var crypto = eval("require('crypto')");
        var Buffer = eval("require('buffer').Buffer");
        var algorithm = is224 ? "sha224" : "sha256";
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
            return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType, is2242) {
        return function(key, message) {
          return new HmacSha256(key, is2242, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(is2242) {
        var method2 = createHmacOutputMethod("hex", is2242);
        method2.create = function(key) {
          return new HmacSha256(key, is2242);
        };
        method2.update = function(key, message) {
          return method2.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type3 = OUTPUT_TYPES[i];
          method2[type3] = createHmacOutputMethod(type3, is2242);
        }
        return method2;
      };
      function Sha256(is2242, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (is2242) {
          this.h0 = 3238371032;
          this.h1 = 914150663;
          this.h2 = 812702999;
          this.h3 = 4144912697;
          this.h4 = 4290775857;
          this.h5 = 1750603025;
          this.h6 = 1694076839;
          this.h7 = 3204075428;
        } else {
          this.h0 = 1779033703;
          this.h1 = 3144134277;
          this.h2 = 1013904242;
          this.h3 = 2773480762;
          this.h4 = 1359893119;
          this.h5 = 2600822924;
          this.h6 = 528734635;
          this.h7 = 1541459225;
        }
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is2242;
      }
      Sha256.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString, type3 = typeof message;
        if (type3 !== "string") {
          if (type3 === "object") {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code, index2 = 0, i, length = message.length, blocks2 = this.blocks;
        while (index2 < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            for (i = this.start; index2 < length && i < 64; ++index2) {
              blocks2[i >> 2] |= message[index2] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index2 < length && i < 64; ++index2) {
              code = message.charCodeAt(index2);
              if (code < 128) {
                blocks2[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.block = blocks2[16];
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha256.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i >> 2] |= EXTRA[i & 3];
        this.block = blocks2[16];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[15] = this.bytes << 3;
        this.hash();
      };
      Sha256.prototype.hash = function() {
        var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f2 = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
        for (j = 16; j < 64; ++j) {
          t1 = blocks2[j - 15];
          s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
          t1 = blocks2[j - 2];
          s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
        }
        bc = b & c;
        for (j = 0; j < 64; j += 4) {
          if (this.first) {
            if (this.is224) {
              ab = 300032;
              t1 = blocks2[0] - 1413257819;
              h = t1 - 150054599 << 0;
              d = t1 + 24177077 << 0;
            } else {
              ab = 704751109;
              t1 = blocks2[0] - 210244248;
              h = t1 - 1521486534 << 0;
              d = t1 + 143694565 << 0;
            }
            this.first = false;
          } else {
            s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
            s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
            ab = a & b;
            maj = ab ^ a & c ^ bc;
            ch = e & f2 ^ ~e & g;
            t1 = h + s1 + ch + K[j] + blocks2[j];
            t2 = s0 + maj;
            h = d + t1 << 0;
            d = t1 + t2 << 0;
          }
          s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
          s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
          da = d & a;
          maj = da ^ d & b ^ ab;
          ch = h & e ^ ~h & f2;
          t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
          t2 = s0 + maj;
          g = c + t1 << 0;
          c = t1 + t2 << 0;
          s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
          s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
          cd = c & d;
          maj = cd ^ c & a ^ da;
          ch = g & h ^ ~g & e;
          t1 = f2 + s1 + ch + K[j + 2] + blocks2[j + 2];
          t2 = s0 + maj;
          f2 = b + t1 << 0;
          b = t1 + t2 << 0;
          s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
          s1 = (f2 >>> 6 | f2 << 26) ^ (f2 >>> 11 | f2 << 21) ^ (f2 >>> 25 | f2 << 7);
          bc = b & c;
          maj = bc ^ b & d ^ cd;
          ch = f2 & g ^ ~f2 & h;
          t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
          t2 = s0 + maj;
          e = a + t1 << 0;
          a = t1 + t2 << 0;
        }
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
        this.h4 = this.h4 + e << 0;
        this.h5 = this.h5 + f2 << 0;
        this.h6 = this.h6 + g << 0;
        this.h7 = this.h7 + h << 0;
      };
      Sha256.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var hex2 = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
        if (!this.is224) {
          hex2 += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
        }
        return hex2;
      };
      Sha256.prototype.toString = Sha256.prototype.hex;
      Sha256.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var arr = [
          h0 >> 24 & 255,
          h0 >> 16 & 255,
          h0 >> 8 & 255,
          h0 & 255,
          h1 >> 24 & 255,
          h1 >> 16 & 255,
          h1 >> 8 & 255,
          h1 & 255,
          h2 >> 24 & 255,
          h2 >> 16 & 255,
          h2 >> 8 & 255,
          h2 & 255,
          h3 >> 24 & 255,
          h3 >> 16 & 255,
          h3 >> 8 & 255,
          h3 & 255,
          h4 >> 24 & 255,
          h4 >> 16 & 255,
          h4 >> 8 & 255,
          h4 & 255,
          h5 >> 24 & 255,
          h5 >> 16 & 255,
          h5 >> 8 & 255,
          h5 & 255,
          h6 >> 24 & 255,
          h6 >> 16 & 255,
          h6 >> 8 & 255,
          h6 & 255
        ];
        if (!this.is224) {
          arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
        }
        return arr;
      };
      Sha256.prototype.array = Sha256.prototype.digest;
      Sha256.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer;
      };
      function HmacSha256(key, is2242, sharedMemory) {
        var i, type3 = typeof key;
        if (type3 === "string") {
          var bytes2 = [], length = key.length, index2 = 0, code;
          for (i = 0; i < length; ++i) {
            code = key.charCodeAt(i);
            if (code < 128) {
              bytes2[index2++] = code;
            } else if (code < 2048) {
              bytes2[index2++] = 192 | code >> 6;
              bytes2[index2++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes2[index2++] = 224 | code >> 12;
              bytes2[index2++] = 128 | code >> 6 & 63;
              bytes2[index2++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
              bytes2[index2++] = 240 | code >> 18;
              bytes2[index2++] = 128 | code >> 12 & 63;
              bytes2[index2++] = 128 | code >> 6 & 63;
              bytes2[index2++] = 128 | code & 63;
            }
          }
          key = bytes2;
        } else {
          if (type3 === "object") {
            if (key === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
        if (key.length > 64) {
          key = new Sha256(is2242, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          var b = key[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Sha256.call(this, is2242, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();
      HmacSha256.prototype.finalize = function() {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };
      var exports = createMethod();
      exports.sha256 = exports;
      exports.sha224 = createMethod(true);
      exports.sha256.hmac = createHmacMethod();
      exports.sha224.hmac = createHmacMethod(true);
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.sha256 = exports.sha256;
        root.sha224 = exports.sha224;
        if (AMD) {
          define(function() {
            return exports;
          });
        }
      }
    })();
  }
});

// node_modules/buffer-layout/lib/Layout.js
var require_Layout2 = __commonJS({
  "node_modules/buffer-layout/lib/Layout.js"(exports2) {
    "use strict";
    var Layout2 = class {
      constructor(span, property) {
        if (!Number.isInteger(span)) {
          throw new TypeError("span must be an integer");
        }
        this.span = span;
        this.property = property;
      }
      /** Function to create an Object into which decoded properties will
       * be written.
       *
       * Used only for layouts that {@link Layout#decode|decode} to Object
       * instances, which means:
       * * {@link Structure}
       * * {@link Union}
       * * {@link VariantLayout}
       * * {@link BitStructure}
       *
       * If left undefined the JavaScript representation of these layouts
       * will be Object instances.
       *
       * See {@link bindConstructorLayout}.
       */
      makeDestinationObject() {
        return {};
      }
      /**
       * Decode from a Buffer into an JavaScript value.
       *
       * @param {Buffer} b - the buffer from which encoded data is read.
       *
       * @param {Number} [offset] - the offset at which the encoded data
       * starts.  If absent a zero offset is inferred.
       *
       * @returns {(Number|Array|Object)} - the value of the decoded data.
       *
       * @abstract
       */
      decode(b, offset3) {
        throw new Error("Layout is abstract");
      }
      /**
       * Encode a JavaScript value into a Buffer.
       *
       * @param {(Number|Array|Object)} src - the value to be encoded into
       * the buffer.  The type accepted depends on the (sub-)type of {@link
       * Layout}.
       *
       * @param {Buffer} b - the buffer into which encoded data will be
       * written.
       *
       * @param {Number} [offset] - the offset at which the encoded data
       * starts.  If absent a zero offset is inferred.
       *
       * @returns {Number} - the number of bytes encoded, including the
       * space skipped for internal padding, but excluding data such as
       * {@link Sequence#count|lengths} when stored {@link
       * ExternalLayout|externally}.  This is the adjustment to `offset`
       * producing the offset where data for the next layout would be
       * written.
       *
       * @abstract
       */
      encode(src, b, offset3) {
        throw new Error("Layout is abstract");
      }
      /**
       * Calculate the span of a specific instance of a layout.
       *
       * @param {Buffer} b - the buffer that contains an encoded instance.
       *
       * @param {Number} [offset] - the offset at which the encoded instance
       * starts.  If absent a zero offset is inferred.
       *
       * @return {Number} - the number of bytes covered by the layout
       * instance.  If this method is not overridden in a subclass the
       * definition-time constant {@link Layout#span|span} will be
       * returned.
       *
       * @throws {RangeError} - if the length of the value cannot be
       * determined.
       */
      getSpan(b, offset3) {
        if (0 > this.span) {
          throw new RangeError("indeterminate span");
        }
        return this.span;
      }
      /**
       * Replicate the layout using a new property.
       *
       * This function must be used to get a structurally-equivalent layout
       * with a different name since all {@link Layout} instances are
       * immutable.
       *
       * **NOTE** This is a shallow copy.  All fields except {@link
       * Layout#property|property} are strictly equal to the origin layout.
       *
       * @param {String} property - the value for {@link
       * Layout#property|property} in the replica.
       *
       * @returns {Layout} - the copy with {@link Layout#property|property}
       * set to `property`.
       */
      replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      /**
       * Create an object from layout properties and an array of values.
       *
       * **NOTE** This function returns `undefined` if invoked on a layout
       * that does not return its value as an Object.  Objects are
       * returned for things that are a {@link Structure}, which includes
       * {@link VariantLayout|variant layouts} if they are structures, and
       * excludes {@link Union}s.  If you want this feature for a union
       * you must use {@link Union.getVariant|getVariant} to select the
       * desired layout.
       *
       * @param {Array} values - an array of values that correspond to the
       * default order for properties.  As with {@link Layout#decode|decode}
       * layout elements that have no property name are skipped when
       * iterating over the array values.  Only the top-level properties are
       * assigned; arguments are not assigned to properties of contained
       * layouts.  Any unused values are ignored.
       *
       * @return {(Object|undefined)}
       */
      fromArray(values) {
        return void 0;
      }
    };
    exports2.Layout = Layout2;
    function nameWithProperty2(name, lo) {
      if (lo.property) {
        return name + "[" + lo.property + "]";
      }
      return name;
    }
    exports2.nameWithProperty = nameWithProperty2;
    function bindConstructorLayout(Class, layout) {
      if ("function" !== typeof Class) {
        throw new TypeError("Class must be constructor");
      }
      if (Class.hasOwnProperty("layout_")) {
        throw new Error("Class is already bound to a layout");
      }
      if (!(layout && layout instanceof Layout2)) {
        throw new TypeError("layout must be a Layout");
      }
      if (layout.hasOwnProperty("boundConstructor_")) {
        throw new Error("layout is already bound to a constructor");
      }
      Class.layout_ = layout;
      layout.boundConstructor_ = Class;
      layout.makeDestinationObject = () => new Class();
      Object.defineProperty(Class.prototype, "encode", {
        value: function(b, offset3) {
          return layout.encode(this, b, offset3);
        },
        writable: true
      });
      Object.defineProperty(Class, "decode", {
        value: function(b, offset3) {
          return layout.decode(b, offset3);
        },
        writable: true
      });
    }
    exports2.bindConstructorLayout = bindConstructorLayout;
    var ExternalLayout2 = class extends Layout2 {
      /**
       * Return `true` iff the external layout decodes to an unsigned
       * integer layout.
       *
       * In that case it can be used as the source of {@link
       * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
       * or as {@link UnionLayoutDiscriminator#layout|external union
       * discriminators}.
       *
       * @abstract
       */
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    };
    var GreedyCount = class extends ExternalLayout2 {
      constructor(elementSpan, property) {
        if (void 0 === elementSpan) {
          elementSpan = 1;
        }
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
          throw new TypeError("elementSpan must be a (positive) integer");
        }
        super(-1, property);
        this.elementSpan = elementSpan;
      }
      /** @override */
      isCount() {
        return true;
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const rem = b.length - offset3;
        return Math.floor(rem / this.elementSpan);
      }
      /** @override */
      encode(src, b, offset3) {
        return 0;
      }
    };
    var OffsetLayout2 = class extends ExternalLayout2 {
      constructor(layout, offset3, property) {
        if (!(layout instanceof Layout2)) {
          throw new TypeError("layout must be a Layout");
        }
        if (void 0 === offset3) {
          offset3 = 0;
        } else if (!Number.isInteger(offset3)) {
          throw new TypeError("offset must be integer or undefined");
        }
        super(layout.span, property || layout.property);
        this.layout = layout;
        this.offset = offset3;
      }
      /** @override */
      isCount() {
        return this.layout instanceof UInt2 || this.layout instanceof UIntBE2;
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return this.layout.decode(b, offset3 + this.offset);
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return this.layout.encode(src, b, offset3 + this.offset);
      }
    };
    var UInt2 = class extends Layout2 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readUIntLE(offset3, this.span);
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeUIntLE(src, offset3, this.span);
        return this.span;
      }
    };
    var UIntBE2 = class extends Layout2 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readUIntBE(offset3, this.span);
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeUIntBE(src, offset3, this.span);
        return this.span;
      }
    };
    var Int = class extends Layout2 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readIntLE(offset3, this.span);
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeIntLE(src, offset3, this.span);
        return this.span;
      }
    };
    var IntBE = class extends Layout2 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readIntBE(offset3, this.span);
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeIntBE(src, offset3, this.span);
        return this.span;
      }
    };
    var V2E322 = Math.pow(2, 32);
    function divmodInt642(src) {
      const hi32 = Math.floor(src / V2E322);
      const lo32 = src - hi32 * V2E322;
      return { hi32, lo32 };
    }
    function roundedInt642(hi32, lo32) {
      return hi32 * V2E322 + lo32;
    }
    var NearUInt642 = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const lo32 = b.readUInt32LE(offset3);
        const hi32 = b.readUInt32LE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const split2 = divmodInt642(src);
        b.writeUInt32LE(split2.lo32, offset3);
        b.writeUInt32LE(split2.hi32, offset3 + 4);
        return 8;
      }
    };
    var NearUInt64BE = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const hi32 = b.readUInt32BE(offset3);
        const lo32 = b.readUInt32BE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const split2 = divmodInt642(src);
        b.writeUInt32BE(split2.hi32, offset3);
        b.writeUInt32BE(split2.lo32, offset3 + 4);
        return 8;
      }
    };
    var NearInt642 = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const lo32 = b.readUInt32LE(offset3);
        const hi32 = b.readInt32LE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const split2 = divmodInt642(src);
        b.writeUInt32LE(split2.lo32, offset3);
        b.writeInt32LE(split2.hi32, offset3 + 4);
        return 8;
      }
    };
    var NearInt64BE = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const hi32 = b.readInt32BE(offset3);
        const lo32 = b.readUInt32BE(offset3 + 4);
        return roundedInt642(hi32, lo32);
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const split2 = divmodInt642(src);
        b.writeInt32BE(split2.hi32, offset3);
        b.writeUInt32BE(split2.lo32, offset3 + 4);
        return 8;
      }
    };
    var Float = class extends Layout2 {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readFloatLE(offset3);
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeFloatLE(src, offset3);
        return 4;
      }
    };
    var FloatBE = class extends Layout2 {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readFloatBE(offset3);
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeFloatBE(src, offset3);
        return 4;
      }
    };
    var Double = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readDoubleLE(offset3);
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeDoubleLE(src, offset3);
        return 8;
      }
    };
    var DoubleBE = class extends Layout2 {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.readDoubleBE(offset3);
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        b.writeDoubleBE(src, offset3);
        return 8;
      }
    };
    var Sequence = class extends Layout2 {
      constructor(elementLayout, count, property) {
        if (!(elementLayout instanceof Layout2)) {
          throw new TypeError("elementLayout must be a Layout");
        }
        if (!(count instanceof ExternalLayout2 && count.isCount() || Number.isInteger(count) && 0 <= count)) {
          throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(count instanceof ExternalLayout2) && 0 < elementLayout.span) {
          span = count * elementLayout.span;
        }
        super(span, property);
        this.elementLayout = elementLayout;
        this.count = count;
      }
      /** @override */
      getSpan(b, offset3) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout2) {
          count = count.decode(b, offset3);
        }
        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          let idx = 0;
          while (idx < count) {
            span += this.elementLayout.getSpan(b, offset3 + span);
            ++idx;
          }
        }
        return span;
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const rv = [];
        let i = 0;
        let count = this.count;
        if (count instanceof ExternalLayout2) {
          count = count.decode(b, offset3);
        }
        while (i < count) {
          rv.push(this.elementLayout.decode(b, offset3));
          offset3 += this.elementLayout.getSpan(b, offset3);
          i += 1;
        }
        return rv;
      }
      /** Implement {@link Layout#encode|encode} for {@link Sequence}.
       *
       * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
       * the unused space in the buffer is left unchanged.  If `src` is
       * longer than {@link Sequence#count|count} the unneeded elements are
       * ignored.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const elo = this.elementLayout;
        const span = src.reduce((span2, v) => {
          return span2 + elo.encode(v, b, offset3 + span2);
        }, 0);
        if (this.count instanceof ExternalLayout2) {
          this.count.encode(src.length, b, offset3);
        }
        return span;
      }
    };
    var Structure2 = class extends Layout2 {
      constructor(fields, property, decodePrefixes) {
        if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout2, true))) {
          throw new TypeError("fields must be array of Layout instances");
        }
        if ("boolean" === typeof property && void 0 === decodePrefixes) {
          decodePrefixes = property;
          property = void 0;
        }
        for (const fd of fields) {
          if (0 > fd.span && void 0 === fd.property) {
            throw new Error("fields cannot contain unnamed variable-length layout");
          }
        }
        let span = -1;
        try {
          span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
        } catch (e) {
        }
        super(span, property);
        this.fields = fields;
        this.decodePrefixes = !!decodePrefixes;
      }
      /** @override */
      getSpan(b, offset3) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let span = 0;
        try {
          span = this.fields.reduce((span2, fd) => {
            const fsp = fd.getSpan(b, offset3);
            offset3 += fsp;
            return span2 + fsp;
          }, 0);
        } catch (e) {
          throw new RangeError("indeterminate span");
        }
        return span;
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b, offset3);
          }
          offset3 += fd.getSpan(b, offset3);
          if (this.decodePrefixes && b.length === offset3) {
            break;
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Structure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the buffer is
       * left unmodified. */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const firstOffset = offset3;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd of this.fields) {
          let span = fd.span;
          lastWrote = 0 < span ? span : 0;
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              lastWrote = fd.encode(fv, b, offset3);
              if (0 > span) {
                span = fd.getSpan(b, offset3);
              }
            }
          }
          lastOffset = offset3;
          offset3 += span;
        }
        return lastOffset + lastWrote - firstOffset;
      }
      /** @override */
      fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property && 0 < values.length) {
            dest[fd.property] = values.shift();
          }
        }
        return dest;
      }
      /**
       * Get access to the layout of a given property.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Layout} - the layout associated with `property`, or
       * undefined if there is no such property.
       */
      layoutFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
      }
      /**
       * Get the offset of a structure member.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Number} - the offset in bytes to the start of `property`
       * within the structure, or undefined if `property` is not a field
       * within the structure.  If the property is a member but follows a
       * variable-length structure member a negative number will be
       * returned.
       */
      offsetOf(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        let offset3 = 0;
        for (const fd of this.fields) {
          if (fd.property === property) {
            return offset3;
          }
          if (0 > fd.span) {
            offset3 = -1;
          } else if (0 <= offset3) {
            offset3 += fd.span;
          }
        }
      }
    };
    var UnionDiscriminator2 = class {
      constructor(property) {
        this.property = property;
      }
      /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
       *
       * The implementation of this method need not reference the buffer if
       * variant information is available through other means. */
      decode() {
        throw new Error("UnionDiscriminator is abstract");
      }
      /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
       *
       * The implementation of this method need not store the value if
       * variant information is maintained through other means. */
      encode() {
        throw new Error("UnionDiscriminator is abstract");
      }
    };
    var UnionLayoutDiscriminator2 = class extends UnionDiscriminator2 {
      constructor(layout, property) {
        if (!(layout instanceof ExternalLayout2 && layout.isCount())) {
          throw new TypeError("layout must be an unsigned integer ExternalLayout");
        }
        super(property || layout.property || "variant");
        this.layout = layout;
      }
      /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      decode(b, offset3) {
        return this.layout.decode(b, offset3);
      }
      /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      encode(src, b, offset3) {
        return this.layout.encode(src, b, offset3);
      }
    };
    var Union2 = class extends Layout2 {
      constructor(discr, defaultLayout, property) {
        const upv = discr instanceof UInt2 || discr instanceof UIntBE2;
        if (upv) {
          discr = new UnionLayoutDiscriminator2(new OffsetLayout2(discr));
        } else if (discr instanceof ExternalLayout2 && discr.isCount()) {
          discr = new UnionLayoutDiscriminator2(discr);
        } else if (!(discr instanceof UnionDiscriminator2)) {
          throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        }
        if (void 0 === defaultLayout) {
          defaultLayout = null;
        }
        if (!(null === defaultLayout || defaultLayout instanceof Layout2)) {
          throw new TypeError("defaultLayout must be null or a Layout");
        }
        if (null !== defaultLayout) {
          if (0 > defaultLayout.span) {
            throw new Error("defaultLayout must have constant span");
          }
          if (void 0 === defaultLayout.property) {
            defaultLayout = defaultLayout.replicate("content");
          }
        }
        let span = -1;
        if (defaultLayout) {
          span = defaultLayout.span;
          if (0 <= span && upv) {
            span += discr.layout.span;
          }
        }
        super(span, property);
        this.discriminator = discr;
        this.usesPrefixDiscriminator = upv;
        this.defaultLayout = defaultLayout;
        this.registry = {};
        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(src) {
          return boundGetSourceVariant(src);
        };
        this.configGetSourceVariant = function(gsv) {
          boundGetSourceVariant = gsv.bind(this);
        };
      }
      /** @override */
      getSpan(b, offset3) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const vlo = this.getVariant(b, offset3);
        if (!vlo) {
          throw new Error("unable to determine span for unrecognized variant");
        }
        return vlo.getSpan(b, offset3);
      }
      /**
       * Method to infer a registered Union variant compatible with `src`.
       *
       * The first satisified rule in the following sequence defines the
       * return value:
       * * If `src` has properties matching the Union discriminator and
       *   the default layout, `undefined` is returned regardless of the
       *   value of the discriminator property (this ensures the default
       *   layout will be used);
       * * If `src` has a property matching the Union discriminator, the
       *   value of the discriminator identifies a registered variant, and
       *   either (a) the variant has no layout, or (b) `src` has the
       *   variant's property, then the variant is returned (because the
       *   source satisfies the constraints of the variant it identifies);
       * * If `src` does not have a property matching the Union
       *   discriminator, but does have a property matching a registered
       *   variant, then the variant is returned (because the source
       *   matches a variant without an explicit conflict);
       * * An error is thrown (because we either can't identify a variant,
       *   or we were explicitly told the variant but can't satisfy it).
       *
       * @param {Object} src - an object presumed to be compatible with
       * the content of the Union.
       *
       * @return {(undefined|VariantLayout)} - as described above.
       *
       * @throws {Error} - if `src` cannot be associated with a default or
       * registered variant.
       */
      defaultGetSourceVariant(src) {
        if (src.hasOwnProperty(this.discriminator.property)) {
          if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
            return void 0;
          }
          const vlo = this.registry[src[this.discriminator.property]];
          if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
            return vlo;
          }
        } else {
          for (const tag in this.registry) {
            const vlo = this.registry[tag];
            if (src.hasOwnProperty(vlo.property)) {
              return vlo;
            }
          }
        }
        throw new Error("unable to infer src variant");
      }
      /** Implement {@link Layout#decode|decode} for {@link Union}.
       *
       * If the variant is {@link Union#addVariant|registered} the return
       * value is an instance of that variant, with no explicit
       * discriminator.  Otherwise the {@link Union#defaultLayout|default
       * layout} is used to decode the content. */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b, offset3);
        let clo = this.registry[discr];
        if (void 0 === clo) {
          let contentOffset = 0;
          clo = this.defaultLayout;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[clo.property] = this.defaultLayout.decode(b, offset3 + contentOffset);
        } else {
          dest = clo.decode(b, offset3);
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Union}.
       *
       * This API assumes the `src` object is consistent with the union's
       * {@link Union#defaultLayout|default layout}.  To encode variants
       * use the appropriate variant-specific {@link VariantLayout#encode}
       * method. */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const vlo = this.getSourceVariant(src);
        if (void 0 === vlo) {
          const dlo = this.discriminator;
          const clo = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dlo.encode(src[dlo.property], b, offset3);
          return contentOffset + clo.encode(
            src[clo.property],
            b,
            offset3 + contentOffset
          );
        }
        return vlo.encode(src, b, offset3);
      }
      /** Register a new variant structure within a union.  The newly
       * created variant is returned.
       *
       * @param {Number} variant - initializer for {@link
       * VariantLayout#variant|variant}.
       *
       * @param {Layout} layout - initializer for {@link
       * VariantLayout#layout|layout}.
       *
       * @param {String} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {VariantLayout} */
      addVariant(variant, layout, property) {
        const rv = new VariantLayout2(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      /**
       * Get the layout associated with a registered variant.
       *
       * If `vb` does not produce a registered variant the function returns
       * `undefined`.
       *
       * @param {(Number|Buffer)} vb - either the variant number, or a
       * buffer from which the discriminator is to be read.
       *
       * @param {Number} offset - offset into `vb` for the start of the
       * union.  Used only when `vb` is an instance of {Buffer}.
       *
       * @return {({VariantLayout}|undefined)}
       */
      getVariant(vb, offset3) {
        let variant = vb;
        if (Buffer.isBuffer(vb)) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          variant = this.discriminator.decode(vb, offset3);
        }
        return this.registry[variant];
      }
    };
    var VariantLayout2 = class extends Layout2 {
      constructor(union3, variant, layout, property) {
        if (!(union3 instanceof Union2)) {
          throw new TypeError("union must be a Union");
        }
        if (!Number.isInteger(variant) || 0 > variant) {
          throw new TypeError("variant must be a (non-negative) integer");
        }
        if ("string" === typeof layout && void 0 === property) {
          property = layout;
          layout = null;
        }
        if (layout) {
          if (!(layout instanceof Layout2)) {
            throw new TypeError("layout must be a Layout");
          }
          if (null !== union3.defaultLayout && 0 <= layout.span && layout.span > union3.defaultLayout.span) {
            throw new Error("variant span exceeds span of containing union");
          }
          if ("string" !== typeof property) {
            throw new TypeError("variant must have a String property");
          }
        }
        let span = union3.span;
        if (0 > union3.span) {
          span = layout ? layout.span : 0;
          if (0 <= span && union3.usesPrefixDiscriminator) {
            span += union3.discriminator.layout.span;
          }
        }
        super(span, property);
        this.union = union3;
        this.variant = variant;
        this.layout = layout || null;
      }
      /** @override */
      getSpan(b, offset3) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        return contentOffset + this.layout.getSpan(b, offset3 + contentOffset);
      }
      /** @override */
      decode(b, offset3) {
        const dest = this.makeDestinationObject();
        if (void 0 === offset3) {
          offset3 = 0;
        }
        if (this !== this.union.getVariant(b, offset3)) {
          throw new Error("variant mismatch");
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout) {
          dest[this.property] = this.layout.decode(b, offset3 + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout && !src.hasOwnProperty(this.property)) {
          throw new TypeError("variant lacks property " + this.property);
        }
        this.union.discriminator.encode(this.variant, b, offset3);
        let span = contentOffset;
        if (this.layout) {
          this.layout.encode(src[this.property], b, offset3 + contentOffset);
          span += this.layout.getSpan(b, offset3 + contentOffset);
          if (0 <= this.union.span && span > this.union.span) {
            throw new Error("encoded variant overruns containing union");
          }
        }
        return span;
      }
      /** Delegate {@link Layout#fromArray|fromArray} to {@link
       * VariantLayout#layout|layout}. */
      fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
      }
    };
    function fixBitwiseResult(v) {
      if (0 > v) {
        v += 4294967296;
      }
      return v;
    }
    var BitStructure = class extends Layout2 {
      constructor(word, msb, property) {
        if (!(word instanceof UInt2 || word instanceof UIntBE2)) {
          throw new TypeError("word must be a UInt or UIntBE layout");
        }
        if ("string" === typeof msb && void 0 === property) {
          property = msb;
          msb = void 0;
        }
        if (4 < word.span) {
          throw new RangeError("word cannot exceed 32 bits");
        }
        super(word.span, property);
        this.word = word;
        this.msb = !!msb;
        this.fields = [];
        let value = 0;
        this._packedSetValue = function(v) {
          value = fixBitwiseResult(v);
          return this;
        };
        this._packedGetValue = function() {
          return value;
        };
      }
      /** @override */
      decode(b, offset3) {
        const dest = this.makeDestinationObject();
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const value = this.word.decode(b, offset3);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(value);
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the packed
       * value is left unmodified.  Unused bits are also left unmodified. */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        const value = this.word.decode(b, offset3);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              fd.encode(fv);
            }
          }
        }
        return this.word.encode(this._packedGetValue(), b, offset3);
      }
      /** Register a new bitfield with a containing bit structure.  The
       * resulting bitfield is returned.
       *
       * @param {Number} bits - initializer for {@link BitField#bits|bits}.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {BitField} */
      addField(bits, property) {
        const bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
      }
      /** As with {@link BitStructure#addField|addField} for single-bit
       * fields with `boolean` value representation.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {Boolean} */
      addBoolean(property) {
        const bf = new Boolean2(this, property);
        this.fields.push(bf);
        return bf;
      }
      /**
       * Get access to the bit field for a given property.
       *
       * @param {String} property - the bit field of interest.
       *
       * @return {BitField} - the field associated with `property`, or
       * undefined if there is no such property.
       */
      fieldFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
      }
    };
    var BitField = class {
      constructor(container, bits, property) {
        if (!(container instanceof BitStructure)) {
          throw new TypeError("container must be a BitStructure");
        }
        if (!Number.isInteger(bits) || 0 >= bits) {
          throw new TypeError("bits must be positive integer");
        }
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
        if (bits + usedBits > totalBits) {
          throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        }
        this.container = container;
        this.bits = bits;
        this.valueMask = (1 << bits) - 1;
        if (32 === bits) {
          this.valueMask = 4294967295;
        }
        this.start = usedBits;
        if (this.container.msb) {
          this.start = totalBits - usedBits - bits;
        }
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        this.property = property;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field. */
      decode() {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value = wordValue >>> this.start;
        return value;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field.
       *
       * **NOTE** This is not a specialization of {@link
       * Layout#encode|Layout.encode} and there is no return value. */
      encode(value) {
        if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
          throw new TypeError(nameWithProperty2("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        }
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      }
    };
    var Boolean2 = class extends BitField {
      constructor(container, property) {
        super(container, 1, property);
      }
      /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
       *
       * @returns {boolean} */
      decode(b, offset3) {
        return !!BitField.prototype.decode.call(this, b, offset3);
      }
      /** @override */
      encode(value) {
        if ("boolean" === typeof value) {
          value = +value;
        }
        return BitField.prototype.encode.call(this, value);
      }
    };
    var Blob2 = class extends Layout2 {
      constructor(length, property) {
        if (!(length instanceof ExternalLayout2 && length.isCount() || Number.isInteger(length) && 0 <= length)) {
          throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(length instanceof ExternalLayout2)) {
          span = length;
        }
        super(span, property);
        this.length = length;
      }
      /** @override */
      getSpan(b, offset3) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset3);
        }
        return span;
      }
      /** @override */
      decode(b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset3);
        }
        return b.slice(offset3, offset3 + span);
      }
      /** Implement {@link Layout#encode|encode} for {@link Blob}.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src, b, offset3) {
        let span = this.length;
        if (this.length instanceof ExternalLayout2) {
          span = src.length;
        }
        if (!(Buffer.isBuffer(src) && span === src.length)) {
          throw new TypeError(nameWithProperty2("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
        }
        if (offset3 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        b.write(src.toString("hex"), offset3, span, "hex");
        if (this.length instanceof ExternalLayout2) {
          this.length.encode(span, b, offset3);
        }
        return span;
      }
    };
    var CString = class extends Layout2 {
      constructor(property) {
        super(-1, property);
      }
      /** @override */
      getSpan(b, offset3) {
        if (!Buffer.isBuffer(b)) {
          throw new TypeError("b must be a Buffer");
        }
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let idx = offset3;
        while (idx < b.length && 0 !== b[idx]) {
          idx += 1;
        }
        return 1 + idx - offset3;
      }
      /** @override */
      decode(b, offset3, dest) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let span = this.getSpan(b, offset3);
        return b.slice(offset3, offset3 + span - 1).toString("utf-8");
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        if ("string" !== typeof src) {
          src = src.toString();
        }
        const srcb = new Buffer(src, "utf8");
        const span = srcb.length;
        if (offset3 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(b, offset3);
        b[offset3 + span] = 0;
        return span + 1;
      }
    };
    var UTF8 = class extends Layout2 {
      constructor(maxSpan, property) {
        if ("string" === typeof maxSpan && void 0 === property) {
          property = maxSpan;
          maxSpan = void 0;
        }
        if (void 0 === maxSpan) {
          maxSpan = -1;
        } else if (!Number.isInteger(maxSpan)) {
          throw new TypeError("maxSpan must be an integer");
        }
        super(-1, property);
        this.maxSpan = maxSpan;
      }
      /** @override */
      getSpan(b, offset3) {
        if (!Buffer.isBuffer(b)) {
          throw new TypeError("b must be a Buffer");
        }
        if (void 0 === offset3) {
          offset3 = 0;
        }
        return b.length - offset3;
      }
      /** @override */
      decode(b, offset3, dest) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        let span = this.getSpan(b, offset3);
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        return b.slice(offset3, offset3 + span).toString("utf-8");
      }
      /** @override */
      encode(src, b, offset3) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        if ("string" !== typeof src) {
          src = src.toString();
        }
        const srcb = new Buffer(src, "utf8");
        const span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        if (offset3 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(b, offset3);
        return span;
      }
    };
    var Constant = class extends Layout2 {
      constructor(value, property) {
        super(0, property);
        this.value = value;
      }
      /** @override */
      decode(b, offset3, dest) {
        return this.value;
      }
      /** @override */
      encode(src, b, offset3) {
        return 0;
      }
    };
    exports2.ExternalLayout = ExternalLayout2;
    exports2.GreedyCount = GreedyCount;
    exports2.OffsetLayout = OffsetLayout2;
    exports2.UInt = UInt2;
    exports2.UIntBE = UIntBE2;
    exports2.Int = Int;
    exports2.IntBE = IntBE;
    exports2.Float = Float;
    exports2.FloatBE = FloatBE;
    exports2.Double = Double;
    exports2.DoubleBE = DoubleBE;
    exports2.Sequence = Sequence;
    exports2.Structure = Structure2;
    exports2.UnionDiscriminator = UnionDiscriminator2;
    exports2.UnionLayoutDiscriminator = UnionLayoutDiscriminator2;
    exports2.Union = Union2;
    exports2.VariantLayout = VariantLayout2;
    exports2.BitStructure = BitStructure;
    exports2.BitField = BitField;
    exports2.Boolean = Boolean2;
    exports2.Blob = Blob2;
    exports2.CString = CString;
    exports2.UTF8 = UTF8;
    exports2.Constant = Constant;
    exports2.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
    exports2.offset = (layout, offset3, property) => new OffsetLayout2(layout, offset3, property);
    exports2.u8 = (property) => new UInt2(1, property);
    exports2.u16 = (property) => new UInt2(2, property);
    exports2.u24 = (property) => new UInt2(3, property);
    exports2.u32 = (property) => new UInt2(4, property);
    exports2.u40 = (property) => new UInt2(5, property);
    exports2.u48 = (property) => new UInt2(6, property);
    exports2.nu64 = (property) => new NearUInt642(property);
    exports2.u16be = (property) => new UIntBE2(2, property);
    exports2.u24be = (property) => new UIntBE2(3, property);
    exports2.u32be = (property) => new UIntBE2(4, property);
    exports2.u40be = (property) => new UIntBE2(5, property);
    exports2.u48be = (property) => new UIntBE2(6, property);
    exports2.nu64be = (property) => new NearUInt64BE(property);
    exports2.s8 = (property) => new Int(1, property);
    exports2.s16 = (property) => new Int(2, property);
    exports2.s24 = (property) => new Int(3, property);
    exports2.s32 = (property) => new Int(4, property);
    exports2.s40 = (property) => new Int(5, property);
    exports2.s48 = (property) => new Int(6, property);
    exports2.ns64 = (property) => new NearInt642(property);
    exports2.s16be = (property) => new IntBE(2, property);
    exports2.s24be = (property) => new IntBE(3, property);
    exports2.s32be = (property) => new IntBE(4, property);
    exports2.s40be = (property) => new IntBE(5, property);
    exports2.s48be = (property) => new IntBE(6, property);
    exports2.ns64be = (property) => new NearInt64BE(property);
    exports2.f32 = (property) => new Float(property);
    exports2.f32be = (property) => new FloatBE(property);
    exports2.f64 = (property) => new Double(property);
    exports2.f64be = (property) => new DoubleBE(property);
    exports2.struct = (fields, property, decodePrefixes) => new Structure2(fields, property, decodePrefixes);
    exports2.bits = (word, msb, property) => new BitStructure(word, msb, property);
    exports2.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
    exports2.union = (discr, defaultLayout, property) => new Union2(discr, defaultLayout, property);
    exports2.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator2(layout, property);
    exports2.blob = (length, property) => new Blob2(length, property);
    exports2.cstr = (property) => new CString(property);
    exports2.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
    exports2.const = (value, property) => new Constant(value, property);
  }
});

// node_modules/@coral-xyz/borsh/dist/index.js
var require_dist = __commonJS({
  "node_modules/@coral-xyz/borsh/dist/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.map = exports2.array = exports2.rustEnum = exports2.str = exports2.vecU8 = exports2.tagged = exports2.vec = exports2.bool = exports2.option = exports2.publicKey = exports2.i256 = exports2.u256 = exports2.i128 = exports2.u128 = exports2.i64 = exports2.u64 = exports2.struct = exports2.f64 = exports2.f32 = exports2.i32 = exports2.u32 = exports2.i16 = exports2.u16 = exports2.i8 = exports2.u8 = void 0;
    var buffer_layout_1 = require_Layout2();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var bn_js_1 = __importDefault(require_bn());
    var buffer_layout_2 = require_Layout2();
    Object.defineProperty(exports2, "u8", { enumerable: true, get: function() {
      return buffer_layout_2.u8;
    } });
    Object.defineProperty(exports2, "i8", { enumerable: true, get: function() {
      return buffer_layout_2.s8;
    } });
    Object.defineProperty(exports2, "u16", { enumerable: true, get: function() {
      return buffer_layout_2.u16;
    } });
    Object.defineProperty(exports2, "i16", { enumerable: true, get: function() {
      return buffer_layout_2.s16;
    } });
    Object.defineProperty(exports2, "u32", { enumerable: true, get: function() {
      return buffer_layout_2.u32;
    } });
    Object.defineProperty(exports2, "i32", { enumerable: true, get: function() {
      return buffer_layout_2.s32;
    } });
    Object.defineProperty(exports2, "f32", { enumerable: true, get: function() {
      return buffer_layout_2.f32;
    } });
    Object.defineProperty(exports2, "f64", { enumerable: true, get: function() {
      return buffer_layout_2.f64;
    } });
    Object.defineProperty(exports2, "struct", { enumerable: true, get: function() {
      return buffer_layout_2.struct;
    } });
    var BNLayout = class extends buffer_layout_1.Layout {
      constructor(span, signed, property) {
        super(span, property);
        this.blob = (0, buffer_layout_1.blob)(span);
        this.signed = signed;
      }
      decode(b, offset3 = 0) {
        const num = new bn_js_1.default(this.blob.decode(b, offset3), 10, "le");
        if (this.signed) {
          return num.fromTwos(this.span * 8).clone();
        }
        return num;
      }
      encode(src, b, offset3 = 0) {
        if (this.signed) {
          src = src.toTwos(this.span * 8);
        }
        return this.blob.encode(src.toArrayLike(Buffer, "le", this.span), b, offset3);
      }
    };
    function u645(property) {
      return new BNLayout(8, false, property);
    }
    exports2.u64 = u645;
    function i642(property) {
      return new BNLayout(8, true, property);
    }
    exports2.i64 = i642;
    function u1282(property) {
      return new BNLayout(16, false, property);
    }
    exports2.u128 = u1282;
    function i1282(property) {
      return new BNLayout(16, true, property);
    }
    exports2.i128 = i1282;
    function u2562(property) {
      return new BNLayout(32, false, property);
    }
    exports2.u256 = u2562;
    function i2562(property) {
      return new BNLayout(32, true, property);
    }
    exports2.i256 = i2562;
    var WrappedLayout2 = class extends buffer_layout_1.Layout {
      constructor(layout, decoder, encoder, property) {
        super(layout.span, property);
        this.layout = layout;
        this.decoder = decoder;
        this.encoder = encoder;
      }
      decode(b, offset3) {
        return this.decoder(this.layout.decode(b, offset3));
      }
      encode(src, b, offset3) {
        return this.layout.encode(this.encoder(src), b, offset3);
      }
      getSpan(b, offset3) {
        return this.layout.getSpan(b, offset3);
      }
    };
    function publicKey4(property) {
      return new WrappedLayout2((0, buffer_layout_1.blob)(32), (b) => new web3_js_1.PublicKey(b), (key) => key.toBuffer(), property);
    }
    exports2.publicKey = publicKey4;
    var OptionLayout = class extends buffer_layout_1.Layout {
      constructor(layout, property) {
        super(-1, property);
        this.layout = layout;
        this.discriminator = (0, buffer_layout_1.u8)();
      }
      encode(src, b, offset3 = 0) {
        if (src === null || src === void 0) {
          return this.discriminator.encode(0, b, offset3);
        }
        this.discriminator.encode(1, b, offset3);
        return this.layout.encode(src, b, offset3 + 1) + 1;
      }
      decode(b, offset3 = 0) {
        const discriminator = this.discriminator.decode(b, offset3);
        if (discriminator === 0) {
          return null;
        } else if (discriminator === 1) {
          return this.layout.decode(b, offset3 + 1);
        }
        throw new Error("Invalid option " + this.property);
      }
      getSpan(b, offset3 = 0) {
        const discriminator = this.discriminator.decode(b, offset3);
        if (discriminator === 0) {
          return 1;
        } else if (discriminator === 1) {
          return this.layout.getSpan(b, offset3 + 1) + 1;
        }
        throw new Error("Invalid option " + this.property);
      }
    };
    function option2(layout, property) {
      return new OptionLayout(layout, property);
    }
    exports2.option = option2;
    function bool3(property) {
      return new WrappedLayout2((0, buffer_layout_1.u8)(), decodeBool, encodeBool, property);
    }
    exports2.bool = bool3;
    function decodeBool(value) {
      if (value === 0) {
        return false;
      } else if (value === 1) {
        return true;
      }
      throw new Error("Invalid bool: " + value);
    }
    function encodeBool(value) {
      return value ? 1 : 0;
    }
    function vec2(elementLayout, property) {
      const length = (0, buffer_layout_1.u32)("length");
      const layout = (0, buffer_layout_1.struct)([
        length,
        (0, buffer_layout_1.seq)(elementLayout, (0, buffer_layout_1.offset)(length, -length.span), "values")
      ]);
      return new WrappedLayout2(layout, ({ values }) => values, (values) => ({ values }), property);
    }
    exports2.vec = vec2;
    function tagged(tag, layout, property) {
      const wrappedLayout = (0, buffer_layout_1.struct)([
        u645("tag"),
        layout.replicate("data")
      ]);
      function decodeTag({ tag: receivedTag, data }) {
        if (!receivedTag.eq(tag)) {
          throw new Error("Invalid tag, expected: " + tag.toString("hex") + ", got: " + receivedTag.toString("hex"));
        }
        return data;
      }
      return new WrappedLayout2(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);
    }
    exports2.tagged = tagged;
    function vecU82(property) {
      const length = (0, buffer_layout_1.u32)("length");
      const layout = (0, buffer_layout_1.struct)([
        length,
        (0, buffer_layout_1.blob)((0, buffer_layout_1.offset)(length, -length.span), "data")
      ]);
      return new WrappedLayout2(layout, ({ data }) => data, (data) => ({ data }), property);
    }
    exports2.vecU8 = vecU82;
    function str2(property) {
      return new WrappedLayout2(vecU82(), (data) => data.toString("utf-8"), (s) => Buffer.from(s, "utf-8"), property);
    }
    exports2.str = str2;
    function rustEnum2(variants, property, discriminant) {
      const unionLayout = (0, buffer_layout_1.union)(discriminant !== null && discriminant !== void 0 ? discriminant : (0, buffer_layout_1.u8)(), property);
      variants.forEach((variant, index2) => unionLayout.addVariant(index2, variant, variant.property));
      return unionLayout;
    }
    exports2.rustEnum = rustEnum2;
    function array4(elementLayout, length, property) {
      const layout = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.seq)(elementLayout, length, "values")
      ]);
      return new WrappedLayout2(layout, ({ values }) => values, (values) => ({ values }), property);
    }
    exports2.array = array4;
    var MapEntryLayout = class extends buffer_layout_1.Layout {
      constructor(keyLayout, valueLayout, property) {
        super(keyLayout.span + valueLayout.span, property);
        this.keyLayout = keyLayout;
        this.valueLayout = valueLayout;
      }
      decode(b, offset3) {
        offset3 = offset3 || 0;
        const key = this.keyLayout.decode(b, offset3);
        const value = this.valueLayout.decode(b, offset3 + this.keyLayout.getSpan(b, offset3));
        return [key, value];
      }
      encode(src, b, offset3) {
        offset3 = offset3 || 0;
        const keyBytes = this.keyLayout.encode(src[0], b, offset3);
        const valueBytes = this.valueLayout.encode(src[1], b, offset3 + keyBytes);
        return keyBytes + valueBytes;
      }
      getSpan(b, offset3) {
        return this.keyLayout.getSpan(b, offset3) + this.valueLayout.getSpan(b, offset3);
      }
    };
    function map(keyLayout, valueLayout, property) {
      const length = (0, buffer_layout_1.u32)("length");
      const layout = (0, buffer_layout_1.struct)([
        length,
        (0, buffer_layout_1.seq)(new MapEntryLayout(keyLayout, valueLayout), (0, buffer_layout_1.offset)(length, -length.span), "values")
      ]);
      return new WrappedLayout2(layout, ({ values }) => new Map(values), (values) => ({ values: Array.from(values.entries()) }), property);
    }
    exports2.map = map;
  }
});

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@coral-xyz/anchor/dist/browser/index.js
var import_buffer2 = __toESM(require_buffer());
init_index_browser_esm();
init_index_browser_esm();
var import_bn2 = __toESM(require_bn());
var import_bn3 = __toESM(require_bn());
var import_bs582 = __toESM(require_bs58());
var base64$1 = __toESM(require_base64_js());
var import_camelcase = __toESM(require_camelcase());
var import_js_sha256 = __toESM(require_sha256());
var borsh = __toESM(require_dist());

// node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f2;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f2 = tree[n * 2];
    s.opt_len += f2 * (bits + xbits);
    if (has_stree) {
      s.static_len += f2 * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f2) => {
  return f2 * 2 - (f2 > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str2;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str2 = s.strstart - s.insert;
      s.ins_h = s.window[str2];
      s.ins_h = HASH(s, s.ins_h, s.window[str2 + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
        s.prev[str2 & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str2;
        str2++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method2, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method2 !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method2;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str2 = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
      s.prev[str2 & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str2;
      str2++;
    } while (--n);
    s.strstart = str2;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks2) => {
  let len = 0;
  for (let i = 0, l = chunks2.length; i < l; i++) {
    len += chunks2[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks2.length; i < l; i++) {
    let chunk = chunks2[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str2) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str2);
  }
  let buf, c, c2, m_pos, i, str_len = str2.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str2.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str2.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str2.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str2.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output2;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output2 = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output2[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output2[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output2;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    }
                    while (len > 2) {
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output2[_out++] = from_source[from++];
                      if (len > 1) {
                        output2[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output2[_out++] = output2[from++];
                      if (len > 1) {
                        output2[_out++] = output2[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type3, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root2 = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask3;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root2 = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root2 > max) {
    root2 = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root2 < min) {
    root2 = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type3 === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type3 === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type3 === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root2;
  drop = 0;
  low = -1;
  used = 1 << root2;
  mask3 = used - 1;
  if (type3 === LENS$1 && used > ENOUGH_LENS$1 || type3 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root2 && (huff & mask3) !== low) {
      if (drop === 0) {
        drop = root2;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type3 === LENS$1 && used > ENOUGH_LENS$1 || type3 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask3;
      table[low] = root2 << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root2;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA2 = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output2;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output2 = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA2;
        case EXTRA2:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output2.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output2 = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output2;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output2[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output2[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output2, _out, put - _out) : adler32_1(state.check, output2, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output2, _out, strm.next_out - _out) : adler32_1(state.check, output2, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var inflate_1 = inflate;

// node_modules/@coral-xyz/anchor/dist/browser/index.js
var import_eventemitter3 = __toESM(require_eventemitter3());
var assert$1 = __toESM(require_assert());
function chunks(array4, size) {
  return Array.apply(0, new Array(Math.ceil(array4.length / size))).map((_, index2) => array4.slice(index2 * size, (index2 + 1) * size));
}
var isVersionedTransaction = (tx) => {
  return "version" in tx;
};
function encode$3(data) {
  return data.reduce((str2, byte) => str2 + byte.toString(16).padStart(2, "0"), "0x");
}
function decode$3(data) {
  if (data.indexOf("0x") === 0) {
    data = data.substr(2);
  }
  if (data.length % 2 === 1) {
    data = "0" + data;
  }
  let key = data.match(/.{2}/g);
  if (key === null) {
    return import_buffer2.Buffer.from([]);
  }
  return import_buffer2.Buffer.from(key.map((byte) => parseInt(byte, 16)));
}
var hex = Object.freeze({
  __proto__: null,
  encode: encode$3,
  decode: decode$3
});
function decode$2(array4) {
  const decoder = new TextDecoder("utf-8");
  return decoder.decode(array4);
}
function encode$2(input) {
  const encoder = new TextEncoder();
  return encoder.encode(input);
}
var utf8 = Object.freeze({
  __proto__: null,
  decode: decode$2,
  encode: encode$2
});
function encode$1(data) {
  return import_bs582.default.encode(data);
}
function decode$1(data) {
  return import_bs582.default.decode(data);
}
var bs582 = Object.freeze({
  __proto__: null,
  encode: encode$1,
  decode: decode$1
});
function encode2(data) {
  return base64$1.fromByteArray(data);
}
function decode2(data) {
  return import_buffer2.Buffer.from(base64$1.toByteArray(data));
}
var base64 = Object.freeze({
  __proto__: null,
  encode: encode2,
  decode: decode2
});
var index$1 = Object.freeze({
  __proto__: null,
  hex,
  utf8,
  bs58: bs582,
  base64
});
function parseIdlErrors(idl) {
  const errors = /* @__PURE__ */ new Map();
  if (idl.errors) {
    idl.errors.forEach((e) => {
      var _a;
      let msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;
      errors.set(e.code, msg);
    });
  }
  return errors;
}
function toInstruction(idlIx, ...args) {
  if (idlIx.args.length != args.length) {
    throw new Error("Invalid argument length");
  }
  const ix = {};
  let idx = 0;
  idlIx.args.forEach((ixArg) => {
    ix[ixArg.name] = args[idx];
    idx += 1;
  });
  return ix;
}
function validateAccounts(ixAccounts, accounts = {}) {
  ixAccounts.forEach((acc) => {
    if ("accounts" in acc) {
      validateAccounts(acc.accounts, accounts[acc.name]);
    } else {
      if (accounts[acc.name] === void 0) {
        throw new Error(`Invalid arguments: ${acc.name} not provided.`);
      }
    }
  });
}
function translateAddress(address) {
  return address instanceof PublicKey ? address : new PublicKey(address);
}
var StructError2 = class extends TypeError {
  constructor(failure, failures) {
    let cached;
    const {
      message,
      ...rest
    } = failure;
    const {
      path
    } = failure;
    const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
    super(msg);
    this.value = void 0;
    this.key = void 0;
    this.type = void 0;
    this.refinement = void 0;
    this.path = void 0;
    this.branch = void 0;
    this.failures = void 0;
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      var _cached;
      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
    };
  }
};
function isIterable2(x) {
  return isObject2(x) && typeof x[Symbol.iterator] === "function";
}
function isObject2(x) {
  return typeof x === "object" && x != null;
}
function print2(value) {
  return typeof value === "string" ? JSON.stringify(value) : "" + value;
}
function shiftIterator2(input) {
  const {
    done,
    value
  } = input.next();
  return done ? void 0 : value;
}
function toFailure2(result, context, struct4, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = {
      message: result
    };
  }
  const {
    path,
    branch
  } = context;
  const {
    type: type3
  } = struct4;
  const {
    refinement,
    message = "Expected a value of type `" + type3 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print2(value) + "`"
  } = result;
  return {
    value,
    type: type3,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures2(result, context, struct4, value) {
  if (!isIterable2(result)) {
    result = [result];
  }
  for (const r of result) {
    const failure = toFailure2(r, context, struct4, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run2(value, struct4, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    path = [],
    branch = [value],
    coerce: coerce3 = false,
    mask: mask3 = false
  } = options;
  const ctx = {
    path,
    branch
  };
  if (coerce3) {
    value = struct4.coercer(value, ctx);
    if (mask3 && struct4.type !== "type" && isObject2(struct4.schema) && isObject2(value) && !Array.isArray(value)) {
      for (const key in value) {
        if (struct4.schema[key] === void 0) {
          delete value[key];
        }
      }
    }
  }
  let valid = true;
  for (const failure of struct4.validator(value, ctx)) {
    valid = false;
    yield [failure, void 0];
  }
  for (let [k, v, s] of struct4.entries(value, ctx)) {
    const ts = run2(v, s, {
      path: k === void 0 ? path : [...path, k],
      branch: k === void 0 ? branch : [...branch, v],
      coerce: coerce3,
      mask: mask3
    });
    for (const t of ts) {
      if (t[0]) {
        valid = false;
        yield [t[0], void 0];
      } else if (coerce3) {
        v = t[1];
        if (k === void 0) {
          value = v;
        } else if (value instanceof Map) {
          value.set(k, v);
        } else if (value instanceof Set) {
          value.add(v);
        } else if (isObject2(value)) {
          value[k] = v;
        }
      }
    }
  }
  if (valid) {
    for (const failure of struct4.refiner(value, ctx)) {
      valid = false;
      yield [failure, void 0];
    }
  }
  if (valid) {
    yield [void 0, value];
  }
}
var Struct3 = class {
  constructor(props) {
    this.TYPE = void 0;
    this.type = void 0;
    this.schema = void 0;
    this.coercer = void 0;
    this.validator = void 0;
    this.refiner = void 0;
    this.entries = void 0;
    const {
      type: type3,
      schema,
      validator,
      refiner,
      coercer = (value) => value,
      entries = function* () {
      }
    } = props;
    this.type = type3;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures2(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures2(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(value) {
    return assert4(value, this);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(value) {
    return create2(value, this);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(value) {
    return is2(value, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(value) {
    return mask2(value, this);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(value, options) {
    if (options === void 0) {
      options = {};
    }
    return validate3(value, this, options);
  }
};
function assert4(value, struct4) {
  const result = validate3(value, struct4);
  if (result[0]) {
    throw result[0];
  }
}
function create2(value, struct4) {
  const result = validate3(value, struct4, {
    coerce: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask2(value, struct4) {
  const result = validate3(value, struct4, {
    coerce: true,
    mask: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is2(value, struct4) {
  const result = validate3(value, struct4);
  return !result[0];
}
function validate3(value, struct4, options) {
  if (options === void 0) {
    options = {};
  }
  const tuples = run2(value, struct4, options);
  const tuple2 = shiftIterator2(tuples);
  if (tuple2[0]) {
    const error = new StructError2(tuple2[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v = tuple2[1];
    return [void 0, v];
  }
}
function define3(name, validator) {
  return new Struct3({
    type: name,
    schema: null,
    validator
  });
}
function any2() {
  return define3("any", () => true);
}
function array3(Element) {
  return new Struct3({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i, v] of value.entries()) {
          yield [i, v, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || "Expected an array value, but received: " + print2(value);
    }
  });
}
function boolean2() {
  return define3("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function literal2(constant) {
  const description = print2(constant);
  const t = typeof constant;
  return new Struct3({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
    validator(value) {
      return value === constant || "Expected the literal `" + description + "`, but received: " + print2(value);
    }
  });
}
function nullable2(struct4) {
  return new Struct3({
    ...struct4,
    validator: (value, ctx) => value === null || struct4.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct4.refiner(value, ctx)
  });
}
function number3() {
  return define3("number", (value) => {
    return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print2(value);
  });
}
function optional2(struct4) {
  return new Struct3({
    ...struct4,
    validator: (value, ctx) => value === void 0 || struct4.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct4.refiner(value, ctx)
  });
}
function string2() {
  return define3("string", (value) => {
    return typeof value === "string" || "Expected a string, but received: " + print2(value);
  });
}
function type2(schema) {
  const keys = Object.keys(schema);
  return new Struct3({
    type: "type",
    schema,
    *entries(value) {
      if (isObject2(value)) {
        for (const k of keys) {
          yield [k, value[k], schema[k]];
        }
      }
    },
    validator(value) {
      return isObject2(value) || "Expected an object, but received: " + print2(value);
    }
  });
}
function union$1(Structs) {
  const description = Structs.map((s) => s.type).join(" | ");
  return new Struct3({
    type: "union",
    schema: null,
    coercer(value, ctx) {
      const firstMatch = Structs.find((s) => {
        const [e] = s.validate(value, {
          coerce: true
        });
        return !e;
      }) || unknown2();
      return firstMatch.coercer(value, ctx);
    },
    validator(value, ctx) {
      const failures = [];
      for (const S of Structs) {
        const [...tuples] = run2(value, S, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print2(value), ...failures];
    }
  });
}
function unknown2() {
  return define3("unknown", () => true);
}
function coerce2(struct4, condition, coercer) {
  return new Struct3({
    ...struct4,
    coercer: (value, ctx) => {
      return is2(value, condition) ? struct4.coercer(coercer(value, ctx), ctx) : struct4.coercer(value, ctx);
    }
  });
}
async function invoke(programId, accounts, data, provider) {
  programId = translateAddress(programId);
  if (!provider) {
    provider = getProvider();
  }
  const tx = new Transaction();
  tx.add(new TransactionInstruction({
    programId,
    keys: accounts !== null && accounts !== void 0 ? accounts : [],
    data
  }));
  if (provider.sendAndConfirm === void 0) {
    throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
  }
  return await provider.sendAndConfirm(tx, []);
}
var GET_MULTIPLE_ACCOUNTS_LIMIT = 99;
async function getMultipleAccounts(connection, publicKeys, commitment) {
  const results = await getMultipleAccountsAndContext(connection, publicKeys, commitment);
  return results.map((result) => {
    return result ? { publicKey: result.publicKey, account: result.account } : null;
  });
}
async function getMultipleAccountsAndContext(connection, publicKeys, commitment) {
  if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {
    return await getMultipleAccountsAndContextCore(connection, publicKeys, commitment);
  } else {
    const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);
    const results = await Promise.all(batches.map((batch) => getMultipleAccountsAndContextCore(connection, batch, commitment)));
    return results.flat();
  }
}
async function getMultipleAccountsAndContextCore(connection, publicKeys, commitmentOverride) {
  const commitment = commitmentOverride !== null && commitmentOverride !== void 0 ? commitmentOverride : connection.commitment;
  const { value: accountInfos, context } = await connection.getMultipleAccountsInfoAndContext(publicKeys, commitment);
  const accounts = accountInfos.map((account, idx) => {
    if (account === null) {
      return null;
    }
    return {
      publicKey: publicKeys[idx],
      account,
      context
    };
  });
  return accounts;
}
async function simulateTransaction(connection, transaction, signers, commitment, includeAccounts) {
  if (signers && signers.length > 0) {
    transaction.sign(...signers);
  }
  const message = transaction._compile();
  const signData = message.serialize();
  const wireTransaction = transaction._serialize(signData);
  const encodedTransaction = wireTransaction.toString("base64");
  const config = {
    encoding: "base64",
    commitment: commitment !== null && commitment !== void 0 ? commitment : connection.commitment
  };
  if (includeAccounts) {
    const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
    config["accounts"] = {
      encoding: "base64",
      addresses
    };
  }
  if (signers) {
    config.sigVerify = true;
  }
  const args = [encodedTransaction, config];
  const unsafeRes = await connection._rpcRequest("simulateTransaction", args);
  const res = create2(unsafeRes, SimulatedTransactionResponseStruct2);
  if ("error" in res) {
    let logs;
    if ("data" in res.error) {
      logs = res.error.data.logs;
      if (logs && Array.isArray(logs)) {
        const traceIndent = "\n    ";
        const logTrace = traceIndent + logs.join(traceIndent);
        console.error(res.error.message, logTrace);
      }
    }
    throw new SendTransactionError("failed to simulate transaction: " + res.error.message, logs);
  }
  return res.result;
}
function jsonRpcResult2(schema) {
  return coerce2(createRpcResult2(schema), UnknownRpcResult2, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create2(value.result, schema)
      };
    }
  });
}
var UnknownRpcResult2 = createRpcResult2(unknown2());
function createRpcResult2(result) {
  return union$1([
    type2({
      jsonrpc: literal2("2.0"),
      id: string2(),
      result
    }),
    type2({
      jsonrpc: literal2("2.0"),
      id: string2(),
      error: type2({
        code: unknown2(),
        message: string2(),
        data: optional2(any2())
      })
    })
  ]);
}
function jsonRpcResultAndContext2(value) {
  return jsonRpcResult2(type2({
    context: type2({
      slot: number3()
    }),
    value
  }));
}
var SimulatedTransactionResponseStruct2 = jsonRpcResultAndContext2(type2({
  err: nullable2(union$1([type2({}), string2()])),
  logs: nullable2(array3(string2())),
  accounts: optional2(nullable2(array3(nullable2(type2({
    executable: boolean2(),
    owner: string2(),
    lamports: number3(),
    data: array3(string2()),
    rentEpoch: optional2(number3())
  }))))),
  unitsConsumed: optional2(number3())
}));
var rpc = Object.freeze({
  __proto__: null,
  invoke,
  getMultipleAccounts,
  getMultipleAccountsAndContext,
  simulateTransaction
});
var AnchorProvider = class {
  /**
   * @param connection The cluster connection where the program is deployed.
   * @param wallet     The wallet used to pay for and sign all transactions.
   * @param opts       Transaction confirmation options to use by default.
   */
  constructor(connection, wallet, opts) {
    this.connection = connection;
    this.wallet = wallet;
    this.opts = opts;
    this.publicKey = wallet === null || wallet === void 0 ? void 0 : wallet.publicKey;
  }
  static defaultOptions() {
    return {
      preflightCommitment: "processed",
      commitment: "processed"
    };
  }
  /**
   * Returns a `Provider` with a wallet read from the local filesystem.
   *
   * @param url  The network cluster url.
   * @param opts The default transaction confirmation options.
   *
   * (This api is for Node only.)
   */
  static local(url, opts) {
    {
      throw new Error(`Provider local is not available on browser.`);
    }
  }
  /**
   * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment
   * variable
   *
   * (This api is for Node only.)
   */
  static env() {
    {
      throw new Error(`Provider env is not available on browser.`);
    }
  }
  /**
   * Sends the given transaction, paid for and signed by the provider's wallet.
   *
   * @param tx      The transaction to send.
   * @param signers The signers of the transaction.
   * @param opts    Transaction confirmation options.
   */
  async sendAndConfirm(tx, signers, opts) {
    var _a, _b, _c, _d;
    if (opts === void 0) {
      opts = this.opts;
    }
    if (isVersionedTransaction(tx)) {
      if (signers) {
        tx.sign(signers);
      }
    } else {
      tx.feePayer = (_a = tx.feePayer) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
      tx.recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
      if (signers) {
        for (const signer of signers) {
          tx.partialSign(signer);
        }
      }
    }
    tx = await this.wallet.signTransaction(tx);
    const rawTx = tx.serialize();
    try {
      return await sendAndConfirmRawTransaction2(this.connection, rawTx, opts);
    } catch (err2) {
      if (err2 instanceof ConfirmError) {
        const txSig = encode$1(isVersionedTransaction(tx) ? ((_b = tx.signatures) === null || _b === void 0 ? void 0 : _b[0]) || new Uint8Array() : (_c = tx.signature) !== null && _c !== void 0 ? _c : new Uint8Array());
        const failedTx = await this.connection.getTransaction(txSig, {
          commitment: "confirmed"
        });
        if (!failedTx) {
          throw err2;
        } else {
          const logs = (_d = failedTx.meta) === null || _d === void 0 ? void 0 : _d.logMessages;
          throw !logs ? err2 : new SendTransactionError(err2.message, logs);
        }
      } else {
        throw err2;
      }
    }
  }
  /**
   * Similar to `send`, but for an array of transactions and signers.
   * All transactions need to be of the same type, it doesn't support a mix of `VersionedTransaction`s and `Transaction`s.
   *
   * @param txWithSigners Array of transactions and signers.
   * @param opts          Transaction confirmation options.
   */
  async sendAll(txWithSigners, opts) {
    var _a, _b, _c;
    if (opts === void 0) {
      opts = this.opts;
    }
    const recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
    let txs = txWithSigners.map((r) => {
      var _a2, _b2;
      if (isVersionedTransaction(r.tx)) {
        let tx = r.tx;
        if (r.signers) {
          tx.sign(r.signers);
        }
        return tx;
      } else {
        let tx = r.tx;
        let signers = (_a2 = r.signers) !== null && _a2 !== void 0 ? _a2 : [];
        tx.feePayer = (_b2 = tx.feePayer) !== null && _b2 !== void 0 ? _b2 : this.wallet.publicKey;
        tx.recentBlockhash = recentBlockhash;
        signers.forEach((kp) => {
          tx.partialSign(kp);
        });
        return tx;
      }
    });
    const signedTxs = await this.wallet.signAllTransactions(txs);
    const sigs = [];
    for (let k = 0; k < txs.length; k += 1) {
      const tx = signedTxs[k];
      const rawTx = tx.serialize();
      try {
        sigs.push(await sendAndConfirmRawTransaction2(this.connection, rawTx, opts));
      } catch (err2) {
        if (err2 instanceof ConfirmError) {
          const txSig = encode$1(isVersionedTransaction(tx) ? ((_a = tx.signatures) === null || _a === void 0 ? void 0 : _a[0]) || new Uint8Array() : (_b = tx.signature) !== null && _b !== void 0 ? _b : new Uint8Array());
          const failedTx = await this.connection.getTransaction(txSig, {
            commitment: "confirmed"
          });
          if (!failedTx) {
            throw err2;
          } else {
            const logs = (_c = failedTx.meta) === null || _c === void 0 ? void 0 : _c.logMessages;
            throw !logs ? err2 : new SendTransactionError(err2.message, logs);
          }
        } else {
          throw err2;
        }
      }
    }
    return sigs;
  }
  /**
   * Simulates the given transaction, returning emitted logs from execution.
   *
   * @param tx      The transaction to send.
   * @param signers The signers of the transaction. If unset, the transaction
   *                will be simulated with the "sigVerify: false" option. This
   *                allows for simulation of transactions without asking the
   *                wallet for a signature.
   * @param opts    Transaction confirmation options.
   */
  async simulate(tx, signers, commitment, includeAccounts) {
    let recentBlockhash = (await this.connection.getLatestBlockhash(commitment !== null && commitment !== void 0 ? commitment : this.connection.commitment)).blockhash;
    let result;
    if (isVersionedTransaction(tx)) {
      if (signers) {
        tx.sign(signers);
        tx = await this.wallet.signTransaction(tx);
      }
      result = await this.connection.simulateTransaction(tx, { commitment });
    } else {
      tx.feePayer = tx.feePayer || this.wallet.publicKey;
      tx.recentBlockhash = recentBlockhash;
      if (signers) {
        tx = await this.wallet.signTransaction(tx);
      }
      result = await simulateTransaction(this.connection, tx, signers, commitment, includeAccounts);
    }
    if (result.value.err) {
      throw new SimulateError(result.value);
    }
    return result.value;
  }
};
var SimulateError = class extends Error {
  constructor(simulationResponse, message) {
    super(message);
    this.simulationResponse = simulationResponse;
  }
};
async function sendAndConfirmRawTransaction2(connection, rawTransaction, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment
  };
  const signature2 = await connection.sendRawTransaction(rawTransaction, sendOptions);
  const status = (await connection.confirmTransaction(signature2, options && options.commitment)).value;
  if (status.err) {
    throw new ConfirmError(`Raw transaction ${signature2} failed (${JSON.stringify(status)})`);
  }
  return signature2;
}
var ConfirmError = class extends Error {
  constructor(message) {
    super(message);
  }
};
function setProvider(provider) {
  _provider = provider;
}
function getProvider() {
  if (_provider === null) {
    return AnchorProvider.local();
  }
  return _provider;
}
var _provider = null;
var _AVAILABLE_FEATURES = /* @__PURE__ */ new Set(["anchor-deprecated-state", "debug-logs"]);
var _FEATURES = /* @__PURE__ */ new Map();
function set(key) {
  if (!_AVAILABLE_FEATURES.has(key)) {
    throw new Error("Invalid feature");
  }
  _FEATURES.set(key, true);
}
function isSet(key) {
  return _FEATURES.get(key) !== void 0;
}
var features = Object.freeze({
  __proto__: null,
  set,
  isSet
});
var IdlError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "IdlError";
  }
};
var ProgramErrorStack = class {
  constructor(stack) {
    this.stack = stack;
  }
  static parse(logs) {
    var _a;
    const programKeyRegex = /^Program (\w*) invoke/;
    const successRegex = /^Program \w* success/;
    const programStack = [];
    for (let i = 0; i < logs.length; i++) {
      if (successRegex.exec(logs[i])) {
        programStack.pop();
        continue;
      }
      const programKey = (_a = programKeyRegex.exec(logs[i])) === null || _a === void 0 ? void 0 : _a[1];
      if (!programKey) {
        continue;
      }
      programStack.push(new PublicKey(programKey));
    }
    return new ProgramErrorStack(programStack);
  }
};
var AnchorError = class extends Error {
  constructor(errorCode, errorMessage, errorLogs, logs, origin, comparedValues) {
    super(errorLogs.join("\n").replace("Program log: ", ""));
    this.errorLogs = errorLogs;
    this.logs = logs;
    this.error = { errorCode, errorMessage, comparedValues, origin };
    this._programErrorStack = ProgramErrorStack.parse(logs);
  }
  static parse(logs) {
    if (!logs) {
      return null;
    }
    const anchorErrorLogIndex = logs.findIndex((log) => log.startsWith("Program log: AnchorError"));
    if (anchorErrorLogIndex === -1) {
      return null;
    }
    const anchorErrorLog = logs[anchorErrorLogIndex];
    const errorLogs = [anchorErrorLog];
    let comparedValues;
    if (anchorErrorLogIndex + 1 < logs.length) {
      if (logs[anchorErrorLogIndex + 1] === "Program log: Left:") {
        const pubkeyRegex = /^Program log: (.*)$/;
        const leftPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 2])[1];
        const rightPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 4])[1];
        comparedValues = [
          new PublicKey(leftPubkey),
          new PublicKey(rightPubkey)
        ];
        errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 5));
      } else if (logs[anchorErrorLogIndex + 1].startsWith("Program log: Left:")) {
        const valueRegex = /^Program log: (Left|Right): (.*)$/;
        const leftValue = valueRegex.exec(logs[anchorErrorLogIndex + 1])[2];
        const rightValue = valueRegex.exec(logs[anchorErrorLogIndex + 2])[2];
        errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 3));
        comparedValues = [leftValue, rightValue];
      }
    }
    const regexNoInfo = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
    const noInfoAnchorErrorLog = regexNoInfo.exec(anchorErrorLog);
    const regexFileLine = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
    const fileLineAnchorErrorLog = regexFileLine.exec(anchorErrorLog);
    const regexAccountName = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
    const accountNameAnchorErrorLog = regexAccountName.exec(anchorErrorLog);
    if (noInfoAnchorErrorLog) {
      const [errorCodeString, errorNumber, errorMessage] = noInfoAnchorErrorLog.slice(1, 4);
      const errorCode = {
        code: errorCodeString,
        number: parseInt(errorNumber)
      };
      return new AnchorError(errorCode, errorMessage, errorLogs, logs, void 0, comparedValues);
    } else if (fileLineAnchorErrorLog) {
      const [file, line, errorCodeString, errorNumber, errorMessage] = fileLineAnchorErrorLog.slice(1, 6);
      const errorCode = {
        code: errorCodeString,
        number: parseInt(errorNumber)
      };
      const fileLine = { file, line: parseInt(line) };
      return new AnchorError(errorCode, errorMessage, errorLogs, logs, fileLine, comparedValues);
    } else if (accountNameAnchorErrorLog) {
      const [accountName, errorCodeString, errorNumber, errorMessage] = accountNameAnchorErrorLog.slice(1, 5);
      const origin = accountName;
      const errorCode = {
        code: errorCodeString,
        number: parseInt(errorNumber)
      };
      return new AnchorError(errorCode, errorMessage, errorLogs, logs, origin, comparedValues);
    } else {
      return null;
    }
  }
  get program() {
    return this._programErrorStack.stack[this._programErrorStack.stack.length - 1];
  }
  get programErrorStack() {
    return this._programErrorStack.stack;
  }
  toString() {
    return this.message;
  }
};
var ProgramError = class extends Error {
  constructor(code, msg, logs) {
    super();
    this.code = code;
    this.msg = msg;
    this.logs = logs;
    if (logs) {
      this._programErrorStack = ProgramErrorStack.parse(logs);
    }
  }
  static parse(err2, idlErrors) {
    const errString = err2.toString();
    let unparsedErrorCode;
    if (errString.includes("custom program error:")) {
      let components = errString.split("custom program error: ");
      if (components.length !== 2) {
        return null;
      } else {
        unparsedErrorCode = components[1];
      }
    } else {
      const matches = errString.match(/"Custom":([0-9]+)}/g);
      if (!matches || matches.length > 1) {
        return null;
      }
      unparsedErrorCode = matches[0].match(/([0-9]+)/g)[0];
    }
    let errorCode;
    try {
      errorCode = parseInt(unparsedErrorCode);
    } catch (parseErr) {
      return null;
    }
    let errorMsg = idlErrors.get(errorCode);
    if (errorMsg !== void 0) {
      return new ProgramError(errorCode, errorMsg, err2.logs);
    }
    errorMsg = LangErrorMessage.get(errorCode);
    if (errorMsg !== void 0) {
      return new ProgramError(errorCode, errorMsg, err2.logs);
    }
    return null;
  }
  get program() {
    var _a;
    return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack[this._programErrorStack.stack.length - 1];
  }
  get programErrorStack() {
    var _a;
    return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack;
  }
  toString() {
    return this.msg;
  }
};
function translateError(err2, idlErrors) {
  if (isSet("debug-logs")) {
    console.log("Translating error:", err2);
  }
  const anchorError = AnchorError.parse(err2.logs);
  if (anchorError) {
    return anchorError;
  }
  const programError = ProgramError.parse(err2, idlErrors);
  if (programError) {
    return programError;
  }
  if (err2.logs) {
    const handler = {
      get: function(target, prop) {
        if (prop === "programErrorStack") {
          return target.programErrorStack.stack;
        } else if (prop === "program") {
          return target.programErrorStack.stack[err2.programErrorStack.stack.length - 1];
        } else {
          return Reflect.get(...arguments);
        }
      }
    };
    err2.programErrorStack = ProgramErrorStack.parse(err2.logs);
    return new Proxy(err2, handler);
  }
  return err2;
}
var LangErrorCode = {
  // Instructions.
  InstructionMissing: 100,
  InstructionFallbackNotFound: 101,
  InstructionDidNotDeserialize: 102,
  InstructionDidNotSerialize: 103,
  // IDL instructions.
  IdlInstructionStub: 1e3,
  IdlInstructionInvalidProgram: 1001,
  // Constraints.
  ConstraintMut: 2e3,
  ConstraintHasOne: 2001,
  ConstraintSigner: 2002,
  ConstraintRaw: 2003,
  ConstraintOwner: 2004,
  ConstraintRentExempt: 2005,
  ConstraintSeeds: 2006,
  ConstraintExecutable: 2007,
  ConstraintState: 2008,
  ConstraintAssociated: 2009,
  ConstraintAssociatedInit: 2010,
  ConstraintClose: 2011,
  ConstraintAddress: 2012,
  ConstraintZero: 2013,
  ConstraintTokenMint: 2014,
  ConstraintTokenOwner: 2015,
  ConstraintMintMintAuthority: 2016,
  ConstraintMintFreezeAuthority: 2017,
  ConstraintMintDecimals: 2018,
  ConstraintSpace: 2019,
  ConstraintAccountIsNone: 2020,
  // Require.
  RequireViolated: 2500,
  RequireEqViolated: 2501,
  RequireKeysEqViolated: 2502,
  RequireNeqViolated: 2503,
  RequireKeysNeqViolated: 2504,
  RequireGtViolated: 2505,
  RequireGteViolated: 2506,
  // Accounts.
  AccountDiscriminatorAlreadySet: 3e3,
  AccountDiscriminatorNotFound: 3001,
  AccountDiscriminatorMismatch: 3002,
  AccountDidNotDeserialize: 3003,
  AccountDidNotSerialize: 3004,
  AccountNotEnoughKeys: 3005,
  AccountNotMutable: 3006,
  AccountOwnedByWrongProgram: 3007,
  InvalidProgramId: 3008,
  InvalidProgramExecutable: 3009,
  AccountNotSigner: 3010,
  AccountNotSystemOwned: 3011,
  AccountNotInitialized: 3012,
  AccountNotProgramData: 3013,
  AccountNotAssociatedTokenAccount: 3014,
  AccountSysvarMismatch: 3015,
  AccountReallocExceedsLimit: 3016,
  AccountDuplicateReallocs: 3017,
  // Miscellaneous
  DeclaredProgramIdMismatch: 4100,
  // Used for APIs that shouldn't be used anymore.
  Deprecated: 5e3
};
var LangErrorMessage = /* @__PURE__ */ new Map([
  // Instructions.
  [
    LangErrorCode.InstructionMissing,
    "8 byte instruction identifier not provided"
  ],
  [
    LangErrorCode.InstructionFallbackNotFound,
    "Fallback functions are not supported"
  ],
  [
    LangErrorCode.InstructionDidNotDeserialize,
    "The program could not deserialize the given instruction"
  ],
  [
    LangErrorCode.InstructionDidNotSerialize,
    "The program could not serialize the given instruction"
  ],
  // Idl instructions.
  [
    LangErrorCode.IdlInstructionStub,
    "The program was compiled without idl instructions"
  ],
  [
    LangErrorCode.IdlInstructionInvalidProgram,
    "The transaction was given an invalid program for the IDL instruction"
  ],
  // Constraints.
  [LangErrorCode.ConstraintMut, "A mut constraint was violated"],
  [LangErrorCode.ConstraintHasOne, "A has one constraint was violated"],
  [LangErrorCode.ConstraintSigner, "A signer constraint was violated"],
  [LangErrorCode.ConstraintRaw, "A raw constraint was violated"],
  [LangErrorCode.ConstraintOwner, "An owner constraint was violated"],
  [
    LangErrorCode.ConstraintRentExempt,
    "A rent exemption constraint was violated"
  ],
  [LangErrorCode.ConstraintSeeds, "A seeds constraint was violated"],
  [LangErrorCode.ConstraintExecutable, "An executable constraint was violated"],
  [
    LangErrorCode.ConstraintState,
    "Deprecated Error, feel free to replace with something else"
  ],
  [LangErrorCode.ConstraintAssociated, "An associated constraint was violated"],
  [
    LangErrorCode.ConstraintAssociatedInit,
    "An associated init constraint was violated"
  ],
  [LangErrorCode.ConstraintClose, "A close constraint was violated"],
  [LangErrorCode.ConstraintAddress, "An address constraint was violated"],
  [LangErrorCode.ConstraintZero, "Expected zero account discriminant"],
  [LangErrorCode.ConstraintTokenMint, "A token mint constraint was violated"],
  [LangErrorCode.ConstraintTokenOwner, "A token owner constraint was violated"],
  [
    LangErrorCode.ConstraintMintMintAuthority,
    "A mint mint authority constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintFreezeAuthority,
    "A mint freeze authority constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintDecimals,
    "A mint decimals constraint was violated"
  ],
  [LangErrorCode.ConstraintSpace, "A space constraint was violated"],
  [
    LangErrorCode.ConstraintAccountIsNone,
    "A required account for the constraint is None"
  ],
  // Require.
  [LangErrorCode.RequireViolated, "A require expression was violated"],
  [LangErrorCode.RequireEqViolated, "A require_eq expression was violated"],
  [
    LangErrorCode.RequireKeysEqViolated,
    "A require_keys_eq expression was violated"
  ],
  [LangErrorCode.RequireNeqViolated, "A require_neq expression was violated"],
  [
    LangErrorCode.RequireKeysNeqViolated,
    "A require_keys_neq expression was violated"
  ],
  [LangErrorCode.RequireGtViolated, "A require_gt expression was violated"],
  [LangErrorCode.RequireGteViolated, "A require_gte expression was violated"],
  // Accounts.
  [
    LangErrorCode.AccountDiscriminatorAlreadySet,
    "The account discriminator was already set on this account"
  ],
  [
    LangErrorCode.AccountDiscriminatorNotFound,
    "No 8 byte discriminator was found on the account"
  ],
  [
    LangErrorCode.AccountDiscriminatorMismatch,
    "8 byte discriminator did not match what was expected"
  ],
  [LangErrorCode.AccountDidNotDeserialize, "Failed to deserialize the account"],
  [LangErrorCode.AccountDidNotSerialize, "Failed to serialize the account"],
  [
    LangErrorCode.AccountNotEnoughKeys,
    "Not enough account keys given to the instruction"
  ],
  [LangErrorCode.AccountNotMutable, "The given account is not mutable"],
  [
    LangErrorCode.AccountOwnedByWrongProgram,
    "The given account is owned by a different program than expected"
  ],
  [LangErrorCode.InvalidProgramId, "Program ID was not as expected"],
  [LangErrorCode.InvalidProgramExecutable, "Program account is not executable"],
  [LangErrorCode.AccountNotSigner, "The given account did not sign"],
  [
    LangErrorCode.AccountNotSystemOwned,
    "The given account is not owned by the system program"
  ],
  [
    LangErrorCode.AccountNotInitialized,
    "The program expected this account to be already initialized"
  ],
  [
    LangErrorCode.AccountNotProgramData,
    "The given account is not a program data account"
  ],
  [
    LangErrorCode.AccountNotAssociatedTokenAccount,
    "The given account is not the associated token account"
  ],
  [
    LangErrorCode.AccountSysvarMismatch,
    "The given public key does not match the required sysvar"
  ],
  [
    LangErrorCode.AccountReallocExceedsLimit,
    "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"
  ],
  [
    LangErrorCode.AccountDuplicateReallocs,
    "The account was duplicated for more than one reallocation"
  ],
  // Miscellaneous
  [
    LangErrorCode.DeclaredProgramIdMismatch,
    "The declared program id does not match the actual program id"
  ],
  // Deprecated
  [
    LangErrorCode.Deprecated,
    "The API being used is deprecated and should no longer be used"
  ]
]);
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function lowerCase(str2) {
  return str2.toLowerCase();
}
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
function noCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
  var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  var start = 0;
  var end = result.length;
  while (result.charAt(start) === "\0")
    start++;
  while (result.charAt(end - 1) === "\0")
    end--;
  return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
function replace(input, re, value) {
  if (re instanceof RegExp)
    return input.replace(re, value);
  return re.reduce(function(input2, re2) {
    return input2.replace(re2, value);
  }, input);
}
function dotCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return noCase(input, __assign({ delimiter: "." }, options));
}
function snakeCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return dotCase(input, __assign$1({ delimiter: "_" }, options));
}
var IdlCoder = class {
  static fieldLayout(field, types) {
    const fieldName = field.name !== void 0 ? (0, import_camelcase.default)(field.name) : void 0;
    switch (field.type) {
      case "bool": {
        return borsh.bool(fieldName);
      }
      case "u8": {
        return borsh.u8(fieldName);
      }
      case "i8": {
        return borsh.i8(fieldName);
      }
      case "u16": {
        return borsh.u16(fieldName);
      }
      case "i16": {
        return borsh.i16(fieldName);
      }
      case "u32": {
        return borsh.u32(fieldName);
      }
      case "i32": {
        return borsh.i32(fieldName);
      }
      case "f32": {
        return borsh.f32(fieldName);
      }
      case "u64": {
        return borsh.u64(fieldName);
      }
      case "i64": {
        return borsh.i64(fieldName);
      }
      case "f64": {
        return borsh.f64(fieldName);
      }
      case "u128": {
        return borsh.u128(fieldName);
      }
      case "i128": {
        return borsh.i128(fieldName);
      }
      case "u256": {
        return borsh.u256(fieldName);
      }
      case "i256": {
        return borsh.i256(fieldName);
      }
      case "bytes": {
        return borsh.vecU8(fieldName);
      }
      case "string": {
        return borsh.str(fieldName);
      }
      case "publicKey": {
        return borsh.publicKey(fieldName);
      }
      default: {
        if ("vec" in field.type) {
          return borsh.vec(IdlCoder.fieldLayout({
            name: void 0,
            type: field.type.vec
          }, types), fieldName);
        } else if ("option" in field.type) {
          return borsh.option(IdlCoder.fieldLayout({
            name: void 0,
            type: field.type.option
          }, types), fieldName);
        } else if ("defined" in field.type) {
          const defined = field.type.defined;
          if (types === void 0) {
            throw new IdlError("User defined types not provided");
          }
          const filtered = types.filter((t) => t.name === defined);
          if (filtered.length !== 1) {
            throw new IdlError(`Type not found: ${JSON.stringify(field)}`);
          }
          return IdlCoder.typeDefLayout(filtered[0], types, fieldName);
        } else if ("array" in field.type) {
          let arrayTy = field.type.array[0];
          let arrayLen = field.type.array[1];
          let innerLayout = IdlCoder.fieldLayout({
            name: void 0,
            type: arrayTy
          }, types);
          return borsh.array(innerLayout, arrayLen, fieldName);
        } else {
          throw new Error(`Not yet implemented: ${field}`);
        }
      }
    }
  }
  static typeDefLayout(typeDef, types = [], name) {
    if (typeDef.type.kind === "struct") {
      const fieldLayouts = typeDef.type.fields.map((field) => {
        const x = IdlCoder.fieldLayout(field, types);
        return x;
      });
      return borsh.struct(fieldLayouts, name);
    } else if (typeDef.type.kind === "enum") {
      let variants = typeDef.type.variants.map((variant) => {
        const name2 = (0, import_camelcase.default)(variant.name);
        if (variant.fields === void 0) {
          return borsh.struct([], name2);
        }
        const fieldLayouts = variant.fields.map((f2, i) => {
          if (!f2.hasOwnProperty("name")) {
            return IdlCoder.fieldLayout({ type: f2, name: i.toString() }, types);
          }
          return IdlCoder.fieldLayout(f2, types);
        });
        return borsh.struct(fieldLayouts, name2);
      });
      if (name !== void 0) {
        return borsh.rustEnum(variants).replicate(name);
      }
      return borsh.rustEnum(variants, name);
    } else {
      throw new Error(`Unknown type kint: ${typeDef}`);
    }
  }
};
var SIGHASH_GLOBAL_NAMESPACE = "global";
var BorshInstructionCoder = class {
  constructor(idl) {
    this.idl = idl;
    this.ixLayout = BorshInstructionCoder.parseIxLayout(idl);
    const sighashLayouts = /* @__PURE__ */ new Map();
    idl.instructions.forEach((ix) => {
      const sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);
      sighashLayouts.set(import_bs582.default.encode(sh), {
        layout: this.ixLayout.get(ix.name),
        name: ix.name
      });
    });
    this.sighashLayouts = sighashLayouts;
  }
  /**
   * Encodes a program instruction.
   */
  encode(ixName, ix) {
    return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);
  }
  _encode(nameSpace, ixName, ix) {
    const buffer = import_buffer2.Buffer.alloc(1e3);
    const methodName = (0, import_camelcase.default)(ixName);
    const layout = this.ixLayout.get(methodName);
    if (!layout) {
      throw new Error(`Unknown method: ${methodName}`);
    }
    const len = layout.encode(ix, buffer);
    const data = buffer.slice(0, len);
    return import_buffer2.Buffer.concat([sighash(nameSpace, ixName), data]);
  }
  static parseIxLayout(idl) {
    const ixLayouts = idl.instructions.map((ix) => {
      let fieldLayouts = ix.args.map((arg) => {
        var _a, _b;
        return IdlCoder.fieldLayout(arg, Array.from([...(_a = idl.accounts) !== null && _a !== void 0 ? _a : [], ...(_b = idl.types) !== null && _b !== void 0 ? _b : []]));
      });
      const name = (0, import_camelcase.default)(ix.name);
      return [name, borsh.struct(fieldLayouts, name)];
    });
    return new Map(ixLayouts);
  }
  /**
   * Decodes a program instruction.
   */
  decode(ix, encoding = "hex") {
    if (typeof ix === "string") {
      ix = encoding === "hex" ? import_buffer2.Buffer.from(ix, "hex") : import_bs582.default.decode(ix);
    }
    let sighash2 = import_bs582.default.encode(ix.slice(0, 8));
    let data = ix.slice(8);
    const decoder = this.sighashLayouts.get(sighash2);
    if (!decoder) {
      return null;
    }
    return {
      data: decoder.layout.decode(data),
      name: decoder.name
    };
  }
  /**
   * Returns a formatted table of all the fields in the given instruction data.
   */
  format(ix, accountMetas) {
    return InstructionFormatter.format(ix, accountMetas, this.idl);
  }
};
var InstructionFormatter = class {
  static format(ix, accountMetas, idl) {
    const idlIx = idl.instructions.filter((i) => ix.name === i.name)[0];
    if (idlIx === void 0) {
      console.error("Invalid instruction given");
      return null;
    }
    const args = idlIx.args.map((idlField) => {
      return {
        name: idlField.name,
        type: InstructionFormatter.formatIdlType(idlField.type),
        data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)
      };
    });
    const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);
    const accounts = accountMetas.map((meta, idx) => {
      if (idx < flatIdlAccounts.length) {
        return {
          name: flatIdlAccounts[idx].name,
          ...meta
        };
      } else {
        return {
          name: void 0,
          ...meta
        };
      }
    });
    return {
      args,
      accounts
    };
  }
  static formatIdlType(idlType) {
    if (typeof idlType === "string") {
      return idlType;
    }
    if ("vec" in idlType) {
      return `Vec<${this.formatIdlType(idlType.vec)}>`;
    }
    if ("option" in idlType) {
      return `Option<${this.formatIdlType(idlType.option)}>`;
    }
    if ("defined" in idlType) {
      return idlType.defined;
    }
    if ("array" in idlType) {
      return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;
    }
    throw new Error(`Unknown IDL type: ${idlType}`);
  }
  static formatIdlData(idlField, data, types) {
    if (typeof idlField.type === "string") {
      return data.toString();
    }
    if (idlField.type.hasOwnProperty("vec")) {
      return "[" + data.map((d) => this.formatIdlData({ name: "", type: idlField.type.vec }, d)).join(", ") + "]";
    }
    if (idlField.type.hasOwnProperty("option")) {
      return data === null ? "null" : this.formatIdlData({ name: "", type: idlField.type.option }, data, types);
    }
    if (idlField.type.hasOwnProperty("defined")) {
      if (types === void 0) {
        throw new Error("User defined types not provided");
      }
      const filtered = types.filter((t) => t.name === idlField.type.defined);
      if (filtered.length !== 1) {
        throw new Error(`Type not found: ${idlField.type.defined}`);
      }
      return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);
    }
    return "unknown";
  }
  static formatIdlDataDefined(typeDef, data, types) {
    if (typeDef.type.kind === "struct") {
      const struct4 = typeDef.type;
      const fields = Object.keys(data).map((k) => {
        const f2 = struct4.fields.filter((f3) => f3.name === k)[0];
        if (f2 === void 0) {
          throw new Error("Unable to find type");
        }
        return k + ": " + InstructionFormatter.formatIdlData(f2, data[k], types);
      }).join(", ");
      return "{ " + fields + " }";
    } else {
      if (typeDef.type.variants.length === 0) {
        return "{}";
      }
      if (typeDef.type.variants[0].name) {
        const variants = typeDef.type.variants;
        const variant = Object.keys(data)[0];
        const enumType = data[variant];
        const namedFields = Object.keys(enumType).map((f2) => {
          var _a;
          const fieldData = enumType[f2];
          const idlField = (_a = variants[variant]) === null || _a === void 0 ? void 0 : _a.filter((v) => v.name === f2)[0];
          if (idlField === void 0) {
            throw new Error("Unable to find variant");
          }
          return f2 + ": " + InstructionFormatter.formatIdlData(idlField, fieldData, types);
        }).join(", ");
        const variantName = (0, import_camelcase.default)(variant, { pascalCase: true });
        if (namedFields.length === 0) {
          return variantName;
        }
        return `${variantName} { ${namedFields} }`;
      } else {
        return "Tuple formatting not yet implemented";
      }
    }
  }
  static flattenIdlAccounts(accounts, prefix) {
    return accounts.map((account) => {
      const accName = sentenceCase(account.name);
      if (account.hasOwnProperty("accounts")) {
        const newPrefix = prefix ? `${prefix} > ${accName}` : accName;
        return InstructionFormatter.flattenIdlAccounts(account.accounts, newPrefix);
      } else {
        return {
          ...account,
          name: prefix ? `${prefix} > ${accName}` : accName
        };
      }
    }).flat();
  }
};
function sentenceCase(field) {
  const result = field.replace(/([A-Z])/g, " $1");
  return result.charAt(0).toUpperCase() + result.slice(1);
}
function sighash(nameSpace, ixName) {
  let name = snakeCase(ixName);
  let preimage = `${nameSpace}:${name}`;
  return import_buffer2.Buffer.from(import_js_sha256.sha256.digest(preimage)).slice(0, 8);
}
function accountSize(idl, idlAccount) {
  if (idlAccount.type.kind === "enum") {
    let variantSizes = idlAccount.type.variants.map((variant) => {
      if (variant.fields === void 0) {
        return 0;
      }
      return variant.fields.map((f2) => {
        if (!(typeof f2 === "object" && "name" in f2)) {
          throw new Error("Tuple enum variants not yet implemented.");
        }
        return typeSize(idl, f2.type);
      }).reduce((a, b) => a + b);
    });
    return Math.max(...variantSizes) + 1;
  }
  if (idlAccount.type.fields === void 0) {
    return 0;
  }
  return idlAccount.type.fields.map((f2) => typeSize(idl, f2.type)).reduce((a, b) => a + b, 0);
}
function typeSize(idl, ty) {
  var _a, _b;
  switch (ty) {
    case "bool":
      return 1;
    case "u8":
      return 1;
    case "i8":
      return 1;
    case "i16":
      return 2;
    case "u16":
      return 2;
    case "u32":
      return 4;
    case "i32":
      return 4;
    case "f32":
      return 4;
    case "u64":
      return 8;
    case "i64":
      return 8;
    case "f64":
      return 8;
    case "u128":
      return 16;
    case "i128":
      return 16;
    case "u256":
      return 32;
    case "i256":
      return 32;
    case "bytes":
      return 1;
    case "string":
      return 1;
    case "publicKey":
      return 32;
    default:
      if ("vec" in ty) {
        return 1;
      }
      if ("option" in ty) {
        return 1 + typeSize(idl, ty.option);
      }
      if ("coption" in ty) {
        return 4 + typeSize(idl, ty.coption);
      }
      if ("defined" in ty) {
        const filtered = (_b = (_a = idl.types) === null || _a === void 0 ? void 0 : _a.filter((t) => t.name === ty.defined)) !== null && _b !== void 0 ? _b : [];
        if (filtered.length !== 1) {
          throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);
        }
        let typeDef = filtered[0];
        return accountSize(idl, typeDef);
      }
      if ("array" in ty) {
        let arrayTy = ty.array[0];
        let arraySize = ty.array[1];
        return typeSize(idl, arrayTy) * arraySize;
      }
      throw new Error(`Invalid type ${JSON.stringify(ty)}`);
  }
}
var ACCOUNT_DISCRIMINATOR_SIZE = 8;
var BorshAccountsCoder = class {
  constructor(idl) {
    if (idl.accounts === void 0) {
      this.accountLayouts = /* @__PURE__ */ new Map();
      return;
    }
    const layouts = idl.accounts.map((acc) => {
      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];
    });
    this.accountLayouts = new Map(layouts);
    this.idl = idl;
  }
  async encode(accountName, account) {
    const buffer = import_buffer2.Buffer.alloc(1e3);
    const layout = this.accountLayouts.get(accountName);
    if (!layout) {
      throw new Error(`Unknown account: ${accountName}`);
    }
    const len = layout.encode(account, buffer);
    let accountData = buffer.slice(0, len);
    let discriminator = BorshAccountsCoder.accountDiscriminator(accountName);
    return import_buffer2.Buffer.concat([discriminator, accountData]);
  }
  decode(accountName, data) {
    const discriminator = BorshAccountsCoder.accountDiscriminator(accountName);
    if (discriminator.compare(data.slice(0, 8))) {
      throw new Error("Invalid account discriminator");
    }
    return this.decodeUnchecked(accountName, data);
  }
  decodeAny(data) {
    const accountDescriminator = data.slice(0, 8);
    const accountName = Array.from(this.accountLayouts.keys()).find((key) => BorshAccountsCoder.accountDiscriminator(key).equals(accountDescriminator));
    if (!accountName) {
      throw new Error("Account descriminator not found");
    }
    return this.decodeUnchecked(accountName, data);
  }
  decodeUnchecked(accountName, ix) {
    const data = ix.slice(ACCOUNT_DISCRIMINATOR_SIZE);
    const layout = this.accountLayouts.get(accountName);
    if (!layout) {
      throw new Error(`Unknown account: ${accountName}`);
    }
    return layout.decode(data);
  }
  memcmp(accountName, appendData) {
    const discriminator = BorshAccountsCoder.accountDiscriminator(accountName);
    return {
      offset: 0,
      bytes: import_bs582.default.encode(appendData ? import_buffer2.Buffer.concat([discriminator, appendData]) : discriminator)
    };
  }
  size(idlAccount) {
    var _a;
    return ACCOUNT_DISCRIMINATOR_SIZE + ((_a = accountSize(this.idl, idlAccount)) !== null && _a !== void 0 ? _a : 0);
  }
  /**
   * Calculates and returns a unique 8 byte discriminator prepended to all anchor accounts.
   *
   * @param name The name of the account to calculate the discriminator.
   */
  static accountDiscriminator(name) {
    return import_buffer2.Buffer.from(import_js_sha256.sha256.digest(`account:${(0, import_camelcase.default)(name, {
      pascalCase: true,
      preserveConsecutiveUppercase: true
    })}`)).slice(0, ACCOUNT_DISCRIMINATOR_SIZE);
  }
};
var BorshEventCoder = class {
  constructor(idl) {
    if (idl.events === void 0) {
      this.layouts = /* @__PURE__ */ new Map();
      return;
    }
    const layouts = idl.events.map((event) => {
      let eventTypeDef = {
        name: event.name,
        type: {
          kind: "struct",
          fields: event.fields.map((f2) => {
            return { name: f2.name, type: f2.type };
          })
        }
      };
      return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];
    });
    this.layouts = new Map(layouts);
    this.discriminators = new Map(idl.events === void 0 ? [] : idl.events.map((e) => [
      base64$1.fromByteArray(eventDiscriminator(e.name)),
      e.name
    ]));
  }
  decode(log) {
    let logArr;
    try {
      logArr = import_buffer2.Buffer.from(base64$1.toByteArray(log));
    } catch (e) {
      return null;
    }
    const disc = base64$1.fromByteArray(logArr.slice(0, 8));
    const eventName = this.discriminators.get(disc);
    if (eventName === void 0) {
      return null;
    }
    const layout = this.layouts.get(eventName);
    if (!layout) {
      throw new Error(`Unknown event: ${eventName}`);
    }
    const data = layout.decode(logArr.slice(8));
    return { data, name: eventName };
  }
};
function eventDiscriminator(name) {
  return import_buffer2.Buffer.from(import_js_sha256.sha256.digest(`event:${name}`)).slice(0, 8);
}
var BorshTypesCoder = class {
  constructor(idl) {
    if (idl.types === void 0) {
      this.typeLayouts = /* @__PURE__ */ new Map();
      return;
    }
    const layouts = idl.types.map((acc) => {
      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];
    });
    this.typeLayouts = new Map(layouts);
    this.idl = idl;
  }
  encode(typeName, type3) {
    const buffer = import_buffer2.Buffer.alloc(1e3);
    const layout = this.typeLayouts.get(typeName);
    if (!layout) {
      throw new Error(`Unknown type: ${typeName}`);
    }
    const len = layout.encode(type3, buffer);
    return buffer.slice(0, len);
  }
  decode(typeName, typeData) {
    const layout = this.typeLayouts.get(typeName);
    if (!layout) {
      throw new Error(`Unknown type: ${typeName}`);
    }
    return layout.decode(typeData);
  }
};
var BorshCoder = class {
  constructor(idl) {
    this.instruction = new BorshInstructionCoder(idl);
    this.accounts = new BorshAccountsCoder(idl);
    this.events = new BorshEventCoder(idl);
    this.types = new BorshTypesCoder(idl);
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var Layout = class {
  constructor(span, property) {
    if (!Number.isInteger(span)) {
      throw new TypeError("span must be an integer");
    }
    this.span = span;
    this.property = property;
  }
  /** Function to create an Object into which decoded properties will
   * be written.
   *
   * Used only for layouts that {@link Layout#decode|decode} to Object
   * instances, which means:
   * * {@link Structure}
   * * {@link Union}
   * * {@link VariantLayout}
   * * {@link BitStructure}
   *
   * If left undefined the JavaScript representation of these layouts
   * will be Object instances.
   *
   * See {@link bindConstructorLayout}.
   */
  makeDestinationObject() {
    return {};
  }
  /**
   * Decode from a Buffer into an JavaScript value.
   *
   * @param {Buffer} b - the buffer from which encoded data is read.
   *
   * @param {Number} [offset] - the offset at which the encoded data
   * starts.  If absent a zero offset is inferred.
   *
   * @returns {(Number|Array|Object)} - the value of the decoded data.
   *
   * @abstract
   */
  decode(b, offset3) {
    throw new Error("Layout is abstract");
  }
  /**
   * Encode a JavaScript value into a Buffer.
   *
   * @param {(Number|Array|Object)} src - the value to be encoded into
   * the buffer.  The type accepted depends on the (sub-)type of {@link
   * Layout}.
   *
   * @param {Buffer} b - the buffer into which encoded data will be
   * written.
   *
   * @param {Number} [offset] - the offset at which the encoded data
   * starts.  If absent a zero offset is inferred.
   *
   * @returns {Number} - the number of bytes encoded, including the
   * space skipped for internal padding, but excluding data such as
   * {@link Sequence#count|lengths} when stored {@link
   * ExternalLayout|externally}.  This is the adjustment to `offset`
   * producing the offset where data for the next layout would be
   * written.
   *
   * @abstract
   */
  encode(src, b, offset3) {
    throw new Error("Layout is abstract");
  }
  /**
   * Calculate the span of a specific instance of a layout.
   *
   * @param {Buffer} b - the buffer that contains an encoded instance.
   *
   * @param {Number} [offset] - the offset at which the encoded instance
   * starts.  If absent a zero offset is inferred.
   *
   * @return {Number} - the number of bytes covered by the layout
   * instance.  If this method is not overridden in a subclass the
   * definition-time constant {@link Layout#span|span} will be
   * returned.
   *
   * @throws {RangeError} - if the length of the value cannot be
   * determined.
   */
  getSpan(b, offset3) {
    if (0 > this.span) {
      throw new RangeError("indeterminate span");
    }
    return this.span;
  }
  /**
   * Replicate the layout using a new property.
   *
   * This function must be used to get a structurally-equivalent layout
   * with a different name since all {@link Layout} instances are
   * immutable.
   *
   * **NOTE** This is a shallow copy.  All fields except {@link
   * Layout#property|property} are strictly equal to the origin layout.
   *
   * @param {String} property - the value for {@link
   * Layout#property|property} in the replica.
   *
   * @returns {Layout} - the copy with {@link Layout#property|property}
   * set to `property`.
   */
  replicate(property) {
    const rv = Object.create(this.constructor.prototype);
    Object.assign(rv, this);
    rv.property = property;
    return rv;
  }
  /**
   * Create an object from layout properties and an array of values.
   *
   * **NOTE** This function returns `undefined` if invoked on a layout
   * that does not return its value as an Object.  Objects are
   * returned for things that are a {@link Structure}, which includes
   * {@link VariantLayout|variant layouts} if they are structures, and
   * excludes {@link Union}s.  If you want this feature for a union
   * you must use {@link Union.getVariant|getVariant} to select the
   * desired layout.
   *
   * @param {Array} values - an array of values that correspond to the
   * default order for properties.  As with {@link Layout#decode|decode}
   * layout elements that have no property name are skipped when
   * iterating over the array values.  Only the top-level properties are
   * assigned; arguments are not assigned to properties of contained
   * layouts.  Any unused values are ignored.
   *
   * @return {(Object|undefined)}
   */
  fromArray(values) {
    return void 0;
  }
};
var Layout_2 = Layout;
function nameWithProperty(name, lo) {
  if (lo.property) {
    return name + "[" + lo.property + "]";
  }
  return name;
}
var ExternalLayout = class extends Layout {
  /**
   * Return `true` iff the external layout decodes to an unsigned
   * integer layout.
   *
   * In that case it can be used as the source of {@link
   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
   * or as {@link UnionLayoutDiscriminator#layout|external union
   * discriminators}.
   *
   * @abstract
   */
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
};
var OffsetLayout = class extends ExternalLayout {
  constructor(layout, offset3, property) {
    if (!(layout instanceof Layout)) {
      throw new TypeError("layout must be a Layout");
    }
    if (void 0 === offset3) {
      offset3 = 0;
    } else if (!Number.isInteger(offset3)) {
      throw new TypeError("offset must be integer or undefined");
    }
    super(layout.span, property || layout.property);
    this.layout = layout;
    this.offset = offset3;
  }
  /** @override */
  isCount() {
    return this.layout instanceof UInt || this.layout instanceof UIntBE;
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    return this.layout.decode(b, offset3 + this.offset);
  }
  /** @override */
  encode(src, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    return this.layout.encode(src, b, offset3 + this.offset);
  }
};
var UInt = class extends Layout {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    return b.readUIntLE(offset3, this.span);
  }
  /** @override */
  encode(src, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    b.writeUIntLE(src, offset3, this.span);
    return this.span;
  }
};
var UIntBE = class extends Layout {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    return b.readUIntBE(offset3, this.span);
  }
  /** @override */
  encode(src, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    b.writeUIntBE(src, offset3, this.span);
    return this.span;
  }
};
var V2E32 = Math.pow(2, 32);
function divmodInt64(src) {
  const hi32 = Math.floor(src / V2E32);
  const lo32 = src - hi32 * V2E32;
  return { hi32, lo32 };
}
function roundedInt64(hi32, lo32) {
  return hi32 * V2E32 + lo32;
}
var NearUInt64 = class extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const lo32 = b.readUInt32LE(offset3);
    const hi32 = b.readUInt32LE(offset3 + 4);
    return roundedInt64(hi32, lo32);
  }
  /** @override */
  encode(src, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const split2 = divmodInt64(src);
    b.writeUInt32LE(split2.lo32, offset3);
    b.writeUInt32LE(split2.hi32, offset3 + 4);
    return 8;
  }
};
var NearInt64 = class extends Layout {
  constructor(property) {
    super(8, property);
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const lo32 = b.readUInt32LE(offset3);
    const hi32 = b.readInt32LE(offset3 + 4);
    return roundedInt64(hi32, lo32);
  }
  /** @override */
  encode(src, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const split2 = divmodInt64(src);
    b.writeUInt32LE(split2.lo32, offset3);
    b.writeInt32LE(split2.hi32, offset3 + 4);
    return 8;
  }
};
var Structure = class extends Layout {
  constructor(fields, property, decodePrefixes) {
    if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {
      throw new TypeError("fields must be array of Layout instances");
    }
    if ("boolean" === typeof property && void 0 === decodePrefixes) {
      decodePrefixes = property;
      property = void 0;
    }
    for (const fd of fields) {
      if (0 > fd.span && void 0 === fd.property) {
        throw new Error("fields cannot contain unnamed variable-length layout");
      }
    }
    let span = -1;
    try {
      span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
    } catch (e) {
    }
    super(span, property);
    this.fields = fields;
    this.decodePrefixes = !!decodePrefixes;
  }
  /** @override */
  getSpan(b, offset3) {
    if (0 <= this.span) {
      return this.span;
    }
    if (void 0 === offset3) {
      offset3 = 0;
    }
    let span = 0;
    try {
      span = this.fields.reduce((span2, fd) => {
        const fsp = fd.getSpan(b, offset3);
        offset3 += fsp;
        return span2 + fsp;
      }, 0);
    } catch (e) {
      throw new RangeError("indeterminate span");
    }
    return span;
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const dest = this.makeDestinationObject();
    for (const fd of this.fields) {
      if (void 0 !== fd.property) {
        dest[fd.property] = fd.decode(b, offset3);
      }
      offset3 += fd.getSpan(b, offset3);
      if (this.decodePrefixes && b.length === offset3) {
        break;
      }
    }
    return dest;
  }
  /** Implement {@link Layout#encode|encode} for {@link Structure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the buffer is
   * left unmodified. */
  encode(src, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const firstOffset = offset3;
    let lastOffset = 0;
    let lastWrote = 0;
    for (const fd of this.fields) {
      let span = fd.span;
      lastWrote = 0 < span ? span : 0;
      if (void 0 !== fd.property) {
        const fv = src[fd.property];
        if (void 0 !== fv) {
          lastWrote = fd.encode(fv, b, offset3);
          if (0 > span) {
            span = fd.getSpan(b, offset3);
          }
        }
      }
      lastOffset = offset3;
      offset3 += span;
    }
    return lastOffset + lastWrote - firstOffset;
  }
  /** @override */
  fromArray(values) {
    const dest = this.makeDestinationObject();
    for (const fd of this.fields) {
      if (void 0 !== fd.property && 0 < values.length) {
        dest[fd.property] = values.shift();
      }
    }
    return dest;
  }
  /**
   * Get access to the layout of a given property.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Layout} - the layout associated with `property`, or
   * undefined if there is no such property.
   */
  layoutFor(property) {
    if ("string" !== typeof property) {
      throw new TypeError("property must be string");
    }
    for (const fd of this.fields) {
      if (fd.property === property) {
        return fd;
      }
    }
  }
  /**
   * Get the offset of a structure member.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Number} - the offset in bytes to the start of `property`
   * within the structure, or undefined if `property` is not a field
   * within the structure.  If the property is a member but follows a
   * variable-length structure member a negative number will be
   * returned.
   */
  offsetOf(property) {
    if ("string" !== typeof property) {
      throw new TypeError("property must be string");
    }
    let offset3 = 0;
    for (const fd of this.fields) {
      if (fd.property === property) {
        return offset3;
      }
      if (0 > fd.span) {
        offset3 = -1;
      } else if (0 <= offset3) {
        offset3 += fd.span;
      }
    }
  }
};
var UnionDiscriminator = class {
  constructor(property) {
    this.property = property;
  }
  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
   *
   * The implementation of this method need not reference the buffer if
   * variant information is available through other means. */
  decode() {
    throw new Error("UnionDiscriminator is abstract");
  }
  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
   *
   * The implementation of this method need not store the value if
   * variant information is maintained through other means. */
  encode() {
    throw new Error("UnionDiscriminator is abstract");
  }
};
var UnionLayoutDiscriminator = class extends UnionDiscriminator {
  constructor(layout, property) {
    if (!(layout instanceof ExternalLayout && layout.isCount())) {
      throw new TypeError("layout must be an unsigned integer ExternalLayout");
    }
    super(property || layout.property || "variant");
    this.layout = layout;
  }
  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  decode(b, offset3) {
    return this.layout.decode(b, offset3);
  }
  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  encode(src, b, offset3) {
    return this.layout.encode(src, b, offset3);
  }
};
var Union = class extends Layout {
  constructor(discr, defaultLayout, property) {
    const upv = discr instanceof UInt || discr instanceof UIntBE;
    if (upv) {
      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));
    } else if (discr instanceof ExternalLayout && discr.isCount()) {
      discr = new UnionLayoutDiscriminator(discr);
    } else if (!(discr instanceof UnionDiscriminator)) {
      throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
    }
    if (void 0 === defaultLayout) {
      defaultLayout = null;
    }
    if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
      throw new TypeError("defaultLayout must be null or a Layout");
    }
    if (null !== defaultLayout) {
      if (0 > defaultLayout.span) {
        throw new Error("defaultLayout must have constant span");
      }
      if (void 0 === defaultLayout.property) {
        defaultLayout = defaultLayout.replicate("content");
      }
    }
    let span = -1;
    if (defaultLayout) {
      span = defaultLayout.span;
      if (0 <= span && upv) {
        span += discr.layout.span;
      }
    }
    super(span, property);
    this.discriminator = discr;
    this.usesPrefixDiscriminator = upv;
    this.defaultLayout = defaultLayout;
    this.registry = {};
    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
    this.getSourceVariant = function(src) {
      return boundGetSourceVariant(src);
    };
    this.configGetSourceVariant = function(gsv) {
      boundGetSourceVariant = gsv.bind(this);
    };
  }
  /** @override */
  getSpan(b, offset3) {
    if (0 <= this.span) {
      return this.span;
    }
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const vlo = this.getVariant(b, offset3);
    if (!vlo) {
      throw new Error("unable to determine span for unrecognized variant");
    }
    return vlo.getSpan(b, offset3);
  }
  /**
   * Method to infer a registered Union variant compatible with `src`.
   *
   * The first satisified rule in the following sequence defines the
   * return value:
   * * If `src` has properties matching the Union discriminator and
   *   the default layout, `undefined` is returned regardless of the
   *   value of the discriminator property (this ensures the default
   *   layout will be used);
   * * If `src` has a property matching the Union discriminator, the
   *   value of the discriminator identifies a registered variant, and
   *   either (a) the variant has no layout, or (b) `src` has the
   *   variant's property, then the variant is returned (because the
   *   source satisfies the constraints of the variant it identifies);
   * * If `src` does not have a property matching the Union
   *   discriminator, but does have a property matching a registered
   *   variant, then the variant is returned (because the source
   *   matches a variant without an explicit conflict);
   * * An error is thrown (because we either can't identify a variant,
   *   or we were explicitly told the variant but can't satisfy it).
   *
   * @param {Object} src - an object presumed to be compatible with
   * the content of the Union.
   *
   * @return {(undefined|VariantLayout)} - as described above.
   *
   * @throws {Error} - if `src` cannot be associated with a default or
   * registered variant.
   */
  defaultGetSourceVariant(src) {
    if (src.hasOwnProperty(this.discriminator.property)) {
      if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
        return void 0;
      }
      const vlo = this.registry[src[this.discriminator.property]];
      if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
        return vlo;
      }
    } else {
      for (const tag in this.registry) {
        const vlo = this.registry[tag];
        if (src.hasOwnProperty(vlo.property)) {
          return vlo;
        }
      }
    }
    throw new Error("unable to infer src variant");
  }
  /** Implement {@link Layout#decode|decode} for {@link Union}.
   *
   * If the variant is {@link Union#addVariant|registered} the return
   * value is an instance of that variant, with no explicit
   * discriminator.  Otherwise the {@link Union#defaultLayout|default
   * layout} is used to decode the content. */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    let dest;
    const dlo = this.discriminator;
    const discr = dlo.decode(b, offset3);
    let clo = this.registry[discr];
    if (void 0 === clo) {
      let contentOffset = 0;
      clo = this.defaultLayout;
      if (this.usesPrefixDiscriminator) {
        contentOffset = dlo.layout.span;
      }
      dest = this.makeDestinationObject();
      dest[dlo.property] = discr;
      dest[clo.property] = this.defaultLayout.decode(b, offset3 + contentOffset);
    } else {
      dest = clo.decode(b, offset3);
    }
    return dest;
  }
  /** Implement {@link Layout#encode|encode} for {@link Union}.
   *
   * This API assumes the `src` object is consistent with the union's
   * {@link Union#defaultLayout|default layout}.  To encode variants
   * use the appropriate variant-specific {@link VariantLayout#encode}
   * method. */
  encode(src, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    const vlo = this.getSourceVariant(src);
    if (void 0 === vlo) {
      const dlo = this.discriminator;
      const clo = this.defaultLayout;
      let contentOffset = 0;
      if (this.usesPrefixDiscriminator) {
        contentOffset = dlo.layout.span;
      }
      dlo.encode(src[dlo.property], b, offset3);
      return contentOffset + clo.encode(
        src[clo.property],
        b,
        offset3 + contentOffset
      );
    }
    return vlo.encode(src, b, offset3);
  }
  /** Register a new variant structure within a union.  The newly
   * created variant is returned.
   *
   * @param {Number} variant - initializer for {@link
   * VariantLayout#variant|variant}.
   *
   * @param {Layout} layout - initializer for {@link
   * VariantLayout#layout|layout}.
   *
   * @param {String} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {VariantLayout} */
  addVariant(variant, layout, property) {
    const rv = new VariantLayout(this, variant, layout, property);
    this.registry[variant] = rv;
    return rv;
  }
  /**
   * Get the layout associated with a registered variant.
   *
   * If `vb` does not produce a registered variant the function returns
   * `undefined`.
   *
   * @param {(Number|Buffer)} vb - either the variant number, or a
   * buffer from which the discriminator is to be read.
   *
   * @param {Number} offset - offset into `vb` for the start of the
   * union.  Used only when `vb` is an instance of {Buffer}.
   *
   * @return {({VariantLayout}|undefined)}
   */
  getVariant(vb, offset3) {
    let variant = vb;
    if (Buffer.isBuffer(vb)) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      variant = this.discriminator.decode(vb, offset3);
    }
    return this.registry[variant];
  }
};
var VariantLayout = class extends Layout {
  constructor(union3, variant, layout, property) {
    if (!(union3 instanceof Union)) {
      throw new TypeError("union must be a Union");
    }
    if (!Number.isInteger(variant) || 0 > variant) {
      throw new TypeError("variant must be a (non-negative) integer");
    }
    if ("string" === typeof layout && void 0 === property) {
      property = layout;
      layout = null;
    }
    if (layout) {
      if (!(layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (null !== union3.defaultLayout && 0 <= layout.span && layout.span > union3.defaultLayout.span) {
        throw new Error("variant span exceeds span of containing union");
      }
      if ("string" !== typeof property) {
        throw new TypeError("variant must have a String property");
      }
    }
    let span = union3.span;
    if (0 > union3.span) {
      span = layout ? layout.span : 0;
      if (0 <= span && union3.usesPrefixDiscriminator) {
        span += union3.discriminator.layout.span;
      }
    }
    super(span, property);
    this.union = union3;
    this.variant = variant;
    this.layout = layout || null;
  }
  /** @override */
  getSpan(b, offset3) {
    if (0 <= this.span) {
      return this.span;
    }
    if (void 0 === offset3) {
      offset3 = 0;
    }
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    return contentOffset + this.layout.getSpan(b, offset3 + contentOffset);
  }
  /** @override */
  decode(b, offset3) {
    const dest = this.makeDestinationObject();
    if (void 0 === offset3) {
      offset3 = 0;
    }
    if (this !== this.union.getVariant(b, offset3)) {
      throw new Error("variant mismatch");
    }
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    if (this.layout) {
      dest[this.property] = this.layout.decode(b, offset3 + contentOffset);
    } else if (this.property) {
      dest[this.property] = true;
    } else if (this.union.usesPrefixDiscriminator) {
      dest[this.union.discriminator.property] = this.variant;
    }
    return dest;
  }
  /** @override */
  encode(src, b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    if (this.layout && !src.hasOwnProperty(this.property)) {
      throw new TypeError("variant lacks property " + this.property);
    }
    this.union.discriminator.encode(this.variant, b, offset3);
    let span = contentOffset;
    if (this.layout) {
      this.layout.encode(src[this.property], b, offset3 + contentOffset);
      span += this.layout.getSpan(b, offset3 + contentOffset);
      if (0 <= this.union.span && span > this.union.span) {
        throw new Error("encoded variant overruns containing union");
      }
    }
    return span;
  }
  /** Delegate {@link Layout#fromArray|fromArray} to {@link
   * VariantLayout#layout|layout}. */
  fromArray(values) {
    if (this.layout) {
      return this.layout.fromArray(values);
    }
  }
};
var Blob$1 = class extends Layout {
  constructor(length, property) {
    if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
      throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
    }
    let span = -1;
    if (!(length instanceof ExternalLayout)) {
      span = length;
    }
    super(span, property);
    this.length = length;
  }
  /** @override */
  getSpan(b, offset3) {
    let span = this.span;
    if (0 > span) {
      span = this.length.decode(b, offset3);
    }
    return span;
  }
  /** @override */
  decode(b, offset3) {
    if (void 0 === offset3) {
      offset3 = 0;
    }
    let span = this.span;
    if (0 > span) {
      span = this.length.decode(b, offset3);
    }
    return b.slice(offset3, offset3 + span);
  }
  /** Implement {@link Layout#encode|encode} for {@link Blob}.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(src, b, offset3) {
    let span = this.length;
    if (this.length instanceof ExternalLayout) {
      span = src.length;
    }
    if (!(Buffer.isBuffer(src) && span === src.length)) {
      throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
    }
    if (offset3 + span > b.length) {
      throw new RangeError("encoding overruns Buffer");
    }
    b.write(src.toString("hex"), offset3, span, "hex");
    if (this.length instanceof ExternalLayout) {
      this.length.encode(span, b, offset3);
    }
    return span;
  }
};
var offset2 = (layout, offset3, property) => new OffsetLayout(layout, offset3, property);
var u83 = (property) => new UInt(1, property);
var u324 = (property) => new UInt(4, property);
var nu642 = (property) => new NearUInt64(property);
var ns642 = (property) => new NearInt64(property);
var struct3 = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
var union2 = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
var blob3 = (length, property) => new Blob$1(length, property);
var SystemInstructionCoder = class {
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  constructor(_) {
  }
  encode(ixName, ix) {
    switch ((0, import_camelcase.default)(ixName)) {
      case "createAccount": {
        return encodeCreateAccount(ix);
      }
      case "assign": {
        return encodeAssign(ix);
      }
      case "transfer": {
        return encodeTransfer(ix);
      }
      case "createAccountWithSeed": {
        return encodeCreateAccountWithSeed(ix);
      }
      case "advanceNonceAccount": {
        return encodeAdvanceNonceAccount(ix);
      }
      case "withdrawNonceAccount": {
        return encodeWithdrawNonceAccount(ix);
      }
      case "initializeNonceAccount": {
        return encodeInitializeNonceAccount(ix);
      }
      case "authorizeNonceAccount": {
        return encodeAuthorizeNonceAccount(ix);
      }
      case "allocate": {
        return encodeAllocate(ix);
      }
      case "allocateWithSeed": {
        return encodeAllocateWithSeed(ix);
      }
      case "assignWithSeed": {
        return encodeAssignWithSeed(ix);
      }
      case "transferWithSeed": {
        return encodeTransferWithSeed(ix);
      }
      default: {
        throw new Error(`Invalid instruction: ${ixName}`);
      }
    }
  }
  encodeState(_ixName, _ix) {
    throw new Error("System does not have state");
  }
};
var RustStringLayout = class extends Layout_2 {
  constructor(property) {
    super(-1, property);
    this.property = property;
    this.layout = struct3([
      u324("length"),
      u324("lengthPadding"),
      blob3(offset2(u324(), -8), "chars")
    ], this.property);
  }
  encode(src, b, offset3 = 0) {
    if (src === null || src === void 0) {
      return this.layout.span;
    }
    const data = {
      chars: Buffer.from(src, "utf8")
    };
    return this.layout.encode(data, b, offset3);
  }
  decode(b, offset3 = 0) {
    const data = this.layout.decode(b, offset3);
    return data["chars"].toString();
  }
  getSpan(b, offset3 = 0) {
    return u324().span + u324().span + new import_bn2.default(new Uint8Array(b).slice(offset3, offset3 + 4), 10, "le").toNumber();
  }
};
function rustStringLayout(property) {
  return new RustStringLayout(property);
}
function publicKey$2(property) {
  return blob3(32, property);
}
function encodeCreateAccount({ lamports, space, owner }) {
  return encodeData2({
    createAccount: { lamports, space, owner: owner.toBuffer() }
  });
}
function encodeAssign({ owner }) {
  return encodeData2({
    assign: { owner: owner.toBuffer() }
  });
}
function encodeTransfer({ lamports }) {
  return encodeData2({
    transfer: { lamports }
  });
}
function encodeCreateAccountWithSeed({ base, seed: seed2, lamports, space, owner }) {
  return encodeData2({
    createAccountWithSeed: {
      base: base.toBuffer(),
      seed: seed2,
      lamports,
      space,
      owner: owner.toBuffer()
    }
  }, LAYOUT.getVariant(3).span + seed2.length);
}
function encodeInitializeNonceAccount({ authorized: authorized2 }) {
  return encodeData2({
    initializeNonceAccount: { authorized: authorized2.toBuffer() }
  });
}
function encodeAdvanceNonceAccount({ authorized: authorized2 }) {
  return encodeData2({
    advanceNonceAccount: { authorized: authorized2.toBuffer() }
  });
}
function encodeWithdrawNonceAccount({ lamports }) {
  return encodeData2({
    withdrawNonceAccount: { lamports }
  });
}
function encodeAuthorizeNonceAccount({ authorized: authorized2 }) {
  return encodeData2({
    authorizeNonceAccount: { authorized: authorized2.toBuffer() }
  });
}
function encodeAllocate({ space }) {
  return encodeData2({
    allocate: { space }
  });
}
function encodeAllocateWithSeed({ base, seed: seed2, space, owner }) {
  return encodeData2({
    allocateWithSeed: {
      base: base.toBuffer(),
      seed: seed2,
      space,
      owner: owner.toBuffer()
    }
  }, LAYOUT.getVariant(9).span + seed2.length);
}
function encodeAssignWithSeed({ base, seed: seed2, owner }) {
  return encodeData2({
    assignWithSeed: {
      base: base.toBuffer(),
      seed: seed2,
      owner: owner.toBuffer()
    }
  }, LAYOUT.getVariant(10).span + seed2.length);
}
function encodeTransferWithSeed({ lamports, seed: seed2, owner }) {
  return encodeData2({
    transferWithSeed: {
      lamports,
      seed: seed2,
      owner: owner.toBuffer()
    }
  }, LAYOUT.getVariant(11).span + seed2.length);
}
var LAYOUT = union2(u324("instruction"));
LAYOUT.addVariant(0, struct3([
  ns642("lamports"),
  ns642("space"),
  publicKey$2("owner")
]), "createAccount");
LAYOUT.addVariant(1, struct3([publicKey$2("owner")]), "assign");
LAYOUT.addVariant(2, struct3([ns642("lamports")]), "transfer");
LAYOUT.addVariant(3, struct3([
  publicKey$2("base"),
  rustStringLayout("seed"),
  ns642("lamports"),
  ns642("space"),
  publicKey$2("owner")
]), "createAccountWithSeed");
LAYOUT.addVariant(4, struct3([publicKey$2("authorized")]), "advanceNonceAccount");
LAYOUT.addVariant(5, struct3([ns642("lamports")]), "withdrawNonceAccount");
LAYOUT.addVariant(6, struct3([publicKey$2("authorized")]), "initializeNonceAccount");
LAYOUT.addVariant(7, struct3([publicKey$2("authorized")]), "authorizeNonceAccount");
LAYOUT.addVariant(8, struct3([ns642("space")]), "allocate");
LAYOUT.addVariant(9, struct3([
  publicKey$2("base"),
  rustStringLayout("seed"),
  ns642("space"),
  publicKey$2("owner")
]), "allocateWithSeed");
LAYOUT.addVariant(10, struct3([
  publicKey$2("base"),
  rustStringLayout("seed"),
  publicKey$2("owner")
]), "assignWithSeed");
LAYOUT.addVariant(11, struct3([
  ns642("lamports"),
  rustStringLayout("seed"),
  publicKey$2("owner")
]), "transferWithSeed");
function encodeData2(instruction, maxSpan) {
  const b = Buffer.alloc(maxSpan !== null && maxSpan !== void 0 ? maxSpan : instructionMaxSpan);
  const span = LAYOUT.encode(instruction, b);
  if (maxSpan === void 0) {
    return b.slice(0, span);
  }
  return b;
}
var instructionMaxSpan = Math.max(...Object.values(LAYOUT.registry).map((r) => r.span));
var SystemAccountsCoder = class {
  constructor(idl) {
    this.idl = idl;
  }
  async encode(accountName, account) {
    switch (accountName) {
      case "nonce": {
        const buffer = Buffer.alloc(NONCE_ACCOUNT_LENGTH);
        const len = NONCE_ACCOUNT_LAYOUT.encode(account, buffer);
        return buffer.slice(0, len);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }
  decode(accountName, ix) {
    return this.decodeUnchecked(accountName, ix);
  }
  decodeUnchecked(accountName, ix) {
    switch (accountName) {
      case "nonce": {
        return decodeNonceAccount(ix);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }
  // TODO: this won't use the appendData.
  memcmp(accountName, _appendData) {
    switch (accountName) {
      case "nonce": {
        return {
          dataSize: NONCE_ACCOUNT_LENGTH
        };
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }
  size(idlAccount) {
    var _a;
    return (_a = accountSize(this.idl, idlAccount)) !== null && _a !== void 0 ? _a : 0;
  }
};
function decodeNonceAccount(ix) {
  return NONCE_ACCOUNT_LAYOUT.decode(ix);
}
var WrappedLayout$1 = class extends Layout_2 {
  constructor(layout, decoder, encoder, property) {
    super(layout.span, property);
    this.layout = layout;
    this.decoder = decoder;
    this.encoder = encoder;
  }
  decode(b, offset3) {
    return this.decoder(this.layout.decode(b, offset3));
  }
  encode(src, b, offset3) {
    return this.layout.encode(this.encoder(src), b, offset3);
  }
  getSpan(b, offset3) {
    return this.layout.getSpan(b, offset3);
  }
};
function publicKey$1(property) {
  return new WrappedLayout$1(blob3(32), (b) => new PublicKey(b), (key) => key.toBuffer(), property);
}
var NONCE_ACCOUNT_LAYOUT = struct3([
  u324("version"),
  u324("state"),
  publicKey$1("authorizedPubkey"),
  publicKey$1("nonce"),
  struct3([nu642("lamportsPerSignature")], "feeCalculator")
]);
var SystemEventsCoder = class {
  constructor(_idl) {
  }
  decode(_log) {
    throw new Error("System program does not have events");
  }
};
var SystemTypesCoder = class {
  constructor(_idl) {
  }
  encode(_name, _type) {
    throw new Error("System does not have user-defined types");
  }
  decode(_name, _typeData) {
    throw new Error("System does not have user-defined types");
  }
};
var SystemCoder = class {
  constructor(idl) {
    this.instruction = new SystemInstructionCoder(idl);
    this.accounts = new SystemAccountsCoder(idl);
    this.events = new SystemEventsCoder(idl);
    this.types = new SystemTypesCoder(idl);
  }
};
function hash2(data) {
  return (0, import_js_sha256.sha256)(data);
}
var sha2562 = Object.freeze({
  __proto__: null,
  hash: hash2
});
function createWithSeedSync(fromPublicKey, seed2, programId) {
  const buffer = import_buffer2.Buffer.concat([
    fromPublicKey.toBuffer(),
    import_buffer2.Buffer.from(seed2),
    programId.toBuffer()
  ]);
  const hash3 = import_js_sha256.sha256.digest(buffer);
  return new PublicKey(import_buffer2.Buffer.from(hash3));
}
function associated(programId, ...args) {
  let seeds = [import_buffer2.Buffer.from([97, 110, 99, 104, 111, 114])];
  args.forEach((arg) => {
    seeds.push(arg instanceof import_buffer2.Buffer ? arg : translateAddress(arg).toBuffer());
  });
  const [assoc] = PublicKey.findProgramAddressSync(seeds, translateAddress(programId));
  return assoc;
}
var pubkey = Object.freeze({
  __proto__: null,
  createWithSeedSync,
  associated
});
var TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var ASSOCIATED_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
function associatedAddress({ mint, owner }) {
  return PublicKey.findProgramAddressSync([owner.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()], ASSOCIATED_PROGRAM_ID)[0];
}
var token = Object.freeze({
  __proto__: null,
  TOKEN_PROGRAM_ID,
  ASSOCIATED_PROGRAM_ID,
  associatedAddress
});
var browserPonyfill = { exports: {} };
(function(module2, exports2) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = function() {
    function F() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F.prototype = global2;
    return new F();
  }();
  (function(self2) {
    (function(exports3) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob();
            return true;
          } catch (e) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        if (typeof name !== "string") {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return { done: value === void 0, value };
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers(headers) {
        this.map = {};
        if (headers instanceof Headers) {
          headers.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
      Headers.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value : value;
      };
      Headers.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };
      Headers.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
      Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push([name, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob4) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob4);
        return promise;
      }
      function readBlobAsText(blob4) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob4);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i = 0; i < view.length; i++) {
          chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode3);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method2) {
        var upcased = method2.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method2;
      }
      function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request.prototype.clone = function() {
        return new Request(this, { body: this._bodyInit });
      };
      function decode3(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes2) {
          if (bytes2) {
            var split2 = bytes2.split("=");
            var name = split2.shift().replace(/\+/g, " ");
            var value = split2.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(":");
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(":").trim();
            headers.append(key, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response.prototype);
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        });
      };
      Response.error = function() {
        var response = new Response(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response(null, { status, headers: { location: url } });
      };
      exports3.DOMException = self2.DOMException;
      try {
        new exports3.DOMException();
      } catch (err2) {
        exports3.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports3.DOMException.prototype = Object.create(Error.prototype);
        exports3.DOMException.prototype.constructor = exports3.DOMException;
      }
      function fetch2(input, init) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init);
          if (request.signal && request.signal.aborted) {
            return reject(new exports3.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response(body, options));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject(new exports3.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value, name) {
            xhr.setRequestHeader(name, value);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch2;
        self2.Headers = Headers;
        self2.Request = Request;
        self2.Response = Response;
      }
      exports3.Headers = Headers;
      exports3.Request = Request;
      exports3.Response = Response;
      exports3.fetch = fetch2;
      Object.defineProperty(exports3, "__esModule", { value: true });
      return exports3;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports2 = ctx.fetch;
  exports2.default = ctx.fetch;
  exports2.fetch = ctx.fetch;
  exports2.Headers = ctx.Headers;
  exports2.Request = ctx.Request;
  exports2.Response = ctx.Response;
  module2.exports = exports2;
})(browserPonyfill, browserPonyfill.exports);
var fetch = getDefaultExportFromCjs(browserPonyfill.exports);
async function verifiedBuild(connection, programId, limit = 5) {
  const url = `https://api.apr.dev/api/v0/program/${programId.toString()}/latest?limit=${limit}`;
  const [programData, latestBuildsResp] = await Promise.all([
    fetchData(connection, programId),
    fetch(url)
  ]);
  const latestBuilds = (await latestBuildsResp.json()).filter((b) => !b.aborted && b.state === "Built" && b.verified === "Verified");
  if (latestBuilds.length === 0) {
    return null;
  }
  const build = latestBuilds[0];
  if (programData.slot.toNumber() !== build.verified_slot) {
    return null;
  }
  return build;
}
async function fetchData(connection, programId) {
  const accountInfo = await connection.getAccountInfo(programId);
  if (accountInfo === null) {
    throw new Error("program account not found");
  }
  const { program: program2 } = decodeUpgradeableLoaderState(accountInfo.data);
  const programdataAccountInfo = await connection.getAccountInfo(program2.programdataAddress);
  if (programdataAccountInfo === null) {
    throw new Error("program data account not found");
  }
  const { programData } = decodeUpgradeableLoaderState(programdataAccountInfo.data);
  return programData;
}
var UPGRADEABLE_LOADER_STATE_LAYOUT = borsh.rustEnum([
  borsh.struct([], "uninitialized"),
  borsh.struct([borsh.option(borsh.publicKey(), "authorityAddress")], "buffer"),
  borsh.struct([borsh.publicKey("programdataAddress")], "program"),
  borsh.struct([
    borsh.u64("slot"),
    borsh.option(borsh.publicKey(), "upgradeAuthorityAddress")
  ], "programData")
], void 0, borsh.u32());
function decodeUpgradeableLoaderState(data) {
  return UPGRADEABLE_LOADER_STATE_LAYOUT.decode(data);
}
var registry = Object.freeze({
  __proto__: null,
  verifiedBuild,
  fetchData,
  decodeUpgradeableLoaderState
});
var index = Object.freeze({
  __proto__: null,
  sha256: sha2562,
  rpc,
  publicKey: pubkey,
  bytes: index$1,
  token,
  features,
  registry
});
function isIdlAccounts(accountItem) {
  return "accounts" in accountItem;
}
async function idlAddress(programId) {
  const base = (await PublicKey.findProgramAddress([], programId))[0];
  return await PublicKey.createWithSeed(base, seed(), programId);
}
function seed() {
  return "anchor:idl";
}
var IDL_ACCOUNT_LAYOUT = borsh.struct([
  borsh.publicKey("authority"),
  borsh.vecU8("data")
]);
function decodeIdlAccount(data) {
  return IDL_ACCOUNT_LAYOUT.decode(data);
}
function splitArgsAndCtx(idlIx, args) {
  var _a, _b;
  let options = {};
  const inputLen = idlIx.args ? idlIx.args.length : 0;
  if (args.length > inputLen) {
    if (args.length !== inputLen + 1) {
      throw new Error(`provided too many arguments ${args} to instruction ${idlIx === null || idlIx === void 0 ? void 0 : idlIx.name} expecting: ${(_b = (_a = idlIx.args) === null || _a === void 0 ? void 0 : _a.map((a) => a.name)) !== null && _b !== void 0 ? _b : []}`);
    }
    options = args.pop();
  }
  return [args, options];
}
var InstructionNamespaceFactory = class {
  static build(idlIx, encodeFn, programId) {
    if (idlIx.name === "_inner") {
      throw new IdlError("the _inner name is reserved");
    }
    const ix = (...args) => {
      const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);
      validateAccounts(idlIx.accounts, ctx.accounts);
      validateInstruction(idlIx, ...args);
      const keys = ix.accounts(ctx.accounts);
      if (ctx.remainingAccounts !== void 0) {
        keys.push(...ctx.remainingAccounts);
      }
      if (isSet("debug-logs")) {
        console.log("Outgoing account metas:", keys);
      }
      return new TransactionInstruction({
        keys,
        programId,
        data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs))
      });
    };
    ix["accounts"] = (accs) => {
      return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts, programId, idlIx.name);
    };
    return ix;
  }
  static accountsArray(ctx, accounts, programId, ixName) {
    if (!ctx) {
      return [];
    }
    return accounts.map((acc) => {
      const nestedAccounts = "accounts" in acc ? acc.accounts : void 0;
      if (nestedAccounts !== void 0) {
        const rpcAccs = ctx[acc.name];
        return InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts, programId, ixName).flat();
      } else {
        const account = acc;
        let pubkey2;
        try {
          pubkey2 = translateAddress(ctx[acc.name]);
        } catch (err2) {
          throw new Error(`Wrong input type for account "${acc.name}" in the instruction accounts object${ixName !== void 0 ? ' for instruction "' + ixName + '"' : ""}. Expected PublicKey or string.`);
        }
        const optional3 = account.isOptional && pubkey2.equals(programId);
        const isWritable = account.isMut && !optional3;
        const isSigner = account.isSigner && !optional3;
        return {
          pubkey: pubkey2,
          isWritable,
          isSigner
        };
      }
    }).flat();
  }
};
function validateInstruction(ix, ...args) {
}
var TransactionFactory = class {
  static build(idlIx, ixFn) {
    const txFn = (...args) => {
      var _a, _b, _c;
      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
      const tx = new Transaction();
      if (ctx.preInstructions && ctx.instructions) {
        throw new Error("instructions is deprecated, use preInstructions");
      }
      (_a = ctx.preInstructions) === null || _a === void 0 ? void 0 : _a.forEach((ix) => tx.add(ix));
      (_b = ctx.instructions) === null || _b === void 0 ? void 0 : _b.forEach((ix) => tx.add(ix));
      tx.add(ixFn(...args));
      (_c = ctx.postInstructions) === null || _c === void 0 ? void 0 : _c.forEach((ix) => tx.add(ix));
      return tx;
    };
    return txFn;
  }
};
var RpcFactory = class {
  static build(idlIx, txFn, idlErrors, provider) {
    const rpc2 = async (...args) => {
      var _a;
      const tx = txFn(...args);
      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
      if (provider.sendAndConfirm === void 0) {
        throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
      }
      try {
        return await provider.sendAndConfirm(tx, (_a = ctx.signers) !== null && _a !== void 0 ? _a : [], ctx.options);
      } catch (err2) {
        throw translateError(err2, idlErrors);
      }
    };
    return rpc2;
  }
};
var AccountFactory = class {
  static build(idl, coder2, programId, provider) {
    var _a;
    const accountFns = {};
    (_a = idl.accounts) === null || _a === void 0 ? void 0 : _a.forEach((idlAccount) => {
      const name = (0, import_camelcase.default)(idlAccount.name);
      accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder2);
    });
    return accountFns;
  }
};
var AccountClient = class {
  /**
   * Returns the number of bytes in this account.
   */
  get size() {
    return this._size;
  }
  /**
   * Returns the program ID owning all accounts.
   */
  get programId() {
    return this._programId;
  }
  /**
   * Returns the client's wallet and network provider.
   */
  get provider() {
    return this._provider;
  }
  /**
   * Returns the coder.
   */
  get coder() {
    return this._coder;
  }
  /**
   * Returns the idl account.
   */
  get idlAccount() {
    return this._idlAccount;
  }
  constructor(idl, idlAccount, programId, provider, coder2) {
    this._idlAccount = idlAccount;
    this._programId = programId;
    this._provider = provider !== null && provider !== void 0 ? provider : getProvider();
    this._coder = coder2 !== null && coder2 !== void 0 ? coder2 : new BorshCoder(idl);
    this._size = this._coder.accounts.size(idlAccount);
  }
  /**
   * Returns a deserialized account, returning null if it doesn't exist.
   *
   * @param address The address of the account to fetch.
   */
  async fetchNullable(address, commitment) {
    const { data } = await this.fetchNullableAndContext(address, commitment);
    return data;
  }
  /**
   * Returns a deserialized account along with the associated rpc response context, returning null if it doesn't exist.
   *
   * @param address The address of the account to fetch.
   */
  async fetchNullableAndContext(address, commitment) {
    const accountInfo = await this.getAccountInfoAndContext(address, commitment);
    const { value, context } = accountInfo;
    return {
      data: value && value.data.length !== 0 ? this._coder.accounts.decode(this._idlAccount.name, value.data) : null,
      context
    };
  }
  /**
   * Returns a deserialized account.
   *
   * @param address The address of the account to fetch.
   */
  async fetch(address, commitment) {
    const { data } = await this.fetchNullableAndContext(address, commitment);
    if (data === null) {
      throw new Error(`Account does not exist or has no data ${address.toString()}`);
    }
    return data;
  }
  /**
   * Returns a deserialized account along with the associated rpc response context.
   *
   * @param address The address of the account to fetch.
   */
  async fetchAndContext(address, commitment) {
    const { data, context } = await this.fetchNullableAndContext(address, commitment);
    if (data === null) {
      throw new Error(`Account does not exist ${address.toString()}`);
    }
    return { data, context };
  }
  /**
   * Returns multiple deserialized accounts.
   * Accounts not found or with wrong discriminator are returned as null.
   *
   * @param addresses The addresses of the accounts to fetch.
   */
  async fetchMultiple(addresses, commitment) {
    const accounts = await this.fetchMultipleAndContext(addresses, commitment);
    return accounts.map((account) => account ? account.data : null);
  }
  /**
   * Returns multiple deserialized accounts.
   * Accounts not found or with wrong discriminator are returned as null.
   *
   * @param addresses The addresses of the accounts to fetch.
   */
  async fetchMultipleAndContext(addresses, commitment) {
    const accounts = await getMultipleAccountsAndContext(this._provider.connection, addresses.map((address) => translateAddress(address)), commitment);
    return accounts.map((result) => {
      if (result == null) {
        return null;
      }
      const { account, context } = result;
      return {
        data: this._coder.accounts.decode(this._idlAccount.name, account.data),
        context
      };
    });
  }
  /**
   * Returns all instances of this account type for the program.
   *
   * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.
   *
   *                When filters are not defined this method returns all
   *                the account instances.
   *
   *                When filters are of type `Buffer`, the filters are appended
   *                after the discriminator.
   *
   *                When filters are of type `GetProgramAccountsFilter[]`,
   *                filters are appended after the discriminator filter.
   */
  async all(filters) {
    const filter = this.coder.accounts.memcmp(this._idlAccount.name, filters instanceof Buffer ? filters : void 0);
    const coderFilters = [];
    if ((filter === null || filter === void 0 ? void 0 : filter.offset) != void 0 && (filter === null || filter === void 0 ? void 0 : filter.bytes) != void 0) {
      coderFilters.push({
        memcmp: { offset: filter.offset, bytes: filter.bytes }
      });
    }
    if ((filter === null || filter === void 0 ? void 0 : filter.dataSize) != void 0) {
      coderFilters.push({ dataSize: filter.dataSize });
    }
    let resp = await this._provider.connection.getProgramAccounts(this._programId, {
      commitment: this._provider.connection.commitment,
      filters: [...coderFilters, ...Array.isArray(filters) ? filters : []]
    });
    return resp.map(({ pubkey: pubkey2, account }) => {
      return {
        publicKey: pubkey2,
        account: this._coder.accounts.decode(this._idlAccount.name, account.data)
      };
    });
  }
  /**
   * Returns an `EventEmitter` emitting a "change" event whenever the account
   * changes.
   */
  subscribe(address, commitment) {
    const sub = subscriptions.get(address.toString());
    if (sub) {
      return sub.ee;
    }
    const ee = new import_eventemitter3.default();
    address = translateAddress(address);
    const listener = this._provider.connection.onAccountChange(address, (acc) => {
      const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);
      ee.emit("change", account);
    }, commitment);
    subscriptions.set(address.toString(), {
      ee,
      listener
    });
    return ee;
  }
  /**
   * Unsubscribes from the account at the given address.
   */
  async unsubscribe(address) {
    let sub = subscriptions.get(address.toString());
    if (!sub) {
      console.warn("Address is not subscribed");
      return;
    }
    if (subscriptions) {
      await this._provider.connection.removeAccountChangeListener(sub.listener).then(() => {
        subscriptions.delete(address.toString());
      }).catch(console.error);
    }
  }
  /**
   * Returns an instruction for creating this account.
   */
  async createInstruction(signer, sizeOverride) {
    const size = this.size;
    if (this._provider.publicKey === void 0) {
      throw new Error("This function requires the Provider interface implementor to have a 'publicKey' field.");
    }
    return SystemProgram.createAccount({
      fromPubkey: this._provider.publicKey,
      newAccountPubkey: signer.publicKey,
      space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,
      lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),
      programId: this._programId
    });
  }
  /**
   * @deprecated since version 14.0.
   *
   * Function returning the associated account. Args are keys to associate.
   * Order matters.
   */
  async associated(...args) {
    const addr = await this.associatedAddress(...args);
    return await this.fetch(addr);
  }
  /**
   * @deprecated since version 14.0.
   *
   * Function returning the associated address. Args are keys to associate.
   * Order matters.
   */
  async associatedAddress(...args) {
    return await associated(this._programId, ...args);
  }
  async getAccountInfo(address, commitment) {
    return await this._provider.connection.getAccountInfo(translateAddress(address), commitment);
  }
  async getAccountInfoAndContext(address, commitment) {
    return await this._provider.connection.getAccountInfoAndContext(translateAddress(address), commitment);
  }
};
var subscriptions = /* @__PURE__ */ new Map();
var PROGRAM_LOG = "Program log: ";
var PROGRAM_DATA = "Program data: ";
var PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;
var PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;
var EventManager = class {
  constructor(programId, provider, coder2) {
    this._programId = programId;
    this._provider = provider;
    this._eventParser = new EventParser(programId, coder2);
    this._eventCallbacks = /* @__PURE__ */ new Map();
    this._eventListeners = /* @__PURE__ */ new Map();
    this._listenerIdCount = 0;
  }
  addEventListener(eventName, callback) {
    var _a;
    let listener = this._listenerIdCount;
    this._listenerIdCount += 1;
    if (!this._eventListeners.has(eventName)) {
      this._eventListeners.set(eventName, []);
    }
    this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener));
    this._eventCallbacks.set(listener, [eventName, callback]);
    if (this._onLogsSubscriptionId !== void 0) {
      return listener;
    }
    this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {
      if (logs.err) {
        return;
      }
      for (const event of this._eventParser.parseLogs(logs.logs)) {
        const allListeners = this._eventListeners.get(event.name);
        if (allListeners) {
          allListeners.forEach((listener2) => {
            const listenerCb = this._eventCallbacks.get(listener2);
            if (listenerCb) {
              const [, callback2] = listenerCb;
              callback2(event.data, ctx.slot, logs.signature);
            }
          });
        }
      }
    });
    return listener;
  }
  async removeEventListener(listener) {
    const callback = this._eventCallbacks.get(listener);
    if (!callback) {
      throw new Error(`Event listener ${listener} doesn't exist!`);
    }
    const [eventName] = callback;
    let listeners = this._eventListeners.get(eventName);
    if (!listeners) {
      throw new Error(`Event listeners don't exist for ${eventName}!`);
    }
    this._eventCallbacks.delete(listener);
    listeners = listeners.filter((l) => l !== listener);
    this._eventListeners.set(eventName, listeners);
    if (listeners.length === 0) {
      this._eventListeners.delete(eventName);
    }
    if (this._eventCallbacks.size == 0) {
      assert$1.ok(this._eventListeners.size === 0);
      if (this._onLogsSubscriptionId !== void 0) {
        await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);
        this._onLogsSubscriptionId = void 0;
      }
    }
  }
};
var EventParser = class {
  constructor(programId, coder2) {
    this.coder = coder2;
    this.programId = programId;
  }
  // Each log given, represents an array of messages emitted by
  // a single transaction, which can execute many different programs across
  // CPI boundaries. However, the subscription is only interested in the
  // events emitted by *this* program. In achieving this, we keep track of the
  // program execution context by parsing each log and looking for a CPI
  // `invoke` call. If one exists, we know a new program is executing. So we
  // push the programId onto a stack and switch the program context. This
  // allows us to track, for a given log, which program was executing during
  // its emission, thereby allowing us to know if a given log event was
  // emitted by *this* program. If it was, then we parse the raw string and
  // emit the event if the string matches the event being subscribed to.
  *parseLogs(logs, errorOnDecodeFailure = false) {
    const logScanner = new LogScanner(logs);
    const execution = new ExecutionContext();
    let log = logScanner.next();
    while (log !== null) {
      let [event, newProgram, didPop] = this.handleLog(execution, log, errorOnDecodeFailure);
      if (event) {
        yield event;
      }
      if (newProgram) {
        execution.push(newProgram);
      }
      if (didPop) {
        execution.pop();
      }
      log = logScanner.next();
    }
  }
  // Main log handler. Returns a three element array of the event, the
  // next program that was invoked for CPI, and a boolean indicating if
  // a program has completed execution (and thus should be popped off the
  // execution stack).
  handleLog(execution, log, errorOnDecodeFailure) {
    if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {
      return this.handleProgramLog(log, errorOnDecodeFailure);
    } else {
      return [null, ...this.handleSystemLog(log)];
    }
  }
  // Handles logs from *this* program.
  handleProgramLog(log, errorOnDecodeFailure) {
    if (log.startsWith(PROGRAM_LOG) || log.startsWith(PROGRAM_DATA)) {
      const logStr = log.startsWith(PROGRAM_LOG) ? log.slice(PROGRAM_LOG_START_INDEX) : log.slice(PROGRAM_DATA_START_INDEX);
      const event = this.coder.events.decode(logStr);
      if (errorOnDecodeFailure && event === null) {
        throw new Error(`Unable to decode event ${logStr}`);
      }
      return [event, null, false];
    } else {
      return [null, ...this.handleSystemLog(log)];
    }
  }
  // Handles logs when the current program being executing is *not* this.
  handleSystemLog(log) {
    const logStart = log.split(":")[0];
    if (logStart.match(/^Program (.*) success/g) !== null) {
      return [null, true];
    } else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {
      return [this.programId.toString(), false];
    } else if (logStart.includes("invoke")) {
      return ["cpi", false];
    } else {
      return [null, false];
    }
  }
};
var ExecutionContext = class {
  constructor() {
    this.stack = [];
  }
  program() {
    assert$1.ok(this.stack.length > 0);
    return this.stack[this.stack.length - 1];
  }
  push(newProgram) {
    this.stack.push(newProgram);
  }
  pop() {
    assert$1.ok(this.stack.length > 0);
    this.stack.pop();
  }
};
var LogScanner = class {
  constructor(logs) {
    this.logs = logs;
  }
  next() {
    if (this.logs.length === 0) {
      return null;
    }
    let l = this.logs[0];
    this.logs = this.logs.slice(1);
    return l;
  }
};
var SimulateFactory = class {
  static build(idlIx, txFn, idlErrors, provider, coder2, programId, idl) {
    const simulate = async (...args) => {
      var _a;
      const tx = txFn(...args);
      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
      let resp = void 0;
      if (provider.simulate === void 0) {
        throw new Error("This function requires 'Provider.simulate' to be implemented.");
      }
      try {
        resp = await provider.simulate(tx, ctx.signers, (_a = ctx.options) === null || _a === void 0 ? void 0 : _a.commitment);
      } catch (err2) {
        throw translateError(err2, idlErrors);
      }
      if (resp === void 0) {
        throw new Error("Unable to simulate transaction");
      }
      const logs = resp.logs;
      if (!logs) {
        throw new Error("Simulated logs not found");
      }
      const events = [];
      if (idl.events) {
        let parser = new EventParser(programId, coder2);
        for (const event of parser.parseLogs(logs)) {
          events.push(event);
        }
      }
      return { events, raw: logs };
    };
    return simulate;
  }
};
function uint64(property) {
  return new WrappedLayout(blob3(8), (b) => u644.fromBuffer(b), (n) => n.toBuffer(), property);
}
function publicKey3(property) {
  return new WrappedLayout(blob3(32), (b) => new PublicKey(b), (key) => key.toBuffer(), property);
}
function coption(layout, property) {
  return new COptionLayout(layout, property);
}
var WrappedLayout = class extends Layout_2 {
  constructor(layout, decoder, encoder, property) {
    super(layout.span, property);
    this.layout = layout;
    this.decoder = decoder;
    this.encoder = encoder;
  }
  decode(b, offset3) {
    return this.decoder(this.layout.decode(b, offset3));
  }
  encode(src, b, offset3) {
    return this.layout.encode(this.encoder(src), b, offset3);
  }
  getSpan(b, offset3) {
    return this.layout.getSpan(b, offset3);
  }
};
var COptionLayout = class extends Layout_2 {
  constructor(layout, property) {
    super(-1, property);
    this.layout = layout;
    this.discriminator = u324();
  }
  encode(src, b, offset3 = 0) {
    if (src === null || src === void 0) {
      return this.layout.span + this.discriminator.encode(0, b, offset3);
    }
    this.discriminator.encode(1, b, offset3);
    return this.layout.encode(src, b, offset3 + 4) + 4;
  }
  decode(b, offset3 = 0) {
    const discriminator = this.discriminator.decode(b, offset3);
    if (discriminator === 0) {
      return null;
    } else if (discriminator === 1) {
      return this.layout.decode(b, offset3 + 4);
    }
    throw new Error("Invalid coption " + this.layout.property);
  }
  getSpan(b, offset3 = 0) {
    return this.layout.getSpan(b, offset3 + 4) + 4;
  }
};
var u644 = class extends import_bn2.default {
  /**
   * Convert to Buffer representation
   */
  toBuffer() {
    const a = super.toArray().reverse();
    const b = Buffer.from(a);
    if (b.length === 8) {
      return b;
    }
    if (b.length >= 8) {
      throw new Error("u64 too large");
    }
    const zeroPad = Buffer.alloc(8);
    b.copy(zeroPad);
    return zeroPad;
  }
  /**
   * Construct a u64 from Buffer representation
   */
  static fromBuffer(buffer) {
    if (buffer.length !== 8) {
      throw new Error(`Invalid buffer length: ${buffer.length}`);
    }
    return new u644([...buffer].reverse().map((i) => `00${i.toString(16)}`.slice(-2)).join(""), 16);
  }
};
var TOKEN_ACCOUNT_LAYOUT = struct3([
  publicKey3("mint"),
  publicKey3("owner"),
  uint64("amount"),
  coption(publicKey3(), "delegate"),
  ((p) => {
    const U = union2(u83("discriminator"), null, p);
    U.addVariant(0, struct3([]), "uninitialized");
    U.addVariant(1, struct3([]), "initialized");
    U.addVariant(2, struct3([]), "frozen");
    return U;
  })("state"),
  coption(uint64(), "isNative"),
  uint64("delegatedAmount"),
  coption(publicKey3(), "closeAuthority")
]);
function decodeTokenAccount(b) {
  return TOKEN_ACCOUNT_LAYOUT.decode(b);
}
var AccountsResolver = class {
  constructor(_args, _accounts, _provider2, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver) {
    this._accounts = _accounts;
    this._provider = _provider2;
    this._programId = _programId;
    this._idlIx = _idlIx;
    this._idlTypes = _idlTypes;
    this._customResolver = _customResolver;
    this._args = _args;
    this._accountStore = new AccountStore(_provider2, _accountNamespace, this._programId);
  }
  args(_args) {
    this._args = _args;
  }
  // Note: We serially resolve PDAs one by one rather than doing them
  //       in parallel because there can be dependencies between
  //       addresses. That is, one PDA can be used as a seed in another.
  async resolve() {
    await this.resolveConst(this._idlIx.accounts);
    while (await this.resolvePdas(this._idlIx.accounts) + await this.resolveRelations(this._idlIx.accounts) + await this.resolveCustom() > 0) {
    }
  }
  async resolveCustom() {
    if (this._customResolver) {
      const { accounts, resolved } = await this._customResolver({
        args: this._args,
        accounts: this._accounts,
        provider: this._provider,
        programId: this._programId,
        idlIx: this._idlIx
      });
      this._accounts = accounts;
      return resolved;
    }
    return 0;
  }
  resolveOptionalsHelper(partialAccounts, accountItems) {
    const nestedAccountsGeneric = {};
    for (const accountItem of accountItems) {
      const accountName = accountItem.name;
      const partialAccount = partialAccounts[accountName];
      if (partialAccount === void 0)
        continue;
      if (isPartialAccounts(partialAccount)) {
        if (isIdlAccounts(accountItem)) {
          nestedAccountsGeneric[accountName] = this.resolveOptionalsHelper(partialAccount, accountItem["accounts"]);
        } else {
          nestedAccountsGeneric[accountName] = flattenPartialAccounts(partialAccount, true);
        }
      } else {
        if (partialAccount !== null) {
          nestedAccountsGeneric[accountName] = translateAddress(partialAccount);
        } else if (accountItem["isOptional"]) {
          nestedAccountsGeneric[accountName] = this._programId;
        }
      }
    }
    return nestedAccountsGeneric;
  }
  resolveOptionals(accounts) {
    Object.assign(this._accounts, this.resolveOptionalsHelper(accounts, this._idlIx.accounts));
  }
  get(path) {
    const ret = path.reduce((acc, subPath) => acc && acc[subPath], this._accounts);
    if (ret && ret.toBase58) {
      return ret;
    }
  }
  set(path, value) {
    let curr = this._accounts;
    path.forEach((p, idx) => {
      const isLast = idx == path.length - 1;
      if (isLast) {
        curr[p] = value;
      }
      curr[p] = curr[p] || {};
      curr = curr[p];
    });
  }
  async resolveConst(accounts, path = []) {
    for (let k = 0; k < accounts.length; k += 1) {
      const accountDescOrAccounts = accounts[k];
      const subAccounts = accountDescOrAccounts.accounts;
      if (subAccounts) {
        await this.resolveConst(subAccounts, [
          ...path,
          (0, import_camelcase.default)(accountDescOrAccounts.name)
        ]);
      }
      const accountDesc = accountDescOrAccounts;
      const accountDescName = (0, import_camelcase.default)(accountDescOrAccounts.name);
      if (accountDesc.isSigner && !this.get([...path, accountDescName])) {
        if (this._provider.wallet === void 0) {
          throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
        }
        this.set([...path, accountDescName], this._provider.wallet.publicKey);
      }
      if (Reflect.has(AccountsResolver.CONST_ACCOUNTS, accountDescName) && !this.get([...path, accountDescName])) {
        this.set([...path, accountDescName], AccountsResolver.CONST_ACCOUNTS[accountDescName]);
      }
    }
  }
  async resolvePdas(accounts, path = []) {
    let found = 0;
    for (let k = 0; k < accounts.length; k += 1) {
      const accountDesc = accounts[k];
      const subAccounts = accountDesc.accounts;
      if (subAccounts) {
        found += await this.resolvePdas(subAccounts, [
          ...path,
          (0, import_camelcase.default)(accountDesc.name)
        ]);
      }
      const accountDescCasted = accountDesc;
      const accountDescName = (0, import_camelcase.default)(accountDesc.name);
      if (accountDescCasted.pda && accountDescCasted.pda.seeds.length > 0 && !this.get([...path, accountDescName])) {
        if (Boolean(await this.autoPopulatePda(accountDescCasted, path))) {
          found += 1;
        }
      }
    }
    return found;
  }
  async resolveRelations(accounts, path = []) {
    let found = 0;
    for (let k = 0; k < accounts.length; k += 1) {
      const accountDesc = accounts[k];
      const subAccounts = accountDesc.accounts;
      if (subAccounts) {
        found += await this.resolveRelations(subAccounts, [
          ...path,
          (0, import_camelcase.default)(accountDesc.name)
        ]);
      }
      const relations = accountDesc.relations || [];
      const accountDescName = (0, import_camelcase.default)(accountDesc.name);
      const newPath = [...path, accountDescName];
      const accountKey = this.get(newPath);
      if (accountKey) {
        const matching = relations.filter((rel) => !this.get([...path, (0, import_camelcase.default)(rel)]));
        found += matching.length;
        if (matching.length > 0) {
          const account = await this._accountStore.fetchAccount({
            publicKey: accountKey
          });
          await Promise.all(matching.map(async (rel) => {
            const relName = (0, import_camelcase.default)(rel);
            this.set([...path, relName], account[relName]);
            return account[relName];
          }));
        }
      }
    }
    return found;
  }
  async autoPopulatePda(accountDesc, path = []) {
    if (!accountDesc.pda || !accountDesc.pda.seeds)
      throw new Error("Must have seeds");
    const seeds = await Promise.all(accountDesc.pda.seeds.map((seedDesc) => this.toBuffer(seedDesc, path)));
    if (seeds.some((seed2) => typeof seed2 == "undefined")) {
      return;
    }
    const programId = await this.parseProgramId(accountDesc, path);
    if (!programId) {
      return;
    }
    const [pubkey2] = await PublicKey.findProgramAddress(seeds, programId);
    this.set([...path, (0, import_camelcase.default)(accountDesc.name)], pubkey2);
  }
  async parseProgramId(accountDesc, path = []) {
    var _a;
    if (!((_a = accountDesc.pda) === null || _a === void 0 ? void 0 : _a.programId)) {
      return this._programId;
    }
    switch (accountDesc.pda.programId.kind) {
      case "const":
        return new PublicKey(this.toBufferConst(accountDesc.pda.programId.value));
      case "arg":
        return this.argValue(accountDesc.pda.programId);
      case "account":
        return await this.accountValue(accountDesc.pda.programId, path);
      default:
        throw new Error(`Unexpected program seed kind: ${accountDesc.pda.programId.kind}`);
    }
  }
  async toBuffer(seedDesc, path = []) {
    switch (seedDesc.kind) {
      case "const":
        return this.toBufferConst(seedDesc);
      case "arg":
        return await this.toBufferArg(seedDesc);
      case "account":
        return await this.toBufferAccount(seedDesc, path);
      default:
        throw new Error(`Unexpected seed kind: ${seedDesc.kind}`);
    }
  }
  /**
   * Recursively get the type at some path of either a primitive or a user defined struct.
   */
  getType(type3, path = []) {
    if (path.length > 0 && type3.defined) {
      const subType = this._idlTypes.find((t) => t.name === type3.defined);
      if (!subType) {
        throw new Error(`Cannot find type ${type3.defined}`);
      }
      const structType = subType.type;
      const field = structType.fields.find((field2) => field2.name === path[0]);
      return this.getType(field.type, path.slice(1));
    }
    return type3;
  }
  toBufferConst(seedDesc) {
    return this.toBufferValue(this.getType(seedDesc.type, (seedDesc.path || "").split(".").slice(1)), seedDesc.value);
  }
  async toBufferArg(seedDesc) {
    const argValue = this.argValue(seedDesc);
    if (typeof argValue === "undefined") {
      return;
    }
    return this.toBufferValue(this.getType(seedDesc.type, (seedDesc.path || "").split(".").slice(1)), argValue);
  }
  argValue(seedDesc) {
    const split2 = seedDesc.path.split(".");
    const seedArgName = (0, import_camelcase.default)(split2[0]);
    const idlArgPosition = this._idlIx.args.findIndex((argDesc) => argDesc.name === seedArgName);
    if (idlArgPosition === -1) {
      throw new Error(`Unable to find argument for seed: ${seedArgName}`);
    }
    return split2.slice(1).reduce((curr, path) => (curr || {})[path], this._args[idlArgPosition]);
  }
  async toBufferAccount(seedDesc, path = []) {
    const accountValue = await this.accountValue(seedDesc, path);
    if (!accountValue) {
      return;
    }
    return this.toBufferValue(seedDesc.type, accountValue);
  }
  async accountValue(seedDesc, path = []) {
    const pathComponents = seedDesc.path.split(".");
    const fieldName = pathComponents[0];
    const fieldPubkey = this.get([...path, (0, import_camelcase.default)(fieldName)]);
    if (fieldPubkey === null) {
      throw new Error(`fieldPubkey is null`);
    }
    if (pathComponents.length === 1) {
      return fieldPubkey;
    }
    const account = await this._accountStore.fetchAccount({
      publicKey: fieldPubkey,
      name: seedDesc.account
    });
    const fieldValue = this.parseAccountValue(account, pathComponents.slice(1));
    return fieldValue;
  }
  parseAccountValue(account, path) {
    let accountField;
    while (path.length > 0) {
      accountField = account[(0, import_camelcase.default)(path[0])];
      path = path.slice(1);
    }
    return accountField;
  }
  // Converts the given idl valaue into a Buffer. The values here must be
  // primitives. E.g. no structs.
  //
  // TODO: add more types here as needed.
  toBufferValue(type3, value) {
    switch (type3) {
      case "u8":
        return Buffer.from([value]);
      case "u16":
        let b = Buffer.alloc(2);
        b.writeUInt16LE(value);
        return b;
      case "u32":
        let buf = Buffer.alloc(4);
        buf.writeUInt32LE(value);
        return buf;
      case "u64":
        let bU64 = Buffer.alloc(8);
        bU64.writeBigUInt64LE(BigInt(value));
        return bU64;
      case "string":
        return Buffer.from(encode$2(value));
      case "publicKey":
        return value.toBuffer();
      default:
        if (type3.array) {
          return Buffer.from(value);
        }
        throw new Error(`Unexpected seed type: ${type3}`);
    }
  }
};
AccountsResolver.CONST_ACCOUNTS = {
  associatedTokenProgram: ASSOCIATED_PROGRAM_ID,
  rent: SYSVAR_RENT_PUBKEY,
  systemProgram: SystemProgram.programId,
  tokenProgram: TOKEN_PROGRAM_ID,
  clock: SYSVAR_CLOCK_PUBKEY
};
var AccountStore = class {
  // todo: don't use the progrma use the account namespace.
  constructor(_provider2, _accounts, _programId) {
    this._provider = _provider2;
    this._programId = _programId;
    this._cache = /* @__PURE__ */ new Map();
    this._idls = {};
    this._idls[_programId.toBase58()] = _accounts;
  }
  async ensureIdl(programId) {
    if (!this._idls[programId.toBase58()]) {
      const idl = await Program.fetchIdl(programId, this._provider);
      if (idl) {
        const program2 = new Program(idl, programId, this._provider);
        this._idls[programId.toBase58()] = program2.account;
      }
    }
    return this._idls[programId.toBase58()];
  }
  async fetchAccount({ publicKey: publicKey4, name, programId = this._programId }) {
    const address = publicKey4.toString();
    if (!this._cache.has(address)) {
      if (name === "TokenAccount") {
        const accountInfo = await this._provider.connection.getAccountInfo(publicKey4);
        if (accountInfo === null) {
          throw new Error(`invalid account info for ${address}`);
        }
        const data = decodeTokenAccount(accountInfo.data);
        this._cache.set(address, data);
      } else if (name) {
        const accounts = await this.ensureIdl(programId);
        if (accounts) {
          const accountFetcher = accounts[(0, import_camelcase.default)(name)];
          if (accountFetcher) {
            const account = await accountFetcher.fetch(publicKey4);
            this._cache.set(address, account);
          }
        }
      } else {
        const account = await this._provider.connection.getAccountInfo(publicKey4);
        if (account === null) {
          throw new Error(`invalid account info for ${address}`);
        }
        const data = account.data;
        const accounts = await this.ensureIdl(account.owner);
        if (accounts) {
          const firstAccountLayout = Object.values(accounts)[0];
          if (!firstAccountLayout) {
            throw new Error("No accounts for this program");
          }
          const result = firstAccountLayout.coder.accounts.decodeAny(data);
          this._cache.set(address, result);
        }
      }
    }
    return this._cache.get(address);
  }
};
var MethodsBuilderFactory = class {
  static build(provider, programId, idlIx, ixFn, txFn, rpcFn, simulateFn, viewFn, accountNamespace, idlTypes, customResolver) {
    return (...args) => new MethodsBuilder(args, ixFn, txFn, rpcFn, simulateFn, viewFn, provider, programId, idlIx, accountNamespace, idlTypes, customResolver);
  }
};
function isPartialAccounts(partialAccount) {
  return typeof partialAccount === "object" && partialAccount !== null && !("_bn" in partialAccount);
}
function flattenPartialAccounts(partialAccounts, throwOnNull) {
  const toReturn = {};
  for (const accountName in partialAccounts) {
    const account = partialAccounts[accountName];
    if (account === null) {
      if (throwOnNull)
        throw new Error("Failed to resolve optionals due to IDL type mismatch with input accounts!");
      continue;
    }
    toReturn[accountName] = isPartialAccounts(account) ? flattenPartialAccounts(account, true) : translateAddress(account);
  }
  return toReturn;
}
var MethodsBuilder = class {
  constructor(_args, _ixFn, _txFn, _rpcFn, _simulateFn, _viewFn, _provider2, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver) {
    this._ixFn = _ixFn;
    this._txFn = _txFn;
    this._rpcFn = _rpcFn;
    this._simulateFn = _simulateFn;
    this._viewFn = _viewFn;
    this._programId = _programId;
    this._accounts = {};
    this._remainingAccounts = [];
    this._signers = [];
    this._preInstructions = [];
    this._postInstructions = [];
    this._autoResolveAccounts = true;
    this._args = _args;
    this._accountsResolver = new AccountsResolver(_args, this._accounts, _provider2, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver);
  }
  args(_args) {
    this._args = _args;
    this._accountsResolver.args(_args);
  }
  async pubkeys() {
    if (this._autoResolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._accounts;
  }
  accounts(accounts) {
    this._autoResolveAccounts = true;
    this._accountsResolver.resolveOptionals(accounts);
    return this;
  }
  accountsStrict(accounts) {
    this._autoResolveAccounts = false;
    this._accountsResolver.resolveOptionals(accounts);
    return this;
  }
  signers(signers) {
    this._signers = this._signers.concat(signers);
    return this;
  }
  remainingAccounts(accounts) {
    this._remainingAccounts = this._remainingAccounts.concat(accounts);
    return this;
  }
  preInstructions(ixs) {
    this._preInstructions = this._preInstructions.concat(ixs);
    return this;
  }
  postInstructions(ixs) {
    this._postInstructions = this._postInstructions.concat(ixs);
    return this;
  }
  async rpc(options) {
    if (this._autoResolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._rpcFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions,
      options
    });
  }
  async rpcAndKeys(options) {
    const pubkeys = await this.pubkeys();
    return {
      pubkeys,
      signature: await this.rpc(options)
    };
  }
  async view(options) {
    if (this._autoResolveAccounts) {
      await this._accountsResolver.resolve();
    }
    if (!this._viewFn) {
      throw new Error("Method does not support views");
    }
    return this._viewFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions,
      options
    });
  }
  async simulate(options) {
    if (this._autoResolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._simulateFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions,
      options
    });
  }
  async instruction() {
    if (this._autoResolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._ixFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions
    });
  }
  /**
   * Convenient shortcut to get instructions and pubkeys via
   * const { pubkeys, instructions } = await prepare();
   */
  async prepare() {
    return {
      instruction: await this.instruction(),
      pubkeys: await this.pubkeys(),
      signers: await this._signers
    };
  }
  async transaction() {
    if (this._autoResolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._txFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions
    });
  }
};
var ViewFactory = class {
  static build(programId, idlIx, simulateFn, idl) {
    const isMut = idlIx.accounts.find((a) => a.isMut);
    const hasReturn = !!idlIx.returns;
    if (isMut || !hasReturn)
      return;
    const view = async (...args) => {
      var _a, _b;
      let simulationResult = await simulateFn(...args);
      const returnPrefix = `Program return: ${programId} `;
      let returnLog = simulationResult.raw.find((l) => l.startsWith(returnPrefix));
      if (!returnLog) {
        throw new Error("View expected return log");
      }
      let returnData = decode2(returnLog.slice(returnPrefix.length));
      let returnType = idlIx.returns;
      if (!returnType) {
        throw new Error("View expected return type");
      }
      const coder2 = IdlCoder.fieldLayout({ type: returnType }, Array.from([...(_a = idl.accounts) !== null && _a !== void 0 ? _a : [], ...(_b = idl.types) !== null && _b !== void 0 ? _b : []]));
      return coder2.decode(returnData);
    };
    return view;
  }
};
var NamespaceFactory = class {
  /**
   * Generates all namespaces for a given program.
   */
  static build(idl, coder2, programId, provider, getCustomResolver) {
    const rpc2 = {};
    const instruction = {};
    const transaction = {};
    const simulate = {};
    const methods = {};
    const view = {};
    const idlErrors = parseIdlErrors(idl);
    const account = idl.accounts ? AccountFactory.build(idl, coder2, programId, provider) : {};
    idl.instructions.forEach((idlIx) => {
      const ixItem = InstructionNamespaceFactory.build(idlIx, (ixName, ix) => coder2.instruction.encode(ixName, ix), programId);
      const txItem = TransactionFactory.build(idlIx, ixItem);
      const rpcItem = RpcFactory.build(idlIx, txItem, idlErrors, provider);
      const simulateItem = SimulateFactory.build(idlIx, txItem, idlErrors, provider, coder2, programId, idl);
      const viewItem = ViewFactory.build(programId, idlIx, simulateItem, idl);
      const methodItem = MethodsBuilderFactory.build(provider, programId, idlIx, ixItem, txItem, rpcItem, simulateItem, viewItem, account, idl.types || [], getCustomResolver && getCustomResolver(idlIx));
      const name = (0, import_camelcase.default)(idlIx.name);
      instruction[name] = ixItem;
      transaction[name] = txItem;
      rpc2[name] = rpcItem;
      simulate[name] = simulateItem;
      methods[name] = methodItem;
      if (viewItem) {
        view[name] = viewItem;
      }
    });
    return [
      rpc2,
      instruction,
      transaction,
      account,
      simulate,
      methods,
      view
    ];
  }
};
var Program = class {
  /**
   * Address of the program.
   */
  get programId() {
    return this._programId;
  }
  /**
   * IDL defining the program's interface.
   */
  get idl() {
    return this._idl;
  }
  /**
   * Coder for serializing requests.
   */
  get coder() {
    return this._coder;
  }
  /**
   * Wallet and network provider.
   */
  get provider() {
    return this._provider;
  }
  /**
   * @param idl       The interface definition.
   * @param programId The on-chain address of the program.
   * @param provider  The network and wallet context to use. If not provided
   *                  then uses [[getProvider]].
   * @param getCustomResolver A function that returns a custom account resolver
   *                          for the given instruction. This is useful for resolving
   *                          public keys of missing accounts when building instructions
   */
  constructor(idl, programId, provider, coder2, getCustomResolver) {
    programId = translateAddress(programId);
    if (!provider) {
      provider = getProvider();
    }
    this._idl = idl;
    this._provider = provider;
    this._programId = programId;
    this._coder = coder2 !== null && coder2 !== void 0 ? coder2 : new BorshCoder(idl);
    this._events = new EventManager(this._programId, provider, this._coder);
    const [rpc2, instruction, transaction, account, simulate, methods, views] = NamespaceFactory.build(idl, this._coder, programId, provider, getCustomResolver !== null && getCustomResolver !== void 0 ? getCustomResolver : () => void 0);
    this.rpc = rpc2;
    this.instruction = instruction;
    this.transaction = transaction;
    this.account = account;
    this.simulate = simulate;
    this.methods = methods;
    this.views = views;
  }
  /**
   * Generates a Program client by fetching the IDL from the network.
   *
   * In order to use this method, an IDL must have been previously initialized
   * via the anchor CLI's `anchor idl init` command.
   *
   * @param programId The on-chain address of the program.
   * @param provider  The network and wallet context.
   */
  static async at(address, provider) {
    const programId = translateAddress(address);
    const idl = await Program.fetchIdl(programId, provider);
    if (!idl) {
      throw new Error(`IDL not found for program: ${address.toString()}`);
    }
    return new Program(idl, programId, provider);
  }
  /**
   * Fetches an idl from the blockchain.
   *
   * In order to use this method, an IDL must have been previously initialized
   * via the anchor CLI's `anchor idl init` command.
   *
   * @param programId The on-chain address of the program.
   * @param provider  The network and wallet context.
   */
  static async fetchIdl(address, provider) {
    provider = provider !== null && provider !== void 0 ? provider : getProvider();
    const programId = translateAddress(address);
    const idlAddr = await idlAddress(programId);
    const accountInfo = await provider.connection.getAccountInfo(idlAddr);
    if (!accountInfo) {
      return null;
    }
    let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));
    const inflatedIdl = inflate_1(idlAccount.data);
    return JSON.parse(decode$2(inflatedIdl));
  }
  /**
   * Invokes the given callback every time the given event is emitted.
   *
   * @param eventName The PascalCase name of the event, provided by the IDL.
   * @param callback  The function to invoke whenever the event is emitted from
   *                  program logs.
   */
  addEventListener(eventName, callback) {
    return this._events.addEventListener(eventName, callback);
  }
  /**
   * Unsubscribes from the given eventName.
   */
  async removeEventListener(listener) {
    return await this._events.removeEventListener(listener);
  }
};
var SYSTEM_PROGRAM_ID = new PublicKey("11111111111111111111111111111111");
function program(provider) {
  return new Program(IDL, SYSTEM_PROGRAM_ID, provider, coder());
}
function coder() {
  return new SystemCoder(IDL);
}
var IDL = {
  version: "0.1.0",
  name: "system_program",
  instructions: [
    {
      name: "createAccount",
      accounts: [
        {
          name: "from",
          isMut: true,
          isSigner: true
        },
        {
          name: "to",
          isMut: true,
          isSigner: true
        }
      ],
      args: [
        {
          name: "lamports",
          type: "u64"
        },
        {
          name: "space",
          type: "u64"
        },
        {
          name: "owner",
          type: "publicKey"
        }
      ]
    },
    {
      name: "assign",
      accounts: [
        {
          name: "pubkey",
          isMut: true,
          isSigner: true
        }
      ],
      args: [
        {
          name: "owner",
          type: "publicKey"
        }
      ]
    },
    {
      name: "transfer",
      accounts: [
        {
          name: "from",
          isMut: true,
          isSigner: true
        },
        {
          name: "to",
          isMut: true,
          isSigner: false
        }
      ],
      args: [
        {
          name: "lamports",
          type: "u64"
        }
      ]
    },
    {
      name: "createAccountWithSeed",
      accounts: [
        {
          name: "from",
          isMut: true,
          isSigner: true
        },
        {
          name: "to",
          isMut: true,
          isSigner: false
        },
        {
          name: "base",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "base",
          type: "publicKey"
        },
        {
          name: "seed",
          type: "string"
        },
        {
          name: "lamports",
          type: "u64"
        },
        {
          name: "space",
          type: "u64"
        },
        {
          name: "owner",
          type: "publicKey"
        }
      ]
    },
    {
      name: "advanceNonceAccount",
      accounts: [
        {
          name: "nonce",
          isMut: true,
          isSigner: false
        },
        {
          name: "recentBlockhashes",
          isMut: false,
          isSigner: false
        },
        {
          name: "authorized",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "authorized",
          type: "publicKey"
        }
      ]
    },
    {
      name: "withdrawNonceAccount",
      accounts: [
        {
          name: "nonce",
          isMut: true,
          isSigner: false
        },
        {
          name: "to",
          isMut: true,
          isSigner: false
        },
        {
          name: "recentBlockhashes",
          isMut: false,
          isSigner: false
        },
        {
          name: "rent",
          isMut: false,
          isSigner: false
        },
        {
          name: "authorized",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "lamports",
          type: "u64"
        }
      ]
    },
    {
      name: "initializeNonceAccount",
      accounts: [
        {
          name: "nonce",
          isMut: true,
          isSigner: true
        },
        {
          name: "recentBlockhashes",
          isMut: false,
          isSigner: false
        },
        {
          name: "rent",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "authorized",
          type: "publicKey"
        }
      ]
    },
    {
      name: "authorizeNonceAccount",
      accounts: [
        {
          name: "nonce",
          isMut: true,
          isSigner: false
        },
        {
          name: "authorized",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "authorized",
          type: "publicKey"
        }
      ]
    },
    {
      name: "allocate",
      accounts: [
        {
          name: "pubkey",
          isMut: true,
          isSigner: true
        }
      ],
      args: [
        {
          name: "space",
          type: "u64"
        }
      ]
    },
    {
      name: "allocateWithSeed",
      accounts: [
        {
          name: "account",
          isMut: true,
          isSigner: false
        },
        {
          name: "base",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "base",
          type: "publicKey"
        },
        {
          name: "seed",
          type: "string"
        },
        {
          name: "space",
          type: "u64"
        },
        {
          name: "owner",
          type: "publicKey"
        }
      ]
    },
    {
      name: "assignWithSeed",
      accounts: [
        {
          name: "account",
          isMut: true,
          isSigner: false
        },
        {
          name: "base",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "base",
          type: "publicKey"
        },
        {
          name: "seed",
          type: "string"
        },
        {
          name: "owner",
          type: "publicKey"
        }
      ]
    },
    {
      name: "transferWithSeed",
      accounts: [
        {
          name: "from",
          isMut: true,
          isSigner: false
        },
        {
          name: "base",
          isMut: false,
          isSigner: true
        },
        {
          name: "to",
          isMut: true,
          isSigner: false
        }
      ],
      args: [
        {
          name: "lamports",
          type: "u64"
        },
        {
          name: "seed",
          type: "string"
        },
        {
          name: "owner",
          type: "publicKey"
        }
      ]
    }
  ],
  accounts: [
    {
      name: "nonce",
      type: {
        kind: "struct",
        fields: [
          {
            name: "version",
            type: "u32"
          },
          {
            name: "state",
            type: "u32"
          },
          {
            name: "authorizedPubkey",
            type: "publicKey"
          },
          {
            name: "nonce",
            type: "publicKey"
          },
          {
            name: "feeCalculator",
            type: {
              defined: "FeeCalculator"
            }
          }
        ]
      }
    }
  ],
  types: [
    {
      name: "FeeCalculator",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lamportsPerSignature",
            type: "u64"
          }
        ]
      }
    }
  ]
};
var Native = class {
  static system(provider) {
    return program(provider);
  }
};
var export_BN = import_bn3.default;
export {
  ACCOUNT_DISCRIMINATOR_SIZE,
  AccountClient,
  AnchorError,
  AnchorProvider,
  export_BN as BN,
  BorshAccountsCoder,
  BorshCoder,
  BorshEventCoder,
  BorshInstructionCoder,
  EventManager,
  EventParser,
  IdlError,
  LangErrorCode,
  LangErrorMessage,
  MethodsBuilderFactory,
  Native,
  Program,
  ProgramError,
  ProgramErrorStack,
  SystemCoder,
  eventDiscriminator,
  getProvider,
  parseIdlErrors,
  setProvider,
  splitArgsAndCtx,
  toInstruction,
  translateAddress,
  translateError,
  index as utils,
  validateAccounts,
  index_browser_esm_exports as web3
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ed25519/lib/esm/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@solana/buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Uint8Array instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@noble/secp256k1/lib/esm/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

js-sha256/src/sha256.js:
  (**
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.9.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   *)

buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Buffer instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/
//# sourceMappingURL=@coral-xyz_anchor.js.map
